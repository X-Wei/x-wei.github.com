<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>mx's blog</title><link href="http://x-wei.github.io/" rel="alternate"></link><link href="http://x-wei.github.io/feeds/tag-scala.atom.xml" rel="self"></link><id>http://x-wei.github.io/</id><updated>2016-08-12T00:00:00+02:00</updated><entry><title>[Functional Program Design in Scala] Lec1: For Expressions and Monads</title><link href="http://x-wei.github.io/progfun2_lec1_forexpr.html" rel="alternate"></link><published>2016-08-12T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-08-12:progfun2_lec1_forexpr.html</id><summary type="html">&lt;h1 id="recap-functions-and-pattern-matching"&gt;Recap: Functions and Pattern Matching&lt;/h1&gt;
&lt;h3 id="case-classes"&gt;case classes&lt;/h3&gt;
&lt;p&gt;ex: json
json objects can be seq, num, str, bool,...&lt;/p&gt;
&lt;p&gt;⇒ represented as abstract class and case classes. &lt;/p&gt;
&lt;h3 id="pattern-matching"&gt;pattern matching&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image002.png"/&gt;&lt;/p&gt;
&lt;p&gt;→ question: what is the type of the &lt;code&gt;{case(key, value)=&amp;gt;"..."}&lt;/code&gt; clause? &lt;/p&gt;
&lt;p&gt;it is &lt;code&gt;(JBinding =&amp;gt; String)&lt;/code&gt; type, which is a shorthand for &lt;code&gt;Function1[JBinding, String]&lt;/code&gt;. &lt;/p&gt;
&lt;h3 id="function1-trait"&gt;Function1 Trait&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image003.png"/&gt;&lt;/p&gt;
&lt;h3 id="subclass-a-function-type"&gt;subclass a function type&lt;/h3&gt;
&lt;p&gt;function types can also be extended ! &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image005.png"/&gt;&lt;/p&gt;
&lt;p&gt;element accessing can be written as function calls because &lt;code&gt;Seq&lt;/code&gt;s are functions!&lt;/p&gt;
&lt;h3 id="partial-match"&gt;Partial Match&lt;/h3&gt;
&lt;p&gt;if there is no match → throw MatchError&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val f: String=&amp;gt;String  = {case "ping" =&amp;gt; "pong"}&lt;/span&gt;
&lt;span class="code-line"&gt;f("ping") // no pb&lt;/span&gt;
&lt;span class="code-line"&gt;f("abc") // MatchError&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ define f as partial function&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val f: PartialFunction[String,String]  = {case "ping" =&amp;gt; "pong"}&lt;/span&gt;
&lt;span class="code-line"&gt;f.isDefinedAt("ping")&lt;/span&gt;
&lt;span class="code-line"&gt;f.isDefinedAt("abc")&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;isDefinedAt&lt;/code&gt; is a method for the &lt;code&gt;PartialFunction&lt;/code&gt; class. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image006.png"/&gt;&lt;/p&gt;
&lt;p&gt;The f definition is translated to: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image007.png"/&gt;&lt;/p&gt;
&lt;p&gt;But the &lt;code&gt;PartialFunction&lt;/code&gt; will only apply for level 1: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image008.png"/&gt;&lt;/p&gt;
&lt;h1 id="recap-collections"&gt;Recap: Collections&lt;/h1&gt;
&lt;p&gt;scala collections hirarchy: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image009.png"/&gt;&lt;/p&gt;
&lt;p&gt;collections &lt;em&gt;share&lt;/em&gt; some general methods (&lt;strong&gt;core methods&lt;/strong&gt;): &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;map&lt;/li&gt;
&lt;li&gt;flatMap&lt;/li&gt;
&lt;li&gt;filter&lt;/li&gt;
&lt;li&gt;foldLeft/foldRight&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(idealized) implementation of &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; on Lists: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image011.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image013.png"/&gt;&lt;/p&gt;
&lt;h3 id="for-expressions"&gt;For expressions&lt;/h3&gt;
&lt;p&gt;for-expr can &lt;em&gt;simplify combinations of core methods&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image014.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;the&lt;/strong&gt; &lt;strong&gt;lhs of a generator can also be a pattern!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image015.png"/&gt;&lt;/p&gt;
&lt;p&gt;pat &amp;lt;- expr &lt;/p&gt;
&lt;p&gt;is translated to : &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;x &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; expr withFilter &lt;span class="p"&gt;{&lt;/span&gt;case pat &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; true&lt;span class="p"&gt;;&lt;/span&gt; case _ &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; false&lt;/span&gt;
&lt;span class="code-line"&gt;                &lt;span class="p"&gt;}&lt;/span&gt; map &lt;span class="p"&gt;{&lt;/span&gt;case pat &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; x&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="11-queries-with-for"&gt;1.1 - Queries with For&lt;/h1&gt;
&lt;p&gt;for notation is equivalent to common ops on databases(ex. sql). &lt;/p&gt;
&lt;p&gt;ex. books in library&lt;/p&gt;
&lt;p&gt;&lt;code&gt;case class Book(title: String, authors: List[String])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;query1: books with author name is "Bird"&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; b&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;books&lt;span class="p"&gt;;&lt;/span&gt; a &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; b.authors &lt;span class="kr"&gt;if&lt;/span&gt; a startsWith &lt;span class="s"&gt;"Bird,"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;yield b.title&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;query2: books with "Program" in the title: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; b&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;books &lt;span class="kr"&gt;if&lt;/span&gt; b.title indexOf &lt;span class="s"&gt;"Program"&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;yield b.title&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;query3: names of authors who wrote &amp;gt;=2 books&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    b1 &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; books&lt;/span&gt;
&lt;span class="code-line"&gt;    b2 &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; books &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kr"&gt;if&lt;/span&gt; b1&lt;span class="o"&gt;!=&lt;/span&gt;b2&lt;/span&gt;
&lt;span class="code-line"&gt;    a1 &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; b1.authors&lt;/span&gt;
&lt;span class="code-line"&gt;    a2 &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; b2.authors&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kr"&gt;if&lt;/span&gt; a1&lt;span class="o"&gt;==&lt;/span&gt;a2&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield a1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;→ pb: the authors will be doubled → b1,b2 and b2,b1
⇒ change line 3 to &lt;code&gt;b1.title &amp;lt; b2.title&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;→ still pb: print 3 times if authors write 3 books... 
⇒ 
sol1. use &lt;code&gt;distinct&lt;/code&gt; function 
sol2. decalre books as Set instead of List. &lt;/p&gt;
&lt;h1 id="12-translation-of-for"&gt;1.2 - Translation of For&lt;/h1&gt;
&lt;p&gt;for expressions → higer order functions&lt;/p&gt;
&lt;p&gt;map, flatMap, filter can all be implemented with for expression:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image016.png"/&gt;&lt;/p&gt;
&lt;p&gt;In reality: scala translates for expr to map/flatMap/filter. &lt;/p&gt;
&lt;h3 id="implemention-of-for-expr-3-rules"&gt;implemention of for-expr: 3 rules&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rule 1: in for(..) only a simple generator &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;for(x &amp;lt;- l1) yield e2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;is translated to: &lt;code&gt;l1.map(x =&amp;gt; e2)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rule2: in for(..), followed by the generator there is a filter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;for(x &amp;lt;- l1 if f; s) yield e2 //s is seq of other generators and filters&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;is translated to: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;for( x &amp;lt;- l1.withFilter(x=&amp;gt;f) ) yield e2&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rule3: in for(..), starts with 2 generators → flatMap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;for( x&amp;lt;-l1; y&amp;lt;-l2; s) yield e3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;is translated to: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;l1.flatMap( x =&amp;gt; for(y&amp;lt;-l2; s) yield e3 )&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;example: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;b &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; books&lt;/span&gt;
&lt;span class="code-line"&gt;a &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; b.authors &lt;span class="kr"&gt;if&lt;/span&gt; a startsWith &lt;span class="s"&gt;"Bird"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield b.title&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;translated to: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;books flatMap ( &lt;/span&gt;
&lt;span class="code-line"&gt;    b =&amp;gt; b.authors.filter( a =&amp;gt; a startsWith "Bird").map(y=&amp;gt;y.title)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;NB: for expr is not restricted to collections, it supports any types with &lt;code&gt;map/flatMap/withFilter&lt;/code&gt; method. ⇒ use for expr for your own types as well. &lt;/p&gt;
&lt;h1 id="13-functional-random-generators"&gt;1.3 - Functional Random Generators&lt;/h1&gt;
&lt;p&gt;goal: use for expr on rand generators. &lt;/p&gt;
&lt;p&gt;for expr support any type with map/flatMap/filter ⇒ ex. rand value generator. &lt;/p&gt;
&lt;p&gt;generate rand value of type T: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;trait Generator[+T] { &lt;/span&gt;
&lt;span class="code-line"&gt;def generate: T&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;first implement Generator[Int], then use this to implement booleans, pairs, lists, sets, trees,......&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val integers = new Generator[Int]{&lt;/span&gt;
&lt;span class="code-line"&gt;    val rand = new java.util.Random&lt;/span&gt;
&lt;span class="code-line"&gt;    def generate = rand.nextInt()&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;val booleans = new Generator[Boolean{&lt;/span&gt;
&lt;span class="code-line"&gt;    def generate = integers.generate &amp;gt; 0&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;val pairs = new Generator[(Int, Int)]{&lt;/span&gt;
&lt;span class="code-line"&gt;    def generate = (integers.generate, integers.generate)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;→ can we avoid the &lt;code&gt;new Generator[...]&lt;/code&gt; ? &lt;/p&gt;
&lt;p&gt;&lt;em&gt;ideally we want to write booleans as pairs as:&lt;/em&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val booleans &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; x &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; integers &lt;span class="p"&gt;)&lt;/span&gt; yield x&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def pairs&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;U&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="kp"&gt;t&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; Generator&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;T&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; u&lt;span class="o"&gt;:&lt;/span&gt; Generator&lt;span class="p"&gt;[&lt;/span&gt;U&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;x &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; y &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; u&lt;span class="p"&gt;}&lt;/span&gt; yield &lt;span class="p"&gt;(&lt;/span&gt;x&lt;span class="p"&gt;,&lt;/span&gt;y&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the for expr will be translated to map/flatMap/filter... &lt;/p&gt;
&lt;p&gt;⇒ define map and flatMap on the Generator trait so that it supports for expr!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;trait Generator[+T]{&lt;/span&gt;
&lt;span class="code-line"&gt;    self =&amp;gt; // syntax: `self` is an alias of `this`&lt;/span&gt;
&lt;span class="code-line"&gt;    def generate: T&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    def map[S](f: T=&amp;gt;S): Generator[S] = &lt;/span&gt;
&lt;span class="code-line"&gt;        new Generator[S]{&lt;/span&gt;
&lt;span class="code-line"&gt;            def generate = f(self.generate) // can't use `this` here: inf loop&lt;/span&gt;
&lt;span class="code-line"&gt;            // or use Generator.this.generate&lt;/span&gt;
&lt;span class="code-line"&gt;        }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    def flatMap(f: T=&amp;gt;Generator[S]): Generator[S] = &lt;/span&gt;
&lt;span class="code-line"&gt;        new Generator[S]{   &lt;/span&gt;
&lt;span class="code-line"&gt;            def generate = f(self.generate).generate &lt;/span&gt;
&lt;span class="code-line"&gt;        }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ex. the booleans expression: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;val booleans = for (x&amp;lt;-integers) yield x&amp;gt;0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;is translated to: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;val booleans = integers map (x=&amp;gt;x&amp;gt;0)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;which is then expands to: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val booleans = &lt;/span&gt;
&lt;span class="code-line"&gt;new Generator[Boolean]{&lt;/span&gt;
&lt;span class="code-line"&gt;    val f = (x =&amp;gt; x&amp;gt;0)&lt;/span&gt;
&lt;span class="code-line"&gt;    def generate = f(integers.generate)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;after reduction, the expression is: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val booleans = new Generator[Boolean{&lt;/span&gt;
&lt;span class="code-line"&gt;    def generate = integers.generate &amp;gt; 0&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is the initial implementation... &lt;/p&gt;
&lt;h3 id="other-base-generators"&gt;other base Generators&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image017.png"/&gt;&lt;/p&gt;
&lt;p&gt;(The &lt;code&gt;T*&lt;/code&gt; syntax is variable parameter)&lt;/p&gt;
&lt;h3 id="rand-list-generator"&gt;rand List Generator&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def lists&lt;span class="o"&gt;:&lt;/span&gt; Generator&lt;span class="p"&gt;[&lt;/span&gt;List&lt;span class="p"&gt;[&lt;/span&gt;Int&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    isEmpty &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; booleans&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;list&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kr"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;isEmpty&lt;span class="p"&gt;)&lt;/span&gt; emptyLists &lt;span class="kr"&gt;else&lt;/span&gt; nonEmptyLists&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield &lt;span class="kt"&gt;list&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def emptyLists &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;single&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;Nil&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def nonEmptyLists &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    head &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; integers&lt;/span&gt;
&lt;span class="code-line"&gt;    tail &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; lists &lt;span class="o"&gt;//&lt;/span&gt; recursive call to &lt;span class="sb"&gt;`lists`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield &lt;span class="kp"&gt;head&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kp"&gt;tail&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="rand-binary-tree-generator"&gt;rand (binary) Tree Generator&lt;/h3&gt;
&lt;p&gt;two types of tree nodes: leaf or inner node&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def trees&lt;span class="o"&gt;:&lt;/span&gt; Generator&lt;span class="p"&gt;[&lt;/span&gt;Tree&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    isLeaf &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; booleans&lt;/span&gt;
&lt;span class="code-line"&gt;    tree &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;isLeaf&lt;span class="p"&gt;)&lt;/span&gt; leafs &lt;span class="kr"&gt;else&lt;/span&gt; inners&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield tree&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def leafs&lt;span class="o"&gt;:&lt;/span&gt; Generator&lt;span class="p"&gt;[&lt;/span&gt;Leaf&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    x &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; integers&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield Leaf&lt;span class="p"&gt;(&lt;/span&gt;x&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def inners&lt;span class="o"&gt;:&lt;/span&gt; Generator&lt;span class="p"&gt;[&lt;/span&gt;Inner&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    l &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; trees&lt;/span&gt;
&lt;span class="code-line"&gt;    r &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; trees&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield Inner&lt;span class="p"&gt;(&lt;/span&gt;l&lt;span class="p"&gt;,&lt;/span&gt; r&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="application-random-testing"&gt;Application: random testing&lt;/h2&gt;
&lt;p&gt;test: check &lt;em&gt;postconditions&lt;/em&gt; (expected results)&lt;/p&gt;
&lt;p&gt;→ generate random test inputs&lt;/p&gt;
&lt;p&gt;a generic wrapper:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def randTest[T](g: Generator[T], numTimes: Int=100)(testfcn: T=&amp;gt;Boolean): Unit = {&lt;/span&gt;
&lt;span class="code-line"&gt;    for( i &lt;span class="nt"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="err"&gt;0&lt;/span&gt; &lt;span class="err"&gt;until&lt;/span&gt; &lt;span class="err"&gt;numTimes){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="err"&gt;val&lt;/span&gt; &lt;span class="na"&gt;value:T =&lt;/span&gt; &lt;span class="s"&gt;g.generate&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="err"&gt;assert(testfcn(value),&lt;/span&gt; &lt;span class="err"&gt;"test&lt;/span&gt; &lt;span class="err"&gt;failed&lt;/span&gt; &lt;span class="err"&gt;for&lt;/span&gt; &lt;span class="err"&gt;"+value)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="err"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="err"&gt;println("passed"&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="err"&gt;numTime&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="err"&gt;"tests")&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="scalacheck"&gt;ScalaCheck&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;instead of writing tests, write properties that are assumed to hold.&lt;/em&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;forAll { &lt;/span&gt;
&lt;span class="code-line"&gt;    (l1:List[Int], l2:List[Int]) =&amp;gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        l1.size + l2.size == (l1++l2).size&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="14-monads"&gt;1.4 - Monads&lt;/h1&gt;
&lt;p&gt;from last section: not only collections, but also any type with map and flatmap can use for expr ⇒ monads. &lt;/p&gt;
&lt;p&gt;&lt;def&gt;. Monads is a type M[T] with 2 operations: &lt;code&gt;flatMap&lt;/code&gt; ("bind") and &lt;code&gt;unit&lt;/code&gt;, and satisfy some laws.&lt;/def&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;train M[T]{&lt;/span&gt;
&lt;span class="code-line"&gt;    def flatMap[U](f: T=&amp;gt;M[U]): M[U]): M[U]&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;def unit[T](x:T): M[T]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;examples: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt; is a monad, &lt;code&gt;unit(x) = List(x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&lt;/code&gt;, with &lt;code&gt;unit(x) = Set(x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Option&lt;/code&gt;, with &lt;code&gt;unit(x) = Some(x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Generator&lt;/code&gt;, with &lt;code&gt;unit(x) = single(x)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt; can be defined as a combination of &lt;code&gt;flatMap&lt;/code&gt; and &lt;code&gt;unit&lt;/code&gt;: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;m map f == m flatMap (x =&amp;gt; unit( f(x)) )&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="monad-laws"&gt;Monad laws&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;associativity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;(m flatMap f) flatMap g == m flatMap ( x =&amp;gt; f(x) flatMap g )&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;↔ (x+y+z) = x+(y+z)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;left unit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;unit(x) flatMap f == f(x)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;right unit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;m flatMap unit == m&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="the-try-type"&gt;the Try type&lt;/h2&gt;
&lt;p&gt;We define a Try class, which is similar to Option class. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;abstraxt class Try[+T]&lt;/span&gt;
&lt;span class="code-line"&gt;case class Success[T](x:T) extends Try[T]&lt;/span&gt;
&lt;span class="code-line"&gt;case class Failure(ex: Exception) extends Try[Nothing]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we can write &lt;code&gt;Try(expr)&lt;/code&gt; to give a computation a try, by implementing the &lt;code&gt;apply&lt;/code&gt; method of object Try:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;object Try{&lt;/span&gt;
&lt;span class="code-line"&gt;def apply[T](expr: =&amp;gt;T): Try[T]= // expr is passed BY NAME, otherwise will cause exception in eval&lt;/span&gt;
&lt;span class="code-line"&gt;    try Success(expr) // java syntax of try-catch&lt;/span&gt;
&lt;span class="code-line"&gt;    catch{ case NonFatal(ex) =&amp;gt; Failure(ex) }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;if Try is a Monad ⇒ can be written in for expr: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image018.png"/&gt;&lt;/p&gt;
&lt;p&gt;⇒ define map and flatMap on &lt;code&gt;Try&lt;/code&gt; type. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun2_lec1_forexpr/pasted_image019.png"/&gt;&lt;/p&gt;
&lt;p&gt;question: is Try a monad with &lt;code&gt;unit(x)=Try(x)&lt;/code&gt;?
⇒ no, left-unit fails: &lt;code&gt;Try(expr) flatMap f != f(expr)&lt;/code&gt;
(lhs never nonfatal exception, but rhs will raise)&lt;/p&gt;
&lt;p&gt;Try is not a monad, but it can still use for expr...&lt;/p&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;for exprs are useful not only for collections: &lt;code&gt;Generator&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt;, &lt;code&gt;Try&lt;/code&gt;&lt;/p&gt;</summary><category term="scala"></category></entry><entry><title>[Functional Programming Principles in Scala] Lec6: Collections</title><link href="http://x-wei.github.io/progfun1_lec6_collections.html" rel="alternate"></link><published>2016-07-30T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-07-30:progfun1_lec6_collections.html</id><summary type="html">&lt;h1 id="61-other-collections"&gt;6.1 - Other Collections&lt;/h1&gt;
&lt;p&gt;so far: only seen List. → more (&lt;strong&gt;immutable&lt;/strong&gt;) collections. &lt;/p&gt;
&lt;h3 id="vector"&gt;vector&lt;/h3&gt;
&lt;p&gt;List:  is linear -- access to head is faster than middle or end element. 
Vector: better rand access performance. &lt;/p&gt;
&lt;p&gt;represented as very shallow trees(32-split at each node)&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec6_collections/pasted_image.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt; support similar operations as List (head, tail,map, fold) , except concat &lt;code&gt;::&lt;/code&gt;, instead Vectors have &lt;code&gt;+:&lt;/code&gt; and &lt;code&gt;:+&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x +: xs&lt;/code&gt; create new vector with x in head&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs :+ x&lt;/code&gt; create new vector with x in tail&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;implementation of &lt;code&gt;:+&lt;/code&gt;: create copies&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec6_collections/pasted_image002.png"/&gt;&lt;/p&gt;
&lt;h3 id="seq"&gt;Seq&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Seq&lt;/code&gt; is base class for &lt;code&gt;Vector&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Seq&lt;/code&gt; itself is subclass of &lt;code&gt;Iterable&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Hierarchy of Iterables: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec6_collections/pasted_image005.png"/&gt;&lt;/p&gt;
&lt;h3 id="array-ans-string"&gt;Array ans String&lt;/h3&gt;
&lt;p&gt;Array and String support same op as Seq, can implicitly be converted to seq when needed. But they are NOT subclasses of Seq as they come from java. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;scala&amp;gt; val xs: Array[Int] = Array(1,2,3)&lt;/span&gt;
&lt;span class="code-line"&gt;xs: Array[Int] = Array(1, 2, 3)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; xs map (2*_)&lt;/span&gt;
&lt;span class="code-line"&gt;res3: Array[Int] = Array(2, 4, 6)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; val ys = "Hello"&lt;/span&gt;
&lt;span class="code-line"&gt;ys: String = Hello&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; ys filter (_.isUpper)&lt;/span&gt;
&lt;span class="code-line"&gt;res4: String = H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="range"&gt;Range&lt;/h3&gt;
&lt;p&gt;represents a seq of evenly spaced integers.&lt;/p&gt;
&lt;p&gt;represented as an obj with 3 values: lower bound, upper bound, step value. &lt;/p&gt;
&lt;p&gt;3 op: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;to&lt;/code&gt;: inclusive &lt;/li&gt;
&lt;li&gt;&lt;code&gt;until&lt;/code&gt;: exclusive&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;by&lt;/code&gt;: step value&lt;/p&gt;
&lt;p&gt;1 to 6       // 1 2 3 4 5 6
1 until 6    // 1 2 3 4 5
1 to 6 by 2  // 1 3 5
6 to 1 by -2 // 6 4 2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="more-ops-on-seq"&gt;More ops on Seq&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xs exists p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs forall p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xs zip ys&lt;/code&gt;: takes 2 seq, returns a single seq, each elem is a pair&lt;/p&gt;
&lt;p&gt;scala&amp;gt; List(1,2,3) zip Vector(2,3,4)
res7: List[(Int, Int)] = List((1,2), (2,3), (3,4))&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xs.unzip&lt;/code&gt;: reverse zip, return 2 lists &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xs flatMap f&lt;/code&gt;: apply f to all elements, and &lt;strong&gt;concat the results&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;scala&amp;gt; "hello" flatMap (c =&amp;gt; List('.', c))
res9: String = .h.e.l.l.o&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;flatten&lt;/code&gt;: flatten a seq of seq into just one seq...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;xs flatMap f = (xs map f).flatten&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The result is concated, instead of being a list of list. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xs.sum&lt;/code&gt;/&lt;code&gt;xs.product&lt;/code&gt;: for numeric collection&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.max&lt;/code&gt;/&lt;code&gt;xs.min&lt;/code&gt;: an ordering must exist&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="examples"&gt;Examples&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;cartesen product: 1..M x 1..N:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;(1 to M) flatMap( x =&amp;gt; (1 to N) map (y =&amp;gt; (x,y)) )&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scalar of 2 vectors&lt;/p&gt;
&lt;p&gt;def scalaProd(xs: Vector[Double], ys: Vector[Double]): Double = 
  (xs zip ys) map (xy =&amp;gt; xy._1 * xy._2).sum&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;alternative: use pattern matching in map (need to add braces &lt;code&gt;{}&lt;/code&gt;!): &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;(xs zip ys) map ( {case(x,y) =&amp;gt; x*y}).sum&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;test isPrime for a number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;def isPrime(n: Int): Boolean = (2 until n) forall (d =&amp;gt; n%d!=0)&lt;/code&gt;&lt;/p&gt;
&lt;h1 id="62-combinatorial-search-and-for-expressions"&gt;6.2 - Combinatorial Search and For-Expressions&lt;/h1&gt;
&lt;p&gt;goal: handle nested seq. &lt;/p&gt;
&lt;p&gt;⇒ extend usage of higher order functions instead of using nested loops. &lt;/p&gt;
&lt;p&gt;example:   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;given n, find all (i,j) st: 1&amp;lt;=j&amp;lt;i&amp;lt;=n, and i+j is prime.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(1 until n) flatMap ( i =&amp;gt; (1 until i) map (j =&amp;gt; (i,j)) ) filter ( {case(i,j) =&amp;gt; isPrime(i+j)})&lt;/p&gt;
&lt;p&gt;this works, but less understandable... ⇒ for expressions. &lt;/p&gt;
&lt;h3 id="foryield-expressions"&gt;for/yield expressions&lt;/h3&gt;
&lt;p&gt;example: class of person&lt;/p&gt;
&lt;p&gt;&lt;code&gt;case class Person(name: String, age: Int)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;To obtain names of persons over 20 years old: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;persons filter (_.age&amp;gt;20) map (_.name)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;equivalent to :&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for (p &amp;lt;- person if p.age &amp;gt; 20) yield p.name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The for expression is similar to jave for-loop, except &lt;strong&gt;it builds a list of the results of all iterations&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;for expression form: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;for( s ) yield e&lt;/code&gt;
where &lt;code&gt;s&lt;/code&gt; can contain &lt;strong&gt;generators&lt;/strong&gt; and &lt;strong&gt;filters&lt;/strong&gt;: &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;generator: &lt;code&gt;p&amp;lt;-e&lt;/code&gt; where &lt;code&gt;e&lt;/code&gt; is a collection, &lt;code&gt;p&lt;/code&gt; is a pattern&lt;/li&gt;
&lt;li&gt;filter: &lt;code&gt;if f&lt;/code&gt; where t is boolean expr&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;rewrite the prime sum example: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  i &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; until n&lt;/span&gt;
&lt;span class="code-line"&gt;  j &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; until i&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="kr"&gt;if&lt;/span&gt; isPrime&lt;span class="p"&gt;(&lt;/span&gt;i&lt;span class="o"&gt;+&lt;/span&gt;j&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield &lt;span class="p"&gt;(&lt;/span&gt;i&lt;span class="p"&gt;,&lt;/span&gt;j&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;exercice: write the scalaProd using for expr: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def scalaProd&lt;span class="p"&gt;(&lt;/span&gt;xs&lt;span class="o"&gt;:&lt;/span&gt; Vector&lt;span class="p"&gt;[&lt;/span&gt;Double&lt;span class="p"&gt;],&lt;/span&gt; ys&lt;span class="o"&gt;:&lt;/span&gt; Vector&lt;span class="p"&gt;[&lt;/span&gt;Double&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; Double &lt;span class="o"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;x&lt;span class="p"&gt;,&lt;/span&gt;y&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; xs zip ys &lt;span class="p"&gt;)&lt;/span&gt; yield x&lt;span class="o"&gt;*&lt;/span&gt;y &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kp"&gt;sum&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;more on scala for expr: 
&lt;a href="http://www.artima.com/pins1ed/for-expressions-revisited.html"&gt;http://www.artima.com/pins1ed/for-expressions-revisited.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="63-combinatorial-search-example"&gt;6.3 - Combinatorial Search Example&lt;/h1&gt;
&lt;p&gt;goal: combine &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt;-expr to solve the n-queens problem. &lt;/p&gt;
&lt;h3 id="sets"&gt;Sets&lt;/h3&gt;
&lt;p&gt;3 fundamental iterable collection types: seq, &lt;strong&gt;set&lt;/strong&gt;, map. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set support most operations on seq (c.f. doc on Iterable)&lt;/li&gt;
&lt;li&gt;sets are unordered&lt;/li&gt;
&lt;li&gt;set don't have dup elements&lt;/li&gt;
&lt;li&gt;contains: &lt;code&gt;s contains e&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="example-n-queens"&gt;Example: N-Queens&lt;/h3&gt;
&lt;p&gt;8*8 chess board, 8 queens 
⇒ places queens st: no two queen in same row/col/diag&lt;/p&gt;
&lt;p&gt;algo: put one queen in each row (in the right column) &lt;/p&gt;
&lt;p&gt;recursive solution: suppose already have solutions for first n-1 rows. 
represent each (partial)solution as a list of column index. &lt;/p&gt;
&lt;p&gt;return all possible solutions (as a Set). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def queens(n: Int): Set[List[Int]] = {&lt;/span&gt;
&lt;span class="code-line"&gt;    def placeQueens(k: Int): Set[List[Int]] = ???// place first k rows&lt;/span&gt;
&lt;span class="code-line"&gt;    placeQueens(n)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fill in the helper function: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def placeQueens&lt;span class="p"&gt;(&lt;/span&gt;k&lt;span class="o"&gt;:&lt;/span&gt; Int&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; Set&lt;span class="p"&gt;[&lt;/span&gt;List&lt;span class="p"&gt;[&lt;/span&gt;Int&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kr"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;k&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; Set&lt;span class="p"&gt;(&lt;/span&gt;List&lt;span class="p"&gt;())&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kr"&gt;else&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        queens &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; placeQueens&lt;span class="p"&gt;(&lt;/span&gt;k&lt;span class="m"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; queens&lt;span class="p"&gt;(&lt;/span&gt;List&lt;span class="p"&gt;[&lt;/span&gt;Int&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; one solution to k&lt;span class="m"&gt;-1&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="kt"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; until n&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="kr"&gt;if&lt;/span&gt; isSafe&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; queens&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="kr"&gt;if&lt;/span&gt; column &lt;span class="kt"&gt;c&lt;/span&gt; doesn&lt;span class="s"&gt;'&lt;/span&gt;&lt;span class="err"&gt;t conflict with the partial solution queens&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt; yield &lt;span class="kt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;queens &lt;span class="o"&gt;//&lt;/span&gt; the kth row solution is &lt;span class="kr"&gt;in&lt;/span&gt; head of &lt;span class="kt"&gt;list&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now fill in the function isSafe that check if a column is valid wrt queens for above rows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def isSafe(col: Int, queens: List[Int]): Boolean = {&lt;/span&gt;
&lt;span class="code-line"&gt;    val k = queens.length // current row is k&lt;/span&gt;
&lt;span class="code-line"&gt;    val indexedQueens = (k-1 to 0 by -1) zip queens // List[(row, col)]&lt;/span&gt;
&lt;span class="code-line"&gt;    indexedQueens forall { &lt;/span&gt;
&lt;span class="code-line"&gt;            case(r,c) =&amp;gt; c!=col &amp;amp;&amp;amp; k-r!=math.abs(c-col) }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now the queens function will work. &lt;/p&gt;
&lt;p&gt;Write another function to print the solution out: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def show&lt;span class="p"&gt;(&lt;/span&gt;queens&lt;span class="o"&gt;:&lt;/span&gt; List&lt;span class="p"&gt;[&lt;/span&gt;Int&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; String &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    val lines &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;col &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; queens.reverse&lt;span class="p"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;                yield Vector.fill&lt;span class="p"&gt;(&lt;/span&gt;queens.length&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"* "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="m"&gt;.&lt;/span&gt;updated&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;col&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"X "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="m"&gt;.&lt;/span&gt;mkString&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="s"&gt;"\n"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; lines.mkString&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;(&lt;/span&gt;queens&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; map show&lt;span class="p"&gt;)&lt;/span&gt; mkString &lt;span class="s"&gt;"====\n"&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="64-maps"&gt;6.4 - Maps&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Map[Key, Value]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ex: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val romanNumerals = Map("I" -&amp;gt;1, "V" -&amp;gt;5, "X" -&amp;gt; 10)&lt;/span&gt;
&lt;span class="code-line"&gt;val captial = Map("France" -&amp;gt; "Paris", "US" -&amp;gt; "Washington")&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Maps are iterables and &lt;strong&gt;functions&lt;/strong&gt;: maps Key to Value like a function call &lt;/p&gt;
&lt;p&gt;ex. &lt;code&gt;romanNumerals("I")&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;will throw &lt;code&gt;NoSuchElementException&lt;/code&gt; if the key is not in map. &lt;/p&gt;
&lt;p&gt;⇒ use &lt;code&gt;get&lt;/code&gt;: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;scala&amp;gt; captial("France")&lt;/span&gt;
&lt;span class="code-line"&gt;res3: String = Paris&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; captial get "France"&lt;/span&gt;
&lt;span class="code-line"&gt;res4: Option[String] = Some(Paris)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; captial get "China"&lt;/span&gt;
&lt;span class="code-line"&gt;res5: Option[String] = None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;have a look at the Option type:&lt;/p&gt;
&lt;h3 id="the-option-type"&gt;The Option Type&lt;/h3&gt;
&lt;p&gt;definition: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;trait Option[+A]&lt;/span&gt;
&lt;span class="code-line"&gt;case class Some[+A](value: A] extends Option[A]&lt;/span&gt;
&lt;span class="code-line"&gt;object None extends Option[Nothing]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;so the get function of map gives: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;None&lt;/code&gt; if key is not in map&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Some(x)&lt;/code&gt; if map associates key to x&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;since &lt;code&gt;Some&lt;/code&gt; is case class, can use pattern matching to decompose. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def showCaptical(country: String) = captial.get(country) match{&lt;/span&gt;
&lt;span class="code-line"&gt;    case Some(cap) =&amp;gt; cap&lt;/span&gt;
&lt;span class="code-line"&gt;    case None =&amp;gt; "missing data"&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="sorted-and-groupby"&gt;Sorted and GroupBy&lt;/h3&gt;
&lt;p&gt;two useful SQL queries. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;orderBy can be expressed using sortWith and sorted: &lt;/p&gt;
&lt;p&gt;val fruit = List("apple", "pear", "orange", "pineapple")
scala&amp;gt; fruit sortWith (&lt;em&gt;.length &amp;lt; &lt;/em&gt;.length)
res7: List[String] = List(pear, apple, orange, pineapple)
scala&amp;gt; fruit.sorted
res8: List[String] = List(apple, orange, pear, pineapple)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;GroupBy(f)&lt;/code&gt;: &lt;strong&gt;partition a collection into a map of collections&lt;/strong&gt; according to &lt;code&gt;f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; fruit groupBy (_.head)
res9: scala.collection.immutable.Map[Char,List[String]] = 
        Map(p -&amp;gt; List(pear, pineapple), 
            a -&amp;gt; List(apple), 
            o -&amp;gt; List(orange))&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="map-example-polynomials"&gt;map Example: polynomials&lt;/h3&gt;
&lt;p&gt;can be seen as map from exponents to coefficients:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec6_collections/pasted_image006.png"/&gt;&lt;/p&gt;
&lt;p&gt;⇒ represent polynm as maps&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;class Poly(val terms: Map[Int, Double]) {&lt;/span&gt;
&lt;span class="code-line"&gt;    def + (other: Poly) = new Poly(terms ++ // ++ on maps: will override older entries in terms!&lt;/span&gt;
&lt;span class="code-line"&gt;                            (other.terms maps adjust)) // adjust defined below&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    def adjust(term: (Int, Double)):(Int, Double) = {&lt;/span&gt;
&lt;span class="code-line"&gt;        val (exp, coeff) = term&lt;/span&gt;
&lt;span class="code-line"&gt;        terms get exp match{&lt;/span&gt;
&lt;span class="code-line"&gt;            case None =&amp;gt; Pair(exp, coeff) // or write: exp -&amp;gt; coeff&lt;/span&gt;
&lt;span class="code-line"&gt;            case Some(coeff1) =&amp;gt; Pair(exp, coeff+coeff1)&lt;/span&gt;
&lt;span class="code-line"&gt;        }&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;    override def toString = &lt;/span&gt;
&lt;span class="code-line"&gt;    (for( (exp, coeff) &lt;span class="nt"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="err"&gt;terms.toList.sorted.reverse)&lt;/span&gt; &lt;span class="err"&gt;yield&lt;/span&gt; &lt;span class="err"&gt;coeff+"x^"+exp)&lt;/span&gt; &lt;span class="err"&gt;mkString&lt;/span&gt; &lt;span class="err"&gt;"+&lt;/span&gt; &lt;span class="err"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="default-values"&gt;default values&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;withDefulatValue&lt;/code&gt;: makes a map into a &lt;strong&gt;total map&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rewrite the poly example: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;class Poly&lt;span class="p"&gt;(&lt;/span&gt;terms0&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kp"&gt;Map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;Int&lt;span class="p"&gt;,&lt;/span&gt; Double&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    val terms &lt;span class="o"&gt;=&lt;/span&gt; terms0 withDefaultValue &lt;span class="m"&gt;0.0&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    def &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;other&lt;span class="o"&gt;:&lt;/span&gt; Poly&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; new Poly&lt;span class="p"&gt;(&lt;/span&gt;terms &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; on maps&lt;span class="o"&gt;:&lt;/span&gt; will override older entries &lt;span class="kr"&gt;in&lt;/span&gt; terms&lt;span class="o"&gt;!&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;                            &lt;span class="p"&gt;(&lt;/span&gt;other.terms maps adjust&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; adjust defined below&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    def adjust&lt;span class="p"&gt;(&lt;/span&gt;term&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;Int&lt;span class="p"&gt;,&lt;/span&gt; Double&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;Int&lt;span class="p"&gt;,&lt;/span&gt; Double&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        val &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; coeff&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; term&lt;/span&gt;
&lt;span class="code-line"&gt;        exp &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;coeff &lt;span class="o"&gt;+&lt;/span&gt; terms&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    override def toString &lt;span class="o"&gt;=&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; coeff&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; terms.toList.sorted.reverse&lt;span class="p"&gt;)&lt;/span&gt; yield coeff&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;"x^"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="kp"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; mkString &lt;span class="s"&gt;"+ "&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;change to variable parameter for better constructor calling: add another constructor&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def this(bindings: (int, Double)*) = // bindings is s sequence&lt;/span&gt;
&lt;span class="code-line"&gt;this(bindings.toMap)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Exercie: re-implement the &lt;code&gt;+&lt;/code&gt; using foldLeft : &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def + (other: Poly) =&lt;/span&gt;
&lt;span class="code-line"&gt;    new Poly( (other.terms foldLeft terms)(addTerm) )&lt;/span&gt;
&lt;span class="code-line"&gt;def addTerm(terms:Map[Int, Double], term: (Int, Double)): Map[Int, Double] = {&lt;/span&gt;
&lt;span class="code-line"&gt;    val (exp, coeff) = term&lt;/span&gt;
&lt;span class="code-line"&gt;    terms + ( exp -&amp;gt; (coeff + terms(exp)) ) // map + (k,v) updates the map&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="65-putting-the-pieces-together-t9-keyboard-mnem"&gt;6.5 - Putting the Pieces Together: T9 keyboard mnem&lt;/h1&gt;
&lt;p&gt;convert a seq of numbers to a scentence&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val mnem  = Map('2'-&amp;gt;"ABC", '3'-&amp;gt;"DEF", 4-&amp;gt;"GHI", '5'-&amp;gt;"JKL",&lt;/span&gt;
&lt;span class="code-line"&gt;            '6'-&amp;gt;"MNO", '7'-&amp;gt;"PQRS", '8'-&amp;gt;"TUV", '9'-&amp;gt;"WXYZ" )&lt;/span&gt;
&lt;span class="code-line"&gt;val in = Source.fromURL("...")&lt;/span&gt;
&lt;span class="code-line"&gt;val words = in.getLines.toList // dictionary: list of valid words&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;goal: design a &lt;code&gt;translate(phoneNumber)&lt;/code&gt; that produces all phrases of words that can serve as mnemonics(助忆) for a phone number. &lt;/p&gt;
&lt;p&gt;Step 1: invert the mnem map to a map from A~Z to 2~9: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val charCode: Map[Char, Char] = &lt;/span&gt;
&lt;span class="code-line"&gt;for ( (digit, str) &lt;span class="nt"&gt;&amp;lt;-mnem&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt; &lt;span class="err"&gt;ltr&amp;lt;-str)&lt;/span&gt; &lt;span class="err"&gt;yield&lt;/span&gt; &lt;span class="err"&gt;ltr-&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;digit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step 2: map a word to the string it represents, ex. "java"-&amp;gt;"5282"&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def wordCode(word: String):String = &lt;/span&gt;
&lt;span class="code-line"&gt;    word.toUpperCase map charCode&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step 3: maps from digit string to all possible valid strings, ex. "5282"-&amp;gt;List("java", "kata",...)
⇒ just a groupby!!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val wordsForNum: Map[String, Seq[String]] = &lt;/span&gt;
&lt;span class="code-line"&gt;    words groupBy wordCode&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;→ Error: key not found: "-", some words contains a "-"... → drop such words... &lt;/p&gt;
&lt;p&gt;&lt;code&gt;val words = in.getLines.toList filter (wd =&amp;gt; wd forall (ch =&amp;gt; ch.isLetter))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Step 4: return all ways to encode a number as a list of words →  recursive, recurse on the nb of first words~&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def encode&lt;span class="p"&gt;(&lt;/span&gt;number&lt;span class="o"&gt;:&lt;/span&gt; String&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; Set&lt;span class="p"&gt;[&lt;/span&gt;List&lt;span class="p"&gt;[&lt;/span&gt;String&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;number.isEmpty&lt;span class="p"&gt;)&lt;/span&gt; Set&lt;span class="p"&gt;(&lt;/span&gt;List&lt;span class="p"&gt;())&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kp"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;        val phraseList &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;            split &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; to number.length &lt;span class="o"&gt;//&lt;/span&gt; the first word &lt;span class="kr"&gt;in&lt;/span&gt; phrase uses numbers&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="kp"&gt;split&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            firstWd &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; wordsForNum&lt;span class="p"&gt;[&lt;/span&gt; number.take&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;split&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            followingWds &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; encode&lt;span class="p"&gt;(&lt;/span&gt;number.drop&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;split&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="p"&gt;}&lt;/span&gt; yield firstWd&lt;span class="o"&gt;::&lt;/span&gt;follwingWds&lt;/span&gt;
&lt;span class="code-line"&gt;        phraseList.toSet&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ error in the line with &lt;code&gt;wordsForNum&lt;/code&gt;: key not found... 
⇒ &lt;code&gt;wordsForNum["7"]&lt;/code&gt; will give error 
⇒ make the &lt;code&gt;wordsForNum&lt;/code&gt; a total map, using withDefaultValue&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val wordsForNum: Map[String, Seq[String]] = &lt;/span&gt;
&lt;span class="code-line"&gt;    (words groupBy wordCode) withDefaultValue( Seq() )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step 5: return strings (instead of List[String])&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def translate(number: String): Set[String] = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    encode(number) map (_.mkString(" "))&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;summary: 
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec6_collections/pasted_image007.png"/&gt;&lt;/p&gt;
&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec6_collections/pasted_image009.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.scala-exercises.org/"&gt;https://www.scala-exercises.org/&lt;/a&gt;&lt;/p&gt;</summary><category term="scala"></category></entry><entry><title>[Functional Programming Principles in Scala] Lec5: Lists</title><link href="http://x-wei.github.io/progfun1_lec5_lists.html" rel="alternate"></link><published>2016-07-29T21:30:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-07-29:progfun1_lec5_lists.html</id><summary type="html">&lt;h1 id="51-more-functions-on-lists"&gt;5.1 - More Functions on Lists&lt;/h1&gt;
&lt;p&gt;already known methods: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;xs.head&lt;/span&gt;
&lt;span class="code-line"&gt;xs.tail&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sublist and ele access: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xs.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.last&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.init&lt;/code&gt;: all elementh except last element&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.take(n)&lt;/code&gt;: sublist of first n elements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.drop(n)&lt;/code&gt;: the rest of list after taking first n elements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs(n)&lt;/code&gt;: = &lt;code&gt;xs.apply(n)&lt;/code&gt; , element at index n&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;More methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;concatenation: &lt;code&gt;xs ++ ys&lt;/code&gt; (&lt;code&gt;:::&lt;/code&gt; is legacy usage)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.reverse&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.updated(n,x)&lt;/code&gt;: return a same list, except xs(n)=x (Note: Lists are immutable, so cannot modify)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.indexOf(x)&lt;/code&gt;: index or -1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.contains(x)&lt;/code&gt;: same as &lt;code&gt;xs.indexOf(x)&amp;gt;=0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;complexity: 
head, tail: simple to implement
⇒ complexity of &lt;code&gt;last&lt;/code&gt;?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def last[T](xs: List[T]): T = xs match{&lt;/span&gt;
&lt;span class="code-line"&gt;    case List() =&amp;gt; throw new Error("last of Nil")&lt;/span&gt;
&lt;span class="code-line"&gt;    case List(x) =&amp;gt; x&lt;/span&gt;
&lt;span class="code-line"&gt;    case y::ys =&amp;gt; last(ys)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ complexity of last = O(n)&lt;/p&gt;
&lt;p&gt;implement &lt;code&gt;init&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def init[T](xs: List[T]): T = xs match{&lt;/span&gt;
&lt;span class="code-line"&gt;    case List() =&amp;gt; throw new Error("init of Nil")&lt;/span&gt;
&lt;span class="code-line"&gt;    case List(x) =&amp;gt; List()&lt;/span&gt;
&lt;span class="code-line"&gt;    case y::ys =&amp;gt; y::init(ys)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ complexity = O(length of xs)&lt;/p&gt;
&lt;p&gt;implement concatenation &lt;code&gt;:::&lt;/code&gt;/&lt;code&gt;++&lt;/code&gt;
(NB: &lt;code&gt;:::&lt;/code&gt; is right-associative, &lt;code&gt;xs:::ys&lt;/code&gt; = &lt;code&gt;ys. :::(xs)&lt;/code&gt;. )&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def concat[T](xs: List[T], ys: List[T]) = xs match{&lt;/span&gt;
&lt;span class="code-line"&gt;    case List() =&amp;gt; ys&lt;/span&gt;
&lt;span class="code-line"&gt;    case z::zs =&amp;gt; x:concat(xs, ys)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ complexity of concat = O(length of xs)&lt;/p&gt;
&lt;p&gt;implement of reverse&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def reverse[T](xs: List[T]) = xs match{&lt;/span&gt;
&lt;span class="code-line"&gt;    case List() =&amp;gt; List()&lt;/span&gt;
&lt;span class="code-line"&gt;    case y::ys =&amp;gt; reverse(ys) ++ y&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ complexity of reverse: every call contains a concat, thus complexity=O(n2)&lt;/p&gt;
&lt;p&gt;exercice: remove nth element: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def removeAt[T](n:Int, xs: List[T]): List[T] = &lt;/span&gt;
&lt;span class="code-line"&gt;(xs take n ) ++ (xs drop n+1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="52-pairs-and-tuples"&gt;5.2 - Pairs and Tuples&lt;/h1&gt;
&lt;p&gt;example: sort list faster than insertion sort → merge sort. &lt;/p&gt;
&lt;p&gt;sort 2 sublist, merge them ⇒ list is sorted&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def msort(xs: List[Int]): List[Int] = {&lt;/span&gt;
&lt;span class="code-line"&gt;    val n = xs.length/2&lt;/span&gt;
&lt;span class="code-line"&gt;    if(n==0) xs&lt;/span&gt;
&lt;span class="code-line"&gt;    else{&lt;/span&gt;
&lt;span class="code-line"&gt;        def merge(xs: List[Int], ys: List[Int]) = ... // see below&lt;/span&gt;
&lt;span class="code-line"&gt;        val (fst, snd) = x splitAt n // splitAt returns 2 sublists&lt;/span&gt;
&lt;span class="code-line"&gt;        merge(msort(fst), msort(snd))&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;merge: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def merge(xs: List[Int], ys: List[Int]): List[Int] = xs match {&lt;/span&gt;
&lt;span class="code-line"&gt;    case Nil =&amp;gt; ys&lt;/span&gt;
&lt;span class="code-line"&gt;    case x::zs =&amp;gt; match ys{&lt;/span&gt;
&lt;span class="code-line"&gt;        case Nil =&amp;gt; xs&lt;/span&gt;
&lt;span class="code-line"&gt;        case y::ws =&amp;gt; {&lt;/span&gt;
&lt;span class="code-line"&gt;            if(x&amp;lt;y) x::merge(zs, ys)&lt;/span&gt;
&lt;span class="code-line"&gt;            else y::merge(xs, ws)&lt;/span&gt;
&lt;span class="code-line"&gt;        }&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="pairtuple"&gt;Pair/Tuple&lt;/h3&gt;
&lt;p&gt;written as &lt;code&gt;(x, y)&lt;/code&gt; in scala. pair can be used as patterns :  similar for tuples. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val pair = ("a", 2)&lt;/span&gt;
&lt;span class="code-line"&gt;val (label, value) = pair&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image.png"/&gt;&lt;/p&gt;
&lt;p&gt;tuple implementation: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image001.png"/&gt;&lt;/p&gt;
&lt;p&gt;⇒ can use &lt;code&gt;_1&lt;/code&gt; &lt;code&gt;_2&lt;/code&gt; to access elements&lt;/p&gt;
&lt;p&gt;exercice: rewrite the merge function using a &lt;em&gt;pattern matching over pairs&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def merge(xs: List[Int], ys: List[Int]): List[Int] =&lt;/span&gt;
&lt;span class="code-line"&gt;(xs, ys) match {&lt;/span&gt;
&lt;span class="code-line"&gt;    case (Nil, ys) =&amp;gt; ys&lt;/span&gt;
&lt;span class="code-line"&gt;    case (xs, Nil) =&amp;gt; xs&lt;/span&gt;
&lt;span class="code-line"&gt;    case (x:zs, y:ws) =&amp;gt; &lt;/span&gt;
&lt;span class="code-line"&gt;        if(x&amp;lt;y) x::merge(zs, ys)&lt;/span&gt;
&lt;span class="code-line"&gt;        else y::merge(xs, ws)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="53-implicit-parameters"&gt;5.3 - Implicit Parameters&lt;/h1&gt;
&lt;p&gt;pb: how to apply msort to list of other element types. &lt;/p&gt;
&lt;p&gt;using type parameters ? &lt;code&gt;msort[T]&lt;/code&gt;⇒ the compare operator is not always defined ! &lt;/p&gt;
&lt;p&gt;⇒ &lt;em&gt;pass the lt function as a parameter&lt;/em&gt;: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;def msort[T](xs: List[T])(lt: (T,T)=&amp;gt;Boolean) = ...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;another option: &lt;code&gt;scala.math.Ordering[T]&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;impor math.Ordering&lt;/span&gt;
&lt;span class="code-line"&gt;def msort[T](xs: List[T])(ord: Ordering) = ...// use ord.lt(x,y)&lt;/span&gt;
&lt;span class="code-line"&gt;msort(nums)(Ordering.Int)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pb: pass each time the function parameter is cumbersome... ⇒ use &lt;strong&gt;implicite&lt;/strong&gt; parameters&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def msort[T](xs: List[T])(implicite ord: Ordering) = ...// use ord.lt(x,y)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ the function calls can ignore the implicite parameter, the compiler will figure it out. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image002.png"/&gt;&lt;/p&gt;
&lt;h1 id="54-higher-order-list-functions"&gt;5.4 - Higher-Order List Functions&lt;/h1&gt;
&lt;p&gt;functions over list have similar pattern: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;transform each element &lt;/li&gt;
&lt;li&gt;retrive elements that satisfy some cretirion&lt;/li&gt;
&lt;li&gt;combing elements using an operator&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="map"&gt;map&lt;/h3&gt;
&lt;p&gt;apply an operation to every elements. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;abstract class List[T]{&lt;/span&gt;
&lt;span class="code-line"&gt;    def map[U](f: T=&amp;gt;U): List[U] = this match {&lt;/span&gt;
&lt;span class="code-line"&gt;        case Nil =&amp;gt; this&lt;/span&gt;
&lt;span class="code-line"&gt;        case x:xs =&amp;gt; f(x)::xs.map(f)&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="filtering"&gt;filtering&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def filter(p: T=&amp;gt;Boolean): List[T] = this match {&lt;/span&gt;
&lt;span class="code-line"&gt;    case Nil =&amp;gt; this&lt;/span&gt;
&lt;span class="code-line"&gt;    case x:xs =&amp;gt; f(p(x)) x::xs.filter(p) else xs.filter(p)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;other methods that extracts sublist: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image003.png"/&gt;&lt;/p&gt;
&lt;p&gt;exercice: implement a function &lt;code&gt;pack&lt;/code&gt;: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image004.png"/&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def pack[T](xs: List[T]): List[List[T]] = xs match {&lt;/span&gt;
&lt;span class="code-line"&gt;    case Nil =&amp;gt; Nil&lt;/span&gt;
&lt;span class="code-line"&gt;    case x::ys =&amp;gt; {&lt;/span&gt;
&lt;span class="code-line"&gt;        val (head, tail) = xs span (c =&amp;gt; c==x)&lt;/span&gt;
&lt;span class="code-line"&gt;        head :: pack(tail)&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;exercice2: implement  a function &lt;code&gt;encode&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image005.png"/&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def encode[T](xs: List[T]): List[(T, Int)] = xs match {&lt;/span&gt;
&lt;span class="code-line"&gt;    case Nil =&amp;gt; Nil&lt;/span&gt;
&lt;span class="code-line"&gt;    case x::ys =&amp;gt; {&lt;/span&gt;
&lt;span class="code-line"&gt;        val (head, tail) = xs span (c =&amp;gt; c==x)&lt;/span&gt;
&lt;span class="code-line"&gt;        (x, head.length) :: pack(tail)&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;another version: use the pack: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def encode[T](xs: List[T]): List[(T, Int)] = &lt;/span&gt;
&lt;span class="code-line"&gt;    pack(xs) map (l =&amp;gt; (l.head, l.length))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="55-reduction-of-lists"&gt;5.5 - Reduction of Lists&lt;/h1&gt;
&lt;p&gt;fold/reduce: combine elements using an operator. &lt;/p&gt;
&lt;h3 id="reduceleft"&gt;reduceLeft&lt;/h3&gt;
&lt;p&gt;(can apply only to non-empty lists) 
inserts a binary operator between adj elements: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image006.png"/&gt;&lt;/p&gt;
&lt;p&gt;ex. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum(xs: List[Int]) = (0::xs) reduceLeft ( (x,y)=&amp;gt; x+y)&lt;/span&gt;
&lt;span class="code-line"&gt;def prod(xs: List[Int]) = (1::xs) reduceLeft ( (x,y)=&amp;gt; x*y)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;write shorter function values using underscore &lt;code&gt;_&lt;/code&gt;:  every &lt;code&gt;_&lt;/code&gt; represents a new parameter&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum(xs: List[Int]) = (0::xs) reduceLeft ( _+_ )&lt;/span&gt;
&lt;span class="code-line"&gt;def prod(xs: List[Int]) = (1::xs) reduceLeft ( _*_ )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="foldleft"&gt;foldLeft&lt;/h3&gt;
&lt;p&gt;foldLeft is like reduceLeft, but can apply on Nil, and takes an &lt;strong&gt;accumulator&lt;/strong&gt; &lt;code&gt;z&lt;/code&gt; =&amp;gt; returns z when calling on Nil. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image007.png"/&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum(xs: List[Int]) = (xs foldleft 0) ( _+_ )&lt;/span&gt;
&lt;span class="code-line"&gt;def prod(xs: List[Int]) = (xs foldleft 1) ( _*_ )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image008.png"/&gt;&lt;/p&gt;
&lt;h3 id="foldrightreduceright"&gt;foldRight/reduceRight&lt;/h3&gt;
&lt;p&gt;dual functions to &lt;code&gt;foldLeft&lt;/code&gt; and &lt;code&gt;reduceLeft&lt;/code&gt;, but produce a tree leaned to right&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image010.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image011.png"/&gt;&lt;/p&gt;
&lt;p&gt;if the operation is associative and communitive, foldLeft and foldRight should give same results. Other times need to think. &lt;/p&gt;
&lt;p&gt;ex. concat&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image012.png"/&gt;
if apply foldLeft ⇒ type error, because the &lt;code&gt;::&lt;/code&gt; operator will be applied to 2 elements of type T.&lt;/p&gt;
&lt;h1 id="56-reasoning-about-concat"&gt;5.6 - Reasoning About Concat&lt;/h1&gt;
&lt;p&gt;proof of programs&lt;/p&gt;
&lt;h3 id="structural-induction"&gt;structural induction&lt;/h3&gt;
&lt;p&gt;pb: prove some properties of concat:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image015.png"/&gt;&lt;/p&gt;
&lt;p&gt;类似数学归纳法: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image016.png"/&gt;&lt;/p&gt;
&lt;p&gt;ex. prove &lt;code&gt;(xs ++ ys) ++ zs = xs ++ (ys ++ zs)&lt;/code&gt;: induction on &lt;code&gt;xs&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def concat[T](xs: List[T], ys: List[T]) = xs match{&lt;/span&gt;
&lt;span class="code-line"&gt;    case Nil =&amp;gt; ys&lt;/span&gt;
&lt;span class="code-line"&gt;    case z::zs =&amp;gt; x:concat(xs, ys)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;base case: &lt;code&gt;xs=Nil&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;(Nil ++ ys ) ++ zs = Nil ++ (ys ++ zs)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;induction step: &lt;code&gt;x::xs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image017.png"/&gt;&lt;/p&gt;
&lt;h2 id="57-a-larger-equational-proof-on-lists"&gt;5.7 - A Larger Equational Proof on Lists&lt;/h2&gt;
&lt;p&gt;pb: want to prove that &lt;code&gt;xs.reverse.revese == xs&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;base case: &lt;code&gt;Nil.reverse.revers = Nil&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;induction step&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pb: cannot advance 
⇒ generalize the argument. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec5_lists/pasted_image018.png"/&gt;&lt;/p&gt;</summary><category term="scala"></category></entry><entry><title>[Functional Programming Principles in Scala] Lec4: Types and Pattern Matching</title><link href="http://x-wei.github.io/progfun1_lec4_pattern_matching.html" rel="alternate"></link><published>2016-07-17T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-07-17:progfun1_lec4_pattern_matching.html</id><summary type="html">&lt;h2 id="41-objects-everywhere"&gt;4.1 - Objects Everywhere&lt;/h2&gt;
&lt;p&gt;scala is &lt;em&gt;pure&lt;/em&gt; OO: every value is an obj, every operation is a method of obj.  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;scala.Int&lt;/code&gt; &lt;code&gt;scala.Boolean&lt;/code&gt; maps to JVM standard primitive types.  &lt;/p&gt;
&lt;p&gt;Implement &lt;code&gt;Boolean&lt;/code&gt; withous primitive type in scala:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image.png"/&gt; &lt;/p&gt;
&lt;p&gt;Then defin &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; as objects, give implementation for &lt;code&gt;ifThenElse()&lt;/code&gt; funciton:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;object true extends Boolean{ &lt;/span&gt;
&lt;span class="code-line"&gt;    def ifThenElse[T](t: =&amp;gt;T, e: =&amp;gt;T) = t &lt;/span&gt;
&lt;span class="code-line"&gt;} &lt;/span&gt;
&lt;span class="code-line"&gt;object false extends Boolean{ &lt;/span&gt;
&lt;span class="code-line"&gt;    def ifThenElse[T](t: =&amp;gt;T, e: =&amp;gt;T) = e &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="42-functions-as-objects"&gt;4.2 - Functions as Objects&lt;/h2&gt;
&lt;p&gt;Function values are treated as objects in scala.&lt;br/&gt;
the type &lt;code&gt;A =&amp;gt; B&lt;/code&gt; is an abbrevation for &lt;code&gt;scala.Function1[A, B]&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image001.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Functions are objects with &lt;/strong&gt;&lt;code&gt;apply&lt;/code&gt;&lt;strong&gt; methods.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;anonymous function &lt;code&gt;(x: Int) =&amp;gt; x*x&lt;/code&gt; is expanded to :  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;new Function1[Int, Int]{ &lt;/span&gt;
&lt;span class="code-line"&gt;def apply(x: Int) = x*x &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;function call &lt;code&gt;f(a,b)&lt;/code&gt; is expanded to:  &lt;code&gt;f.apply(a,b)&lt;/code&gt;
&lt;code&gt;List(1,2)&lt;/code&gt; is expanded to : &lt;code&gt;List.apply(1,2)&lt;/code&gt; &lt;/p&gt;
&lt;h2 id="43-subtyping-and-generics"&gt;4.3 - Subtyping and Generics&lt;/h2&gt;
&lt;p&gt;2 forms of polymorphism: &lt;em&gt;subtyping and generics&lt;/em&gt; &lt;/p&gt;
&lt;h3 id="type-bounds"&gt;Type Bounds&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image003.png"/&gt;
&lt;code&gt;assertAllPos&lt;/code&gt; taks either &lt;code&gt;EmptySet&lt;/code&gt; or &lt;code&gt;NonEmptySet&lt;/code&gt;, the return type is EmptySet (when para=EmptySet) or NonEmptySet (when para=NonEmpty).&lt;br/&gt;
To express this situation:  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;def assertAllPos[S &amp;lt;: IntSet](r: S): S = ...&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;Here &lt;code&gt;&amp;lt;: IntSet&lt;/code&gt; means IntSet is an upper bound of the type parameter.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image004.png"/&gt; 
and we can mix the two notations:  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;[S &amp;gt;: NonEmpty &amp;lt;: IntSet]&lt;/code&gt; &lt;/p&gt;
&lt;h3 id="covariance"&gt;Covariance&lt;/h3&gt;
&lt;p&gt;Given &lt;code&gt;NonEmpty &amp;lt;: IntSet&lt;/code&gt;,&lt;br/&gt;
should we have: &lt;code&gt;List[NonEmpty] &amp;lt;: List[IntSet]&lt;/code&gt; ? &lt;/p&gt;
&lt;p&gt;In this case the typse are called *covariant. * &lt;/p&gt;
&lt;p&gt;In java, arrays are covariant: &lt;code&gt;NonEmpty[] &amp;lt;: IntSet[]&lt;/code&gt; 
but this might cause problems:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image005.png"/&gt; &lt;/p&gt;
&lt;p&gt;will get ArrayStoreException in 3rd line.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Liskov substitution principle&lt;/strong&gt;: when a type can be a subtype of another  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;If A&amp;lt;:B, then everything one can do with an object of type B, one should also be able to do it with object of type A.&lt;/em&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In scala the Array is not covariant: &lt;code&gt;Array[IntSet]&lt;/code&gt; is not supertype of &lt;code&gt;Array[NonEmpty]&lt;/code&gt; &lt;/p&gt;
&lt;h2 id="45-decomposition"&gt;4.5 - Decomposition&lt;/h2&gt;
&lt;p&gt;ex: arithmetic expression interpreter: a tree of numbers and sums, both are subtype of &lt;code&gt;Expr&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;1st try: test and accessor methods &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image006.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image007.png"/&gt; &lt;/p&gt;
&lt;p&gt;→ tedious... And to add more operands need to add many more methods...  &lt;/p&gt;
&lt;p&gt;2nd try: (non-solution) 
type testing and type casting 
&lt;code&gt;isinstantceof&lt;/code&gt;, &lt;code&gt;asinstanceof&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image008.png"/&gt; &lt;/p&gt;
&lt;p&gt;discouraged in scala. &lt;/p&gt;
&lt;p&gt;1st solution: &lt;strong&gt;OO decomposition&lt;/strong&gt; 
add &lt;code&gt;eval&lt;/code&gt; method to class Expr. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image009.png"/&gt; &lt;/p&gt;
&lt;p&gt;limitation: if we want to simplify an expression,  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image010.png"/&gt; &lt;/p&gt;
&lt;p&gt;⇒ there is no local simplification ! &lt;/p&gt;
&lt;p&gt;⇒ &lt;strong&gt;pattern matching&lt;/strong&gt; &lt;/p&gt;
&lt;h2 id="46-pattern-matching"&gt;4.6 - Pattern Matching&lt;/h2&gt;
&lt;p&gt;goal: &lt;em&gt;reverse&lt;/em&gt; the construction process.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;which subclass it is? &lt;/li&gt;
&lt;li&gt;what were the arguments? &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="case-classes"&gt;case classes&lt;/h3&gt;
&lt;p&gt;add &lt;code&gt;case&lt;/code&gt; in class definition. 
ex. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;case class Number(n: Int) extends Expr &lt;/span&gt;
&lt;span class="code-line"&gt;case class Sum(e1: Expr, e2: Expr) extends Expr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;adding &lt;code&gt;case&lt;/code&gt; adds &lt;em&gt;companion objects&lt;/em&gt; with &lt;code&gt;apply&lt;/code&gt; methods:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image011.png"/&gt; &lt;/p&gt;
&lt;p&gt;according to the expansion, &lt;code&gt;Number(2)&lt;/code&gt; is equal to &lt;code&gt;Number.apply(2)&lt;/code&gt; which is actaully &lt;code&gt;new Numver(2)&lt;/code&gt; &lt;/p&gt;
&lt;h3 id="pattern-matching"&gt;pattern matching&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;match&lt;/code&gt;: extension of &lt;code&gt;switch&lt;/code&gt; in java, ex:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def eval(e: Expr): Int = e match{ &lt;/span&gt;
&lt;span class="code-line"&gt;    case Number(n) =&amp;gt; n &lt;/span&gt;
&lt;span class="code-line"&gt;    case Sum(e1, e2) =&amp;gt; e1 + e2 &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image012.png"/&gt; &lt;/p&gt;
&lt;p&gt;patterns include:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;constructor, ex. &lt;code&gt;Number(n)&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;variable, ex. &lt;code&gt;n, e1, e2&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;wildcard patters, ex. &lt;code&gt;_&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;constant, ex. &lt;code&gt;1, true&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;or their combination, ex &lt;code&gt;Sum(Number(1),  Var(x))&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The whole match expression is replaced with the expression to the rhs of the first match pattern.  &lt;/p&gt;
&lt;p&gt;exercice: implement a &lt;code&gt;show&lt;/code&gt; function. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def show(e: Expr): String = e match { &lt;/span&gt;
&lt;span class="code-line"&gt;    case Number(n) =&amp;gt; n.toString &lt;/span&gt;
&lt;span class="code-line"&gt;    case Sum(l, r) =&amp;gt; show(l) + "+" + show(r) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="47-lists"&gt;4.7 - Lists&lt;/h2&gt;
&lt;p&gt;example:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image013.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image014.png"/&gt; &lt;/p&gt;
&lt;p&gt;difference between List and Array:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lists are immutable, elements cannot change &lt;/li&gt;
&lt;li&gt;Lists are recursive, arrays are flat &lt;/li&gt;
&lt;li&gt;both are homogeneous, all elements of the same type &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All &lt;code&gt;List&lt;/code&gt;s in scala are constructed with:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Empty list &lt;code&gt;Nil&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;construction op &lt;code&gt;::&lt;/code&gt;(pronunced: cons), &lt;code&gt;x::xs&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image015.png"/&gt; &lt;/p&gt;
&lt;p&gt;convention in scala: operators ending with &lt;code&gt;:&lt;/code&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;are &lt;em&gt;right-associative&lt;/em&gt;. &lt;code&gt;a::b::c&lt;/code&gt; is equal to &lt;code&gt;a::(b::c)&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;seen as method calls from the right-hand operand. &lt;code&gt;1::2::Nil&lt;/code&gt; equal to &lt;code&gt;Nil.::(2).::(1)&lt;/code&gt; ( &lt;code&gt;::&lt;/code&gt; is prepend operation) &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;operations on lists:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;head &lt;/li&gt;
&lt;li&gt;tail &lt;/li&gt;
&lt;li&gt;isEmpty &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;list in pattern matching: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image016.png"/&gt; &lt;/p&gt;
&lt;p&gt;ex. insertion sort of lists &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec4_pattern_matching/pasted_image017.png"/&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def isort(xs: List[Int]): List[Int] = xs match{ &lt;/span&gt;
&lt;span class="code-line"&gt;    case List() =&amp;gt; List() &lt;/span&gt;
&lt;span class="code-line"&gt;    case y::ys =&amp;gt; insert(y, isort(ys)) &lt;/span&gt;
&lt;span class="code-line"&gt;} &lt;/span&gt;
&lt;span class="code-line"&gt;def insert(x:Int, xs:List[Int]): List[Int] = xs match{ &lt;/span&gt;
&lt;span class="code-line"&gt;    case List() =&amp;gt; List(x) &lt;/span&gt;
&lt;span class="code-line"&gt;    case y::ys =&amp;gt; if(x&amp;lt;=y) x::xs else y::insert(y, ys) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="scala"></category></entry><entry><title>[Functional Programming Principles in Scala] Lec3: Data and Abstraction</title><link href="http://x-wei.github.io/progfun1_lec3_data_abstraction.html" rel="alternate"></link><published>2016-06-28T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-06-28:progfun1_lec3_data_abstraction.html</id><summary type="html">&lt;p&gt;This week, we'll cover traits, and we'll learn how to organize classes into hierarchies. We'll cover the hierarchy of standard Scala types, and see how to organize classes and traits into packages. Finally, we'll touch upon the different sorts of polymorphism in Scala. &lt;/p&gt;
&lt;h2 id="31-class-hierarchies"&gt;3.1 - Class Hierarchies&lt;/h2&gt;
&lt;h3 id="abstract-class"&gt;abstract class&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;abstract class IntSet { &lt;/span&gt;
&lt;span class="code-line"&gt;  def incl(x: Int): IntSet &lt;/span&gt;
&lt;span class="code-line"&gt;  def contains(x: Int): Boolean &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;abstract class:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;contains members without implementation &lt;/li&gt;
&lt;li&gt;cannot be created with &lt;code&gt;new&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="class-extensions"&gt;class Extensions&lt;/h3&gt;
&lt;p&gt;implement the integer set abstract class with BST 
2 types of trees: &lt;code&gt;Empty&lt;/code&gt; and &lt;code&gt;NonEmpty&lt;/code&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Empty&lt;/span&gt; &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;IntSet&lt;/span&gt; { &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;override&lt;/span&gt; &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;incl&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;: &lt;span class="nb"&gt;Int&lt;/span&gt;): &lt;span class="n"&gt;IntSet&lt;/span&gt; = &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NonEmpty&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;, &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Empty&lt;/span&gt;, &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Empty&lt;/span&gt;)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;override&lt;/span&gt; &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="nb"&gt;contains&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;: &lt;span class="nb"&gt;Int&lt;/span&gt;): &lt;span class="n"&gt;Boolean&lt;/span&gt; = &lt;span class="n"&gt;false&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;NonEmpty&lt;/span&gt;(&lt;span class="n"&gt;elem:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;, &lt;span class="n"&gt;left:&lt;/span&gt; &lt;span class="n"&gt;IntSet&lt;/span&gt;, &lt;span class="n"&gt;right:&lt;/span&gt; &lt;span class="n"&gt;IntSet&lt;/span&gt;) &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;IntSet&lt;/span&gt; { &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;override&lt;/span&gt; &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;incl&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;: &lt;span class="nb"&gt;Int&lt;/span&gt;): &lt;span class="n"&gt;IntSet&lt;/span&gt; = &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="o"&gt;x&lt;/span&gt; == &lt;span class="n"&gt;elem&lt;/span&gt;) &lt;span class="n"&gt;this&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;elem&lt;/span&gt; &amp;gt; &lt;span class="o"&gt;x&lt;/span&gt;) &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NonEmpty&lt;/span&gt;(&lt;span class="n"&gt;elem&lt;/span&gt;, &lt;span class="n"&gt;left&lt;/span&gt;.&lt;span class="n"&gt;incl&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;), &lt;span class="n"&gt;right&lt;/span&gt;)// &lt;span class="n"&gt;immutable&lt;/span&gt;! &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NonEmpty&lt;/span&gt;(&lt;span class="n"&gt;elem&lt;/span&gt;, &lt;span class="n"&gt;left&lt;/span&gt;, &lt;span class="n"&gt;right&lt;/span&gt;.&lt;span class="n"&gt;incl&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;))&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;override&lt;/span&gt; &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="nb"&gt;contains&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;: &lt;span class="nb"&gt;Int&lt;/span&gt;): &lt;span class="n"&gt;Boolean&lt;/span&gt; = &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;elem&lt;/span&gt; == &lt;span class="o"&gt;x&lt;/span&gt;) &lt;span class="nb"&gt;true&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;elem&lt;/span&gt; &amp;gt; &lt;span class="o"&gt;x&lt;/span&gt;) &lt;span class="n"&gt;left&lt;/span&gt;.&lt;span class="nb"&gt;contains&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;) &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;.&lt;span class="nb"&gt;contains&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;root class of all classes: &lt;code&gt;Object&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;replace concrete defintion of super class: &lt;code&gt;override&lt;/code&gt; is mandantory. &lt;/p&gt;
&lt;h3 id="object"&gt;Object&lt;/h3&gt;
&lt;p&gt;in the previous example, seems only one single &lt;code&gt;Empty&lt;/code&gt; set is needed.&lt;br/&gt;
⇒ define &lt;code&gt;Empty&lt;/code&gt; as &lt;strong&gt;singleton object&lt;/strong&gt; 
no other &lt;code&gt;Empty&lt;/code&gt; instances can be created, object is a &lt;em&gt;value.&lt;/em&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;object Empty extends IntSet { &lt;/span&gt;
&lt;span class="code-line"&gt;  override def incl(x: Int): IntSet = new NonEmpty(x, Empty, Empty)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  override def contains(x: Int): Boolean = false&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  override def toString = "." &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="program"&gt;Program&lt;/h3&gt;
&lt;p&gt;create standalone scala applicatoins.&lt;br/&gt;
Each such applications contains an &lt;code&gt;object&lt;/code&gt; with a &lt;code&gt;main(args:Array[String])&lt;/code&gt; method &lt;/p&gt;
&lt;h3 id="exercice-implement-union"&gt;exercice: implement union&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;union(other:IntSet): IntSet&lt;/code&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;override def union(other: IntSet): IntSet = &lt;/span&gt;
&lt;span class="code-line"&gt;  left union (right union (other incl elem))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;why this recursive call terminates ?&lt;br/&gt;
every call to &lt;code&gt;union&lt;/code&gt; is on a &lt;em&gt;smaller&lt;/em&gt; IntSet ! &lt;/p&gt;
&lt;p&gt;写成这样就会stackoverflow: &lt;code&gt;other.incl(elem).union(left).union(right)&lt;/code&gt;&lt;br/&gt;
讨论见: &lt;a href="https://www.coursera.org/learn/progfun1/discussions/weeks/3/threads/AzJ-4CLYEeag6wpD-92Rcw"&gt;https://www.coursera.org/learn/progfun1/discussions/weeks/3/threads/AzJ-4CLYEeag6wpD-92Rcw&lt;/a&gt; 
(需要点"view earlier replies"才有) 
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec3_data_abstraction/pasted_image012.png"/&gt; &lt;/p&gt;
&lt;h3 id="dynamic-binding"&gt;Dynamic Binding&lt;/h3&gt;
&lt;p&gt;behavior depends on the runtime type of the object.  &lt;/p&gt;
&lt;p&gt;~ higher-order functions &lt;/p&gt;
&lt;h2 id="lecture-32-how-classes-are-organized"&gt;Lecture 3.2 - How Classes Are Organized&lt;/h2&gt;
&lt;h3 id="package"&gt;package&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;named&lt;/span&gt; &lt;span class="n"&gt;imports&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;week3.Rational&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;week3.&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Hello&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;wildcard&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;week3._&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;can import either from a package or from an object &lt;/p&gt;
&lt;p&gt;automatically imported in scala:&lt;br/&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec3_data_abstraction/pasted_image001.png"/&gt; 
ex: 
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec3_data_abstraction/pasted_image002.png"/&gt; &lt;/p&gt;
&lt;p&gt;scaladoc: &lt;a href="http://www.scala-lang.org/files/archive/api/current/#package"&gt;http://www.scala-lang.org/files/archive/api/current/#package&lt;/a&gt; &lt;/p&gt;
&lt;h3 id="traits"&gt;Traits&lt;/h3&gt;
&lt;p&gt;in scala/java, a class has only one super class (single inheritance).&lt;br/&gt;
have several supertypes? ⇒ trait! &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one class can extend many traits (concated by &lt;code&gt;with&lt;/code&gt;)  — like java &lt;code&gt;interface&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec3_data_abstraction/pasted_image003.png"/&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;traits can contain fileds and concrete methods &lt;/li&gt;
&lt;li&gt;on the other hand, traits cannot have (value) parameters, but classes can &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="scala-class-hierchy"&gt;scala class hierchy&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec3_data_abstraction/pasted_image004.png"/&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Any&lt;/code&gt;: base class of all &lt;/li&gt;
&lt;li&gt;&lt;code&gt;AnyVal&lt;/code&gt;: primitive types (&lt;code&gt;Int, Unit, Boolean,...&lt;/code&gt;) &lt;/li&gt;
&lt;li&gt;&lt;code&gt;AnyRef&lt;/code&gt;: (=alias of &lt;code&gt;java.lang.Object&lt;/code&gt;) all reference types (&lt;code&gt;String, List, Seq, Iterable,...&lt;/code&gt;) &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Nothing&lt;/code&gt;: bottom of the hierchy, &lt;em&gt;is subtype of every type&lt;/em&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Null&lt;/code&gt;: &lt;em&gt;subtype of every reference type, &lt;/em&gt;&lt;code&gt;null&lt;/code&gt;'s type is &lt;code&gt;Null&lt;/code&gt;, not compatible with &lt;code&gt;AnyVal&lt;/code&gt; types.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;exception: &lt;code&gt;throw Exc&lt;/code&gt;, the typeof &lt;code&gt;Exc&lt;/code&gt; is &lt;code&gt;Nothing&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;exercice:&lt;br/&gt;
&lt;code&gt;if (true) 1 else false&lt;/code&gt; ⇒ type = &lt;code&gt;AnyVal&lt;/code&gt; &lt;/p&gt;
&lt;h2 id="lecture-33-polymorphism"&gt;Lecture 3.3 - Polymorphism&lt;/h2&gt;
&lt;h3 id="cons-list"&gt;cons-list&lt;/h3&gt;
&lt;p&gt;immutable linked list 
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec3_data_abstraction/pasted_image005.png"/&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec3_data_abstraction/pasted_image006.png"/&gt; 
implement this in scala: 
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec3_data_abstraction/pasted_image007.png"/&gt; &lt;/p&gt;
&lt;p&gt;the &lt;code&gt;val&lt;/code&gt; in the class definition: &lt;strong&gt;defines at the same time parameter and field of a class&lt;/strong&gt;, equivalent to:&lt;br/&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec3_data_abstraction/pasted_image008.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;type parameters&lt;/strong&gt; (generic) 
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec3_data_abstraction/pasted_image009.png"/&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;trait List[T]{ &lt;/span&gt;
&lt;span class="code-line"&gt;  def isEmpty : Boolean &lt;/span&gt;
&lt;span class="code-line"&gt;  def head: T &lt;/span&gt;
&lt;span class="code-line"&gt;  def tail: List[T] &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;class Cons[T](val head:T, val tail: List[T]) extends List[T] { &lt;/span&gt;
&lt;span class="code-line"&gt;  def isEmpty(): Boolean = false &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;head and tail are implemented in the parameters(fields), difference between &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;def&lt;/code&gt; only consist in the initialization (CBN, CBV). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Nil&lt;/span&gt;[&lt;span class="n"&gt;T&lt;/span&gt;] &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="nb"&gt;List&lt;/span&gt;[&lt;span class="n"&gt;T&lt;/span&gt;]{ &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isEmpty&lt;/span&gt; = &lt;span class="n"&gt;false&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;head:&lt;/span&gt; &lt;span class="n"&gt;Nothing&lt;/span&gt; = &lt;span class="n"&gt;throw&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NoSuchElementException&lt;/span&gt;(&lt;span class="s"&gt;"Nil.head"&lt;/span&gt;) &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;tail:&lt;/span&gt; &lt;span class="n"&gt;Nothing&lt;/span&gt; = &lt;span class="n"&gt;throw&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NoSuchElementException&lt;/span&gt;(&lt;span class="s"&gt;"Nil.tail"&lt;/span&gt;) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;use nothing as return type, and throw an exception.  &lt;/p&gt;
&lt;h3 id="generic-functions"&gt;generic functions&lt;/h3&gt;
&lt;p&gt;type parameters can be applied to functions.&lt;br/&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec3_data_abstraction/pasted_image011.png"/&gt; 
sometime the type parameter can be deduced by scala compiler.&lt;br/&gt;
ex. &lt;code&gt;singleton(2); singleton(true)&lt;/code&gt; &lt;/p&gt;
&lt;h3 id="types-and-evaulation"&gt;Types and Evaulation&lt;/h3&gt;
&lt;p&gt;type parameters don't affect evaluation.&lt;br/&gt;
can assume type parameters are removed before the evaluation (&lt;em&gt;type erasure&lt;/em&gt;).  &lt;/p&gt;
&lt;h3 id="polymorphism"&gt;Polymorphism&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;subtyping: instances of subclass can be passed to a base class &lt;/li&gt;
&lt;li&gt;generics: function/class with type parameters &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;exercice: write a function &lt;code&gt;nth(n: Int, list: List)&lt;/code&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def nth[T](n: Int, list:List[T]): T =  &lt;/span&gt;
&lt;span class="code-line"&gt;  if(list.isEmpty) throw new IndexOutOfBoundsException() &lt;/span&gt;
&lt;span class="code-line"&gt;  else if (n==0) list.head &lt;/span&gt;
&lt;span class="code-line"&gt;  else nth(n-1, list.tail)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="programming-assignment-object-oriented-sets"&gt;Programming Assignment: Object-Oriented Sets&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;TweetSet&lt;/code&gt;: an abstract class &lt;code&gt;TweetSet&lt;/code&gt; with two concrete subclasses,&lt;code&gt;Empty&lt;/code&gt; which represents an empty set, and &lt;code&gt;NonEmpty(elem: Tweet, left: TweetSet, right: TweetSet&lt;/code&gt;), which represents a non-empty set as a binary tree rooted at elem. The tweets are indexed by their text bodies: the bodies of all tweets on the left are lexicographically smaller than elem and all bodies of elements on the right are lexicographically greater. &lt;/p&gt;</summary><category term="scala"></category></entry><entry><title>[Functional Programming Principles in Scala] Lec2: Higher Order Functions</title><link href="http://x-wei.github.io/progfun1_lec2_highorder_func.html" rel="alternate"></link><published>2016-06-23T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-06-23:progfun1_lec2_highorder_func.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;This week, we'll learn about functions as first-class values, and higher order functions. We'll also learn about Scala's syntax and how it's formally defined. Finally, we'll learn about methods, classes, and data abstraction through the design of a data structure for rational numbers. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="21-higher-order-functions"&gt;2.1 - Higher-Order Functions&lt;/h2&gt;
&lt;p&gt;higher order functions: functions that takes functions as parameter or returns functions.  &lt;/p&gt;
&lt;p&gt;example:&lt;br/&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image.png"/&gt; 
⇒ put the &lt;code&gt;f&lt;/code&gt; as a parameter &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum(f:Int =&amp;gt; Int, a: Int, b: Int):Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;  if(a&amp;gt;b) 0 &lt;/span&gt;
&lt;span class="code-line"&gt;  else f(a) + sum(f, a+1, b) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="function-types"&gt;function types&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;A =&amp;gt; B&lt;/code&gt; is a function that takes &lt;code&gt;A&lt;/code&gt; as parameter and returns &lt;code&gt;B&lt;/code&gt;. &lt;/p&gt;
&lt;h3 id="anonymous-functions"&gt;Anonymous functions&lt;/h3&gt;
&lt;p&gt;"literals" for functions, syntactic sugar. 
ex.   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;(x: Int, y: Int) =&amp;gt; x+y&lt;/code&gt;
&lt;code&gt;(x: Int) =&amp;gt; x*x&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;use anon functions in previous &lt;code&gt;sum()&lt;/code&gt; function:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;sum(x=&amp;gt;x, 1, 10) &lt;/span&gt;
&lt;span class="code-line"&gt;sum(x=&amp;gt;x*x, 1, 10)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;exercice: turn &lt;code&gt;sum()&lt;/code&gt; into tailrec fashion. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum2(f:Int =&amp;gt; Int, a: Int, b: Int):Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;  @tailrec &lt;/span&gt;
&lt;span class="code-line"&gt;  def sumTR(a: Int, acc: Int): Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;    if (a &amp;gt; b) acc &lt;/span&gt;
&lt;span class="code-line"&gt;    else sumTR(a + 1, acc + f(a)) &lt;/span&gt;
&lt;span class="code-line"&gt;  } &lt;/span&gt;
&lt;span class="code-line"&gt;  sumTR(a, 0) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(note: using namescoping to eliminate parameters in inner functions) &lt;/p&gt;
&lt;h2 id="22-currying"&gt;2.2 - Currying&lt;/h2&gt;
&lt;p&gt;define a function that &lt;em&gt;returns  a funtion&lt;/em&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum3(f:Int =&amp;gt; Int): (Int, Int)=&amp;gt;Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;  def sumF(a:Int, b:Int):Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;    if(a&amp;gt;b) 0 &lt;/span&gt;
&lt;span class="code-line"&gt;    else f(a) + sum3(f, a+1, b) &lt;/span&gt;
&lt;span class="code-line"&gt;  } &lt;/span&gt;
&lt;span class="code-line"&gt;  sumF &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;when calling this function:&lt;br/&gt;
&lt;code&gt;sum3(cube)(1,10)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;syntactic sugar: shorter version of functions that return functions: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum3(f:Int =&amp;gt; Int)(a:Int, b:Int):Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;    if(a&amp;gt;b) 0 &lt;/span&gt;
&lt;span class="code-line"&gt;    else f(a) + sum3(f)(a+1, b) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;question: what is type of &lt;code&gt;sum3&lt;/code&gt;? 
→ &lt;code&gt;Int =&amp;gt; Int =&amp;gt; (Int, Int) =&amp;gt; Int&lt;/code&gt; 
note: functional types are &lt;em&gt;associated to the right&lt;/em&gt;,&lt;br/&gt;
&lt;code&gt;Int =&amp;gt; Int =&amp;gt; Int&lt;/code&gt; is equivalent to &lt;code&gt;Int =&amp;gt; (Int =&amp;gt; Int)&lt;/code&gt; &lt;/p&gt;
&lt;h3 id="currying"&gt;"currying"&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image002.png"/&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image003.png"/&gt; &lt;/p&gt;
&lt;p&gt;exercice:&lt;br/&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image005.png"/&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def product(f: Int =&amp;gt; Int)(a: Int, b: Int): Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;  if (a &amp;gt; b) 1 &lt;/span&gt;
&lt;span class="code-line"&gt;  else a * product(f)(a + 1, b) &lt;/span&gt;
&lt;span class="code-line"&gt;} &lt;/span&gt;
&lt;span class="code-line"&gt;product(x=&amp;gt;x)(1,10)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image006.png"/&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def fact(n:Int) = product(x=&amp;gt;x)(1,n) &lt;/span&gt;
&lt;span class="code-line"&gt;fact(10)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image007.png"/&gt; 
    def more_general(op: (Int,Int) =&amp;gt; Int, default: Int) 
                    (f: Int=&amp;gt; Int)(a:Int, b:Int):Int = { 
      if(a&amp;gt;b) default 
      else op(a, more_general(op, default)(f)(a + 1, b)) 
    } 
    more_general((x,y)=&amp;gt;x+y, 0)(x=&amp;gt;x)(1,10) &lt;/p&gt;
&lt;p&gt;老师的解法:&lt;br/&gt;
    def map_reduce(f:Int=&amp;gt; Int, op:(Int, Int)=&amp;gt;Int, default:Int) 
                  (a:Int, b:Int):Int = { 
      if(a&amp;gt;b) default 
      else op(f(a), map_reduce(f, op, default)(a+1,b)) 
    } 
    def factorial2(n:Int):Int = map_reduce(x=&amp;gt;x, (a,b)=&amp;gt; a*b, 1)(1,n) 
    factorial2(10) &lt;/p&gt;
&lt;h2 id="23-example-finding-fixed-points"&gt;2.3 - Example: Finding Fixed Points&lt;/h2&gt;
&lt;p&gt;find the fix point of a function: x = f(x) 
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image008.png"/&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val tol = 0.001 &lt;/span&gt;
&lt;span class="code-line"&gt;def isCloseEnough(x:Double, y:Double):Boolean = &lt;/span&gt;
&lt;span class="code-line"&gt;  math.abs((x-y)/x)&amp;lt;tol &lt;/span&gt;
&lt;span class="code-line"&gt;def fixedPoint(f: Double=&amp;gt;Double)(firstGuess:Double):Double = { &lt;/span&gt;
&lt;span class="code-line"&gt;  def iterate(guess:Double):Double = { &lt;/span&gt;
&lt;span class="code-line"&gt;    if(isCloseEnough(guess, f(guess))) guess &lt;/span&gt;
&lt;span class="code-line"&gt;    else iterate(f(guess)) &lt;/span&gt;
&lt;span class="code-line"&gt;  } &lt;/span&gt;
&lt;span class="code-line"&gt;  iterate(firstGuess) &lt;/span&gt;
&lt;span class="code-line"&gt;} &lt;/span&gt;
&lt;span class="code-line"&gt;fixedPoint(x=&amp;gt;1+x/2)(1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;using the fixepoint function for &lt;code&gt;sqrt&lt;/code&gt;: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sqrt(x) = y such that: x=y*y &lt;/li&gt;
&lt;li&gt;=y such that y = x/y &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;=&lt;em&gt;fixed point for the function f(y)=x/y&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;def sqrt(x:Double):Double = fixedPoint(y=&amp;gt;x/y)(1) 
sqrt(2) &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⇒ doesn't converge! ⇒ guess oscillates between 1 and 2... 
average damping: prevent the estimate from varying to much. 
⇒  &lt;em&gt;by taking the average of successive values&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;def sqrt2(x: Double): Double = fixedPoint(y =&amp;gt; (y + x / y) / 2)(1)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;abstract this damping technique: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def avgDamping(f:Double=&amp;gt; Double)(x:Double):Double = &lt;/span&gt;
&lt;span class="code-line"&gt;  (f(x)+x)/2 &lt;/span&gt;
&lt;span class="code-line"&gt;def sqrt2(x: Double): Double = fixedPoint(avgDamping(y=&amp;gt;x/y))(1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;summary: The highest level of abstraction is not always the best, but it is important to know the techniques of abstraction, so as to use them when appropriate. &lt;/p&gt;
&lt;h2 id="24-scala-syntax-summary"&gt;2.4 - Scala Syntax Summary&lt;/h2&gt;
&lt;p&gt;notations(EBNF): &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt; denotes an alternative &lt;/li&gt;
&lt;li&gt;&lt;code&gt;[...]&lt;/code&gt; an option (0 or 1) &lt;/li&gt;
&lt;li&gt;&lt;code&gt;{...}&lt;/code&gt; a repetition (0 or more) &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Types&lt;/strong&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image009.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Expressions&lt;/strong&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image010.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Definitions&lt;/strong&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image011.png"/&gt; &lt;/p&gt;
&lt;h2 id="25-functions-and-data"&gt;2.5 - Functions and Data&lt;/h2&gt;
&lt;p&gt;example. &lt;em&gt;rational numbers&lt;/em&gt; (x/y) 
define a class:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;:&lt;span class="n"&gt;Int&lt;/span&gt;, &lt;span class="n"&gt;y:Int&lt;/span&gt;){ &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;numer&lt;/span&gt; = &lt;span class="o"&gt;x&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;denom&lt;/span&gt; = &lt;span class="n"&gt;y&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;} &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;x&lt;/span&gt; = &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;(&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="mi"&gt;2&lt;/span&gt;) &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;x&lt;/span&gt;.&lt;span class="n"&gt;numer&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;x&lt;/span&gt;.&lt;span class="n"&gt;denom&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;this definition creates both a class and the constructor.&lt;br/&gt;
now implement arithmetic: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def add(that: Rational) = &lt;/span&gt;
&lt;span class="code-line"&gt;  new Rational(numer * that.denom + denom * that.numer, that.denom * denom)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def neg = new Rational(-numer, denom)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def sub(that: Rational) = &lt;/span&gt;
&lt;span class="code-line"&gt;  add(that.neg)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;override def toString = numer + "/" + denom&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="26-more-fun-with-rationals"&gt;2.6 - More Fun With Rationals&lt;/h2&gt;
&lt;p&gt;simplify the rationals &lt;em&gt;at construction&lt;/em&gt;:  add private members:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) &lt;/span&gt;
&lt;span class="code-line"&gt;private val g = gcd(x, y) &lt;/span&gt;
&lt;span class="code-line"&gt;def numer = x/g &lt;/span&gt;
&lt;span class="code-line"&gt;def denom = y/g&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;other options:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;replace &lt;code&gt;g&lt;/code&gt; with &lt;code&gt;gcd(x,y)&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;turn &lt;code&gt;numer&lt;/code&gt; and &lt;code&gt;denom&lt;/code&gt; into &lt;code&gt;val&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;add less and max function:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def less(that:Rational) = &lt;/span&gt;
&lt;span class="code-line"&gt;  this.numer*that.denom &amp;lt; this.denom*that.numer&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def max(that:Rational) = if(this.less(that)) that else this&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="preconditions"&gt;preconditions&lt;/h3&gt;
&lt;p&gt;ex: avoid divide by 0.  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;require(y!=0, "denominator must be non zero")&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;→ &lt;em&gt;java.lang.IllegalArgumentException: requirement failed: denominator must be non zero&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;require&lt;/code&gt;is a test to perform when the class is initialized.&lt;br/&gt;
similar: &lt;code&gt;assert()&lt;/code&gt; &lt;/p&gt;
&lt;h3 id="constructor"&gt;constructor&lt;/h3&gt;
&lt;p&gt;in scala a class implicitly introduces a &lt;strong&gt;primary constructor:&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;takes parameters of the class&lt;/em&gt; &lt;/li&gt;
&lt;li&gt;&lt;em&gt;executes all statements in the class body&lt;/em&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;to add another constructor: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;def this(x:Int) = this(x,1)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;exercice:&lt;br/&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image012.png"/&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;override def toString = { &lt;/span&gt;
&lt;span class="code-line"&gt;  val g = gcd(numer, denom) &lt;/span&gt;
&lt;span class="code-line"&gt;  numer/g + "/" + denom/g &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="27-evaluation-and-operators"&gt;2.7 - Evaluation and Operators&lt;/h2&gt;
&lt;h2 id="evaluation-for-classobject"&gt;evaluation for class/object&lt;/h2&gt;
&lt;p&gt;extend the substitution model to classes and objects 
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image014.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image015.png"/&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image016.png"/&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image017.png"/&gt; &lt;/p&gt;
&lt;p&gt;examples:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image019.png"/&gt; &lt;/p&gt;
&lt;h2 id="operator-overloading"&gt;operator overloading&lt;/h2&gt;
&lt;h3 id="infix-ops"&gt;infix ops&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;any method with one parameter can be used as an infix operator.&lt;/strong&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image020.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;em&gt;scala identifiers can bu symbolic:&lt;/em&gt;
&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image021.png"/&gt; &lt;/p&gt;
&lt;p&gt;⇒ change names to &lt;code&gt;+, &amp;lt;, -,&lt;/code&gt; use in this way: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;x + y &lt;/span&gt;
&lt;span class="code-line"&gt;x &amp;lt; y &lt;/span&gt;
&lt;span class="code-line"&gt;x max y &lt;/span&gt;
&lt;span class="code-line"&gt;x - y - z&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="unitary-ops"&gt;unitary ops&lt;/h3&gt;
&lt;p&gt;now change the &lt;code&gt;neg&lt;/code&gt; method: prefix operator, and might be confused with the sub(&lt;code&gt;-&lt;/code&gt;) 
⇒ it's name is special: &lt;code&gt;unary_-&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;def unary_- = new Rational(-numer, denom)&lt;/code&gt; &lt;/p&gt;
&lt;h3 id="precedence-of-ops"&gt;precedence of ops&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;the precedence of an op is defined by its first letter&lt;/strong&gt; 
order (by increasing precedence): &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec2_highorder_func/pasted_image022.png"/&gt; 
quite the same as in java &lt;/p&gt;
&lt;h2 id="programming-assignment-functional-sets"&gt;Programming Assignment: Functional Sets&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Mathematically, we call the function which takes an integer as argument and which returns a boolean indicating whether the given integer belongs to a set, the characteristic function of the set. For example, we can characterize the set of negative integers by the characteristic function (x: Int) =&amp;gt; x &amp;lt; 0. &lt;/p&gt;
&lt;p&gt;Therefore, we choose to represent a set by its characterisitc function and define a type alias for this representation: &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;type Set = Int =&amp;gt; Boolean &lt;/span&gt;
&lt;span class="code-line"&gt;def contains(s: Set, elem: Int): Boolean = s(elem)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="scala"></category></entry><entry><title>[Functional Programming Principles in Scala] Lec1: Functions &amp; Evaluation</title><link href="http://x-wei.github.io/progfun1_lec1_fun_and_eval.html" rel="alternate"></link><published>2016-06-21T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-06-21:progfun1_lec1_fun_and_eval.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;In this week, we'll learn the difference between functional imperative programming. We step through the basics of Scala; covering expressions, evaluation, conditionals, functions, and recursion  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="11-programming-paradigms"&gt;1.1 - Programming Paradigms&lt;/h2&gt;
&lt;p&gt;imperative programming:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;modify mutable variables  &lt;/li&gt;
&lt;li&gt;using assignments  &lt;/li&gt;
&lt;li&gt;control structures: if-else, loops, break, continue, return, etc.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;~~~&amp;gt; Von Neumann computer:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;em&gt;conceptualize data structures word-by-word. ⇒ need higher level abstractions (theories).&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image001.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;theory doesn't describe mutations!&lt;/strong&gt;&lt;br/&gt;
ex. theories of polynomials  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image002.png"/&gt; &lt;/p&gt;
&lt;p&gt;To implement high-level concepts following their math theories, &lt;strong&gt;there's no place for mutation&lt;/strong&gt;.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image003.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Functional programming&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image004.png"/&gt;&lt;br/&gt;
functions in FP language are 1st-class citizens.  &lt;/p&gt;
&lt;h2 id="12-elements-of-programming"&gt;1.2 - Elements of Programming&lt;/h2&gt;
&lt;p&gt;in a language:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;primitive expressions  &lt;/li&gt;
&lt;li&gt;operators to combin expressions  &lt;/li&gt;
&lt;li&gt;abstract expressions: introduce a name for an expression  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;primitive types in scala are written capatilized:   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image005.png"/&gt; &lt;/p&gt;
&lt;h3 id="repl"&gt;REPL&lt;/h3&gt;
&lt;p&gt;interactive shell: write expressions and respond its value  &lt;/p&gt;
&lt;h3 id="evaluation"&gt;Evaluation&lt;/h3&gt;
&lt;p&gt;evaluation: &lt;strong&gt;expression → value&lt;/strong&gt;&lt;br/&gt;
evaluation stops onces it results in a &lt;em&gt;value.&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;evaluate non-primitive expressions:&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;take the left-most operator  &lt;/li&gt;
&lt;li&gt;take (left and right) operands   &lt;/li&gt;
&lt;li&gt;apply the operator to operands  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;evaluate names:&lt;/strong&gt;&lt;br/&gt;
replace the name with the rhs of its &lt;em&gt;definition.&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;definitions can have parameters.&lt;br/&gt;
ex. variable/return types are &lt;em&gt;after&lt;/em&gt; their names, seperated by a &lt;code&gt;:&lt;/code&gt;&lt;br/&gt;
&lt;code&gt;def power(x: Double, y: Int): Double = ...&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;evaluate a parameterized function:&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image006.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image007.png"/&gt; &lt;/p&gt;
&lt;p&gt;This scheme is called "&lt;strong&gt;substition model&lt;/strong&gt;" — formalized in the lambda calculus. This can be applied as long as there is no &lt;em&gt;side effects&lt;/em&gt;(ex. modify variable &lt;code&gt;c++&lt;/code&gt;)&lt;em&gt;.&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Termination&lt;/strong&gt;&lt;br/&gt;
Q: does every expression evaluates to a value? &lt;br/&gt;
NO, ex. &lt;br/&gt;
&lt;code&gt;def loop: Int = loop&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;change evaluation strategy&lt;/strong&gt;&lt;br/&gt;
do &lt;em&gt;not&lt;/em&gt; reduce argument values before rewrite function application.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image008.png"/&gt; &lt;/p&gt;
&lt;h2 id="call-by-name-and-call-by-value"&gt;call-by-name and call-by-value&lt;/h2&gt;
&lt;p&gt;the above evaluation schemes.   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;call-by-value: reduce argument values before rewrite function application.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;advantage: it evaluates every function argument only once.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;call-by-name: do not reduce arg values  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;advantage: a function argument is not evaluated if the corresponding parameter is unused in the evaluation&lt;br/&gt;
of the function body.  &lt;/p&gt;
&lt;p&gt;ex.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image009.png"/&gt; &lt;/p&gt;
&lt;h2 id="13-evaluation-strategies-and-termination"&gt;1.3 - Evaluation Strategies and Termination&lt;/h2&gt;
&lt;p&gt;CBV and CBN:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image010.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image011.png"/&gt; &lt;/p&gt;
&lt;p&gt;ex.   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def first(x: Int, y: Int) = x  &lt;/span&gt;
&lt;span class="code-line"&gt;first(1, loop)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;in scala:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;normally use call-by-value (more efficient than call-by-name because it avoid repeated computation of CBN).  &lt;/li&gt;
&lt;li&gt;but: &lt;strong&gt;if a  &lt;/strong&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;strong&gt; before a parameter type&lt;/strong&gt;, that parameter is called &lt;em&gt;by-name&lt;/em&gt;.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex.   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def constOne(x: Int, y: =&amp;gt; Int) = 1  &lt;/span&gt;
&lt;span class="code-line"&gt;constOne(1+2, loop)  &lt;/span&gt;
&lt;span class="code-line"&gt;constOne(loop, 1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="14-conditionals-and-value-definitions"&gt;1.4 - Conditionals and Value Definitions&lt;/h2&gt;
&lt;h3 id="conditional-expressions"&gt;conditional expressions&lt;/h3&gt;
&lt;p&gt;the &lt;code&gt;if-else&lt;/code&gt; expression&lt;br/&gt;
the &lt;code&gt;if-else&lt;/code&gt; is an expression, not statement.&lt;br/&gt;
ex. &lt;code&gt;def abs(x: Int): Int = if (x&amp;gt;=0) x else -x&lt;/code&gt;&lt;br/&gt;
the &lt;code&gt;x&amp;gt;=0&lt;/code&gt; is a boolean expression, sometimes called &lt;strong&gt;predicates&lt;/strong&gt;.  &lt;/p&gt;
&lt;h3 id="cbn-and-cbv-for-definition"&gt;CBN and CBV for definition&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;def&lt;/code&gt; form is by name, its rhs is evaluated at each use  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;val&lt;/code&gt; is by value, evaluted at the definiton  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;scala&amp;gt; def loop:Boolean = loop  &lt;/span&gt;
&lt;span class="code-line"&gt;loop: Boolean&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; def x = loop  &lt;/span&gt;
&lt;span class="code-line"&gt;x: Boolean&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; val x = loop  &lt;/span&gt;
&lt;span class="code-line"&gt;Execution interrupted by signal.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;exercice: implement &lt;code&gt;and(x,y)&lt;/code&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;scala&amp;gt; def and(x:Boolean, y: =&amp;gt; Boolean) = if(x) y else false  &lt;/span&gt;
&lt;span class="code-line"&gt;and: (x: Boolean, y: =&amp;gt; Boolean)Boolean&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; and(false, loop)  &lt;/span&gt;
&lt;span class="code-line"&gt;res3: Boolean = false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="15-example-square-roots-with-newtons-method"&gt;1.5 - Example: square roots with Newton's method&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image012.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;def sqrt(x: Double): Double = ...&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;need helper (recursive) functions.   &lt;/p&gt;
&lt;p&gt;note: in scala the &lt;em&gt;return type of recursive functions&lt;/em&gt; must be given.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def improve(guess: Double, x: Double): Double =  &lt;/span&gt;
&lt;span class="code-line"&gt;  (x / guess + guess) / 2.0&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def isGoodGuess(guess: Double, x: Double): Boolean =  &lt;/span&gt;
&lt;span class="code-line"&gt;  math.abs((guess * guess - x)/x)&amp;lt;0.001&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def sqrtItr(guess: Double, x: Double): Double = {  &lt;/span&gt;
&lt;span class="code-line"&gt;  if (isGoodGuess(guess, x)) guess  &lt;/span&gt;
&lt;span class="code-line"&gt;  else sqrtItr(improve(guess, x), x)  &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def sqrt(x:Double): Double = sqrtItr(1, x)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="16-blocks-and-lexical-scope"&gt;1.6 - Blocks and Lexical Scope&lt;/h2&gt;
&lt;h3 id="nested-functions"&gt;nested functions&lt;/h3&gt;
&lt;p&gt;put aux functions inside a function.   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sqrt(x:Double): Double = {  &lt;/span&gt;
&lt;span class="code-line"&gt;  def improve(guess: Double, x: Double): Double =  &lt;/span&gt;
&lt;span class="code-line"&gt;    (x / guess + guess) / 2.0&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  def isGoodGuess(guess: Double, x: Double): Boolean =  &lt;/span&gt;
&lt;span class="code-line"&gt;    math.abs((guess * guess - x)/x)&amp;lt;0.001&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  def sqrtItr(guess: Double, x: Double): Double = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    if (isGoodGuess(guess, x)) guess  &lt;/span&gt;
&lt;span class="code-line"&gt;    else sqrtItr(improve(guess, x), x)  &lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  sqrtItr(1, x)  &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="blocks-and-visibility"&gt;blocks and visibility&lt;/h3&gt;
&lt;p&gt;blocks: delimited by braces &lt;code&gt;{...}&lt;/code&gt;&lt;br/&gt;
The last element of a block is an expression that defines its value.&lt;br/&gt;
Blocks are themselves expressions; &lt;em&gt;a block may appear everywhere an expression can&lt;/em&gt;.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image013.png"/&gt; &lt;/p&gt;
&lt;p&gt;ex.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val x = 0  &lt;/span&gt;
&lt;span class="code-line"&gt;def f(y: Int) = y +1  &lt;/span&gt;
&lt;span class="code-line"&gt;val result = {  &lt;/span&gt;
&lt;span class="code-line"&gt;  val x = f(3);  &lt;/span&gt;
&lt;span class="code-line"&gt;  x * x  &lt;/span&gt;
&lt;span class="code-line"&gt;} + x // result = 16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ex. eliminate the parameter &lt;code&gt;x&lt;/code&gt; of helper functions inside the &lt;code&gt;sqrt&lt;/code&gt; function  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sqrt(x:Double): Double = {  &lt;/span&gt;
&lt;span class="code-line"&gt;  def improve(guess: Double): Double =  &lt;/span&gt;
&lt;span class="code-line"&gt;    (x / guess + guess) / 2.0&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  def isGoodGuess(guess: Double): Boolean =  &lt;/span&gt;
&lt;span class="code-line"&gt;    math.abs((guess * guess - x)/x)&amp;lt;0.001&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  def sqrtItr(guess: Double): Double = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    if (isGoodGuess(guess)) guess  &lt;/span&gt;
&lt;span class="code-line"&gt;    else sqrtItr(improve(guess))  &lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  sqrtItr(1)  &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;about multiline expressions: put the operator in the first line to avoid ambguity.   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image014.png"/&gt; &lt;/p&gt;
&lt;h2 id="17-tail-recursion"&gt;1.7 - Tail Recursion&lt;/h2&gt;
&lt;p&gt;review: evaluation of function application.   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image015.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image016.png"/&gt; &lt;/p&gt;
&lt;p&gt;ex1. gcd  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def gcd(a:Int, b:Int): Int=  &lt;/span&gt;
&lt;span class="code-line"&gt;  if(b==0) a else gcd(b, a%b)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image017.png"/&gt; &lt;/p&gt;
&lt;p&gt;ex2. factorial  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def factorial(n:Int): Int =  &lt;/span&gt;
&lt;span class="code-line"&gt;  if(n==0) 1 else n*factorial(n-1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="_images/progfun1_lec1_fun_and_eval/pasted_image018.png"/&gt; &lt;/p&gt;
&lt;p&gt;difference from the &lt;code&gt;gcd&lt;/code&gt; case:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;in &lt;code&gt;gcd&lt;/code&gt;, the expression is reduced to a &lt;code&gt;gcd()&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;in &lt;code&gt;factorial&lt;/code&gt;, &lt;em&gt;add one more element to the expression in each step&lt;/em&gt;!  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="tail-recursion"&gt;tail recursion&lt;/h3&gt;
&lt;p&gt;if &lt;strong&gt;a function calls itself  as its last action&lt;/strong&gt;, then the function's stack can be reused. &lt;br/&gt;
⇒ tail recursion functions are iterative process.   &lt;/p&gt;
&lt;p&gt;In general, if &lt;strong&gt;the last action of a function consists of calling a function (which may be the same)&lt;/strong&gt;, one stack frame would be sufficient for both functions. Such calls are called &lt;em&gt;tail-calls&lt;/em&gt;.  &lt;/p&gt;
&lt;p&gt;tail-recursive function:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;more efficient  &lt;/li&gt;
&lt;li&gt;can avoid stackoverflow  &lt;/li&gt;
&lt;li&gt;might not be as clear as a non-tailrec version   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;add &lt;code&gt;@tailrec&lt;/code&gt;annotation to the function, if its not tailrec, an error will be shown.    &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;@tailrec  &lt;/span&gt;
&lt;span class="code-line"&gt;def gcd(a: Int, b: Int): Int = ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;exercice: turn factorial into tailrec fashion. &lt;br/&gt;
→ idea: use an &lt;strong&gt;accumulator &lt;/strong&gt;(partial result) &lt;code&gt;acc&lt;/code&gt; .  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def factorialTR(n:Int):Int = {  &lt;/span&gt;
&lt;span class="code-line"&gt;  @tailrec  &lt;/span&gt;
&lt;span class="code-line"&gt;  def fact(n:Int, acc:Int):Int = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    if(n==0) acc  &lt;/span&gt;
&lt;span class="code-line"&gt;    else fact(n-1, n*acc)  &lt;/span&gt;
&lt;span class="code-line"&gt;  }  &lt;/span&gt;
&lt;span class="code-line"&gt;  fact(n, 1)  &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="programming-assignment-recursion"&gt;Programming Assignment: Recursion&lt;/h2&gt;
&lt;p&gt;三道递归的练习题...  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;  /**  &lt;/span&gt;
&lt;span class="code-line"&gt;    * Exercise 1  &lt;/span&gt;
&lt;span class="code-line"&gt;    */  &lt;/span&gt;
&lt;span class="code-line"&gt;  def pascal(c: Int, r: Int): Int = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    if (c == 0 || c == r) 1  &lt;/span&gt;
&lt;span class="code-line"&gt;    else pascal(c, r - 1) + pascal(c - 1, r - 1)  &lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  /**  &lt;/span&gt;
&lt;span class="code-line"&gt;    * Exercise 2  &lt;/span&gt;
&lt;span class="code-line"&gt;    */  &lt;/span&gt;
&lt;span class="code-line"&gt;  def balance(chars: List[Char]): Boolean = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    def balance_rec(chars: List[Char], acc: Int): Boolean = {  &lt;/span&gt;
&lt;span class="code-line"&gt;      if (acc&amp;lt;0) false  &lt;/span&gt;
&lt;span class="code-line"&gt;      else if (chars.isEmpty) acc == 0  &lt;/span&gt;
&lt;span class="code-line"&gt;      else if (chars.head == '(') balance_rec(chars.tail, acc+1)  &lt;/span&gt;
&lt;span class="code-line"&gt;      else if (chars.head == ')') balance_rec(chars.tail, acc-1)  &lt;/span&gt;
&lt;span class="code-line"&gt;      else balance_rec(chars.tail, acc)  &lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    balance_rec(chars, 0)  &lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  /**  &lt;/span&gt;
&lt;span class="code-line"&gt;    * Exercise 3  &lt;/span&gt;
&lt;span class="code-line"&gt;    */  &lt;/span&gt;
&lt;span class="code-line"&gt;  def countChange(money: Int, coins: List[Int]): Int = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    if(money==0 ) 1  &lt;/span&gt;
&lt;span class="code-line"&gt;    else if(coins.isEmpty || money&amp;lt;0) 0  &lt;/span&gt;
&lt;span class="code-line"&gt;    else countChange(money, coins.tail) + countChange(money-coins.head, coins)  &lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="scala"></category></entry><entry><title>[Functional Programming Principles in Scala] Lec0: Getting Started</title><link href="http://x-wei.github.io/progfun1_lec0_setup.html" rel="alternate"></link><published>2016-06-20T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-06-20:progfun1_lec0_setup.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;Get up and running with Scala on your computer. Complete an example assignment to familiarize yourself with our unique way of submitting assignments.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="tool-setup"&gt;Tool setup&lt;/h1&gt;
&lt;h3 id="intellij"&gt;IntelliJ&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;use worksheet as a better REPL&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="sbt"&gt;SBT&lt;/h3&gt;
&lt;p&gt;navigate to the directory of the assignment you are working on, then start &lt;code&gt;sbt&lt;/code&gt;. 
(when first running &lt;code&gt;sbt&lt;/code&gt;, will take 5~10 minutes to download files...)&lt;/p&gt;
&lt;h4 id="repl"&gt;REPL&lt;/h4&gt;
&lt;p&gt;type &lt;code&gt;console&lt;/code&gt; to enter scala REPL, hit &lt;code&gt;ctrl-d&lt;/code&gt; to exit REPL. &lt;/p&gt;
&lt;h4 id="compile-run-test"&gt;Compile / run / test&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;compile&lt;/code&gt;: The compile task will compile the source code of the assignment which is located in the directory &lt;code&gt;src/main/scala&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test&lt;/code&gt;: The directory &lt;code&gt;src/test/scala&lt;/code&gt; contains unit tests for the project. In order to run these tests in sbt, you can use the test command.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;run&lt;/code&gt;: If your project has an object with a main method (or an object extending the trait App), then you can run the code in sbt easily by typing run. In case sbt finds multiple main methods, it will ask you which one you'd like to execute.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="submit"&gt;submit&lt;/h4&gt;
&lt;p&gt;submitting assignments in sbt: 
&lt;code&gt;submit your@email.com YourSubmissionPassWord&lt;/code&gt;&lt;/p&gt;
&lt;h1 id="scala-tutorial"&gt;Scala tutorial&lt;/h1&gt;
&lt;h3 id="classes-traits-objects-and-packages"&gt;Classes, Traits, Objects and Packages&lt;/h3&gt;
&lt;h4 id="classes"&gt;Classes&lt;/h4&gt;
&lt;p&gt;Classes in Scala are very similar to classes in Java. They are templates containing fields and methods. Like in Java, classes can be instantiated using the new construct, there can be many “instances” (or “objects”) of the same class.&lt;/p&gt;
&lt;p&gt;In Scala there exists &lt;strong&gt;a special kind of class named case classes&lt;/strong&gt;. You will learn about case classes during the course.&lt;/p&gt;
&lt;p&gt;Classes in Scala &lt;strong&gt;cannot have static members&lt;/strong&gt;. You can use &lt;em&gt;objects&lt;/em&gt; (see below) to achieve similar functionality as with static members in Java.&lt;/p&gt;
&lt;h4 id="traits"&gt;Traits&lt;/h4&gt;
&lt;p&gt;Traits are like &lt;strong&gt;interfaces&lt;/strong&gt; in Java, but they &lt;em&gt;can also contain concrete members&lt;/em&gt;, i.e. method implementations or field definitions.&lt;/p&gt;
&lt;h4 id="objects"&gt;Objects&lt;/h4&gt;
&lt;p&gt;Object in Scala are like classes, but for every object definition there is only one single instance. &lt;em&gt;It is not possible to create instances of objects using new&lt;/em&gt;, instead you can just access the members (methods or fields) of an object using its name.&lt;/p&gt;
&lt;h4 id="packages"&gt;Packages&lt;/h4&gt;
&lt;p&gt;Adding a statement such as package foo.bar at the top of a file makes the code in a file part of the package foo.bar. You can then do import foo.bar._ to make everything from package foo.bar available in your code. The content of a package can be scattered across many files. If you define a class MyClass in package foo.bar, you can import that specific class (and not anything else from that package) with import foo.bar.MyClass.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;In Scala, everything can be imported, not only class names&lt;/em&gt;. So for instance if you have an object baz in package foo.bar, then import foo.bar.baz._ would import all the members of that object.&lt;/p&gt;
&lt;h3 id="hello-world-in-scala"&gt;Hello, World! in Scala&lt;/h3&gt;
&lt;p&gt;In Scala, the main or &lt;em&gt;entry point method is defined in an object&lt;/em&gt;. An object can be made executable by either adding extending the type &lt;code&gt;App&lt;/code&gt; or by adding a method &lt;code&gt;def main(args: Array[String])&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here are two ways to define a program which outputs “Hello, World!” in Scala:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;object HelloWorld extends App {&lt;/span&gt;
&lt;span class="code-line"&gt;  println("Hello, World!")&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;object HelloWorld {&lt;/span&gt;
&lt;span class="code-line"&gt;  def main(args: Array[String]) {&lt;/span&gt;
&lt;span class="code-line"&gt;    println("Hello, World!")&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="source-files-classfiles-and-the-jvm"&gt;Source Files, Classfiles and the JVM&lt;/h3&gt;
&lt;p&gt;Scala source code is stored in text files with the extension &lt;code&gt;.scala&lt;/code&gt;. Typically Scala programmers create one source file for each class, or one source file for a class hierarchy: In fact, Scala &lt;em&gt;allows multiple classes and objects to be defined in the same source file&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The name of a Scala source file can be chosen &lt;em&gt;freely&lt;/em&gt;, but it is recommended to use the name of a class which is defined in that file.&lt;/li&gt;
&lt;li&gt;Package hierarchies should be reflected in directory structure: a source file defining class C in package foo.bar should be stored in a subdirectory as foo/bar/C.scala. Scala does not really enforce this convention, but some tools such as the Scala IDE for eclipse might have problems otherwise.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The scala compiler compiles &lt;code&gt;.scala&lt;/code&gt; source files to &lt;code&gt;.class&lt;/code&gt; files, like the Java compiler. Classfiles are binary files containing machine code for the Java Virtual Machine. In order to run a Scala program, the JVM has to know the directory where classfiles are stored. This parameter is called the “classpath”.&lt;/p&gt;
&lt;p&gt;If you are using eclipse or sbt to compile and run your Scala code, you don’t need to do any of the above manually - these tools take care of invoking the Scala compiler and the JVM with the correct arguments.&lt;/p&gt;
&lt;h1 id="scala-style-guide"&gt;Scala Style Guide&lt;/h1&gt;
&lt;p&gt;style checker: &lt;a href="http://www.scalastyle.org/"&gt;http://www.scalastyle.org/&lt;/a&gt;
(in IntelliJ: You can enable scalastyle in Intellij by selecting Settings-&amp;gt;Editor-&amp;gt;Inspections, then searching for Scala style inspections.)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Avoid Casts and Type Tests&lt;/em&gt;: Never use isInstanceOf or asInstanceOf - there’s always a better solution.&lt;/li&gt;
&lt;li&gt;Indentation &lt;/li&gt;
&lt;li&gt;&lt;em&gt;Line Length and Whitespace&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Use local Values to simplify complex Expressions&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Choose meaningful Names for Methods and Values&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Common Subexpressions&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;*Don’t Copy-Paste Code!: factor out common parts into separate methods instead of copying code around. *&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Scala doesn’t require Semicolons&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Don’t submit Code with “print” Statements: the final code should be free of debugging statements.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Avoid using Return&lt;/em&gt;: often don’t need to use explicit returns. &lt;/li&gt;
&lt;li&gt;&lt;em&gt;Avoid mutable local Variables&lt;/em&gt;: You can often rewrite code that uses mutable local variables to code with helper functions that take accumulators.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Eliminate redundant “If” Expressions&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="cheatsheet"&gt;Cheatsheet&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/lampepfl/progfun-wiki/blob/gh-pages/CheatSheet.md"&gt;https://github.com/lampepfl/progfun-wiki/blob/gh-pages/CheatSheet.md&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="example-assignment"&gt;Example Assignment&lt;/h1&gt;
&lt;h3 id="implementation"&gt;implementation&lt;/h3&gt;
&lt;p&gt;implement &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;sum&lt;/code&gt; method for &lt;code&gt;List[Int]&lt;/code&gt;. 
trick: use recursion. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum(xs: List[Int]): Int = {&lt;/span&gt;
&lt;span class="code-line"&gt;    if (xs.isEmpty) 0&lt;/span&gt;
&lt;span class="code-line"&gt;    else xs.head + sum(xs.tail)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def max(xs: List[Int]): Int = {&lt;/span&gt;
&lt;span class="code-line"&gt;    if (xs.isEmpty) throw new java.util.NoSuchElementException()&lt;/span&gt;
&lt;span class="code-line"&gt;    max(xs, Int.MinValue)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;def max(xs: List[Int], m: Int): Int = {&lt;/span&gt;
&lt;span class="code-line"&gt;    if (xs.isEmpty) m&lt;/span&gt;
&lt;span class="code-line"&gt;    else if (xs.head &amp;gt; m) max(xs.tail, xs.head)&lt;/span&gt;
&lt;span class="code-line"&gt;    else max(xs.tail, m)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="scalatest"&gt;ScalaTest&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A test suite is simply a collection of individual tests for some specific component of a program. A test suite is created by defining a class which extends the type &lt;code&gt;org.scalatest.FunSuite&lt;/code&gt;. When running ScalaTest, it will automatically find this class and execute all of its tests.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You have two options for running this test suite:
- Start the sbt console and run the "&lt;code&gt;test&lt;/code&gt;" command
- Right-click this file in eclipse and chose "Run As" - "JUnit Test"&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Tests are written using the &lt;code&gt;test&lt;/code&gt; operator which takes two arguments:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A description of the test. This description has to be unique, no two tests can have the same description. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;The test body, a piece of Scala code that implements the test 
The most common way to implement a test body is using the method &lt;code&gt;assert&lt;/code&gt; which tests that its argument evaluates to &lt;code&gt;true&lt;/code&gt;. So one of the simplest successful tests is the following:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;test("one plus one is two")(assert(1 + 1 == 2))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;In Scala, it is allowed to pass an argument to a method using the block  syntax, i.e. &lt;code&gt;{ argument }&lt;/code&gt; instead of parentheses&lt;code&gt;(argument)&lt;/code&gt;.
This allows tests to be written in a more readable manner:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;test("one plus one is three?") {&lt;/span&gt;
&lt;span class="code-line"&gt;    assert(1 + 1 == 3) // This assertion fails! Go ahead and fix it.&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One problem with the previous (failing) test is that ScalaTest will      &lt;br/&gt;
only tell you that a test failed, but it will not tell you what was      &lt;br/&gt;
the reason for the failure. The output looks like this:                    &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;{{{                                                                        &lt;/span&gt;
&lt;span class="code-line"&gt;   [info] - one plus one is three? *** FAILED ***                          &lt;/span&gt;
&lt;span class="code-line"&gt;}}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This situation can be improved by &lt;strong&gt;using a special equality operator &lt;/strong&gt;&lt;code&gt;===&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (this is only possible in ScalaTest). So if you  run the next test, ScalaTest will show the following output:               &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;{{{                                                                        &lt;/span&gt;
&lt;span class="code-line"&gt;   [info] - details why one plus one is not three *** FAILED ***           &lt;/span&gt;
&lt;span class="code-line"&gt;   [info]   2 did not equal 3 (ListsSuite.scala:67)                        &lt;/span&gt;
&lt;span class="code-line"&gt;}}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;We recommend to always use the &lt;/strong&gt;&lt;code&gt;===&lt;/code&gt;&lt;strong&gt; equality operator when writing tests.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;In order to test the exceptional behavior of a methods, ScalaTest offers the &lt;code&gt;intercept&lt;/code&gt;operation.                                              &lt;/p&gt;
&lt;p&gt;In the following example, we test the fact that the method &lt;code&gt;intNotZero&lt;/code&gt; throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if its argument is &lt;code&gt;0&lt;/code&gt;.     &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def intNotZero(x: Int): Int = {&lt;/span&gt;
&lt;span class="code-line"&gt;    if (x == 0) throw new IllegalArgumentException("zero is not allowed")&lt;/span&gt;
&lt;span class="code-line"&gt;    else x&lt;/span&gt;
&lt;span class="code-line"&gt;  }     &lt;/span&gt;
&lt;span class="code-line"&gt;test("intNotZero throws an exception if its argument is 0") {&lt;/span&gt;
&lt;span class="code-line"&gt;    intercept[IllegalArgumentException] {&lt;/span&gt;
&lt;span class="code-line"&gt;      intNotZero(0)&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It is allowed to have multiple &lt;code&gt;assert&lt;/code&gt; statements inside one test, however it is recommended to write an individual &lt;code&gt;test&lt;/code&gt; statement for every tested aspect of a method.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;  test("sum of a few numbers") {&lt;/span&gt;
&lt;span class="code-line"&gt;    assert(sum(List(1,2,0)) === 3)&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;  test("sum of empty list"){&lt;/span&gt;
&lt;span class="code-line"&gt;    assert(sum(List())===0)&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;  test("sum of negative numbers"){&lt;/span&gt;
&lt;span class="code-line"&gt;    assert(sum(List(-1,-1,-1)) === -3)&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  test("max of a few numbers") {&lt;/span&gt;
&lt;span class="code-line"&gt;    assert(max(List(3, 7, 2)) === 7)&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;  test("max of empty list throws NoSuchElementException"){&lt;/span&gt;
&lt;span class="code-line"&gt;    intercept[NoSuchElementException]{&lt;/span&gt;
&lt;span class="code-line"&gt;      max(List())&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="scala"></category></entry></feed>