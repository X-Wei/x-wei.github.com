<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>mx's blog</title><link href="http://x-wei.github.io/" rel="alternate"></link><link href="http://x-wei.github.io/feeds/tag-scala.atom.xml" rel="self"></link><id>http://x-wei.github.io/</id><updated>2016-12-31T00:00:00+01:00</updated><entry><title>Scala/OCaml初体验</title><link href="http://x-wei.github.io/scala-ocaml-impression.html" rel="alternate"></link><published>2016-12-31T00:00:00+01:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-12-31:scala-ocaml-impression.html</id><summary type="html">
&lt;p&gt;2016年的最后几小时, 随便写写关于Scala和OCaml的一些入门体验好了.   &lt;/p&gt;
&lt;p&gt;今年对FP语言特别感兴趣, 上了两门Scala的公开课(&lt;a href="https://www.coursera.org/learn/progfun1/home/welcome"&gt;here&lt;/a&gt; and &lt;a href="https://www.coursera.org/learn/progfun2/home/welcome"&gt;here&lt;/a&gt;)和一门OCaml的公开课(&lt;a href="https://www.fun-mooc.fr/courses/parisdiderot/56002S02/session02/info"&gt;here&lt;/a&gt;), 在博客中写了一系列的笔记, 课后作业也都认真做完了. 斗胆说这两门语言都算入门了吧... 这里就随便写一下使用这两门语言的感受, 想到哪里写到哪里...   &lt;/p&gt;
&lt;p&gt;FP语言和之前接触的语言确实不大一样, 比如之前我都有种错觉, 学什么语言只要知道循环/条件/基本类型运算怎么写, 就差不多可以上手了...... 然后遇到了FP, 发现循环语句其实是不必要的... 记得看到过一篇文章, 类比学FP就好像开了很多种车的老司机突然开始学开宇宙飞船, 肯定各种WTF不适应了~   &lt;/p&gt;
&lt;p&gt;以前谈到FP我只能联想到一些Python里的FP特性: lambda表达式, 高阶函数之类的, 顶多还想到个闭包... 不过Python里面的FP特性和Scala/OCaml里的比起来还是差了不少: i.e. 现在非常希望Python里可以支持pattern matching...   &lt;/p&gt;
&lt;h1 id="scala"&gt;Scala&lt;/h1&gt;
&lt;p&gt;Scala算是比较亲民的FP语言了(和Java有点像...), 也是我最早接触的FP语言. EPFL的那两门公开课质量很棒, 毕竟是Scala的作者亲自来上的...   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;immutable types&lt;/em&gt;: 习惯了就好, 就像java里所有东西都是final的, 要修改什么东西的时候改成新建一个, immutable数据的优点就是并行方便啊...   &lt;/li&gt;
&lt;li&gt;&lt;em&gt;一切皆为表达式&lt;/em&gt;, specifically, &lt;code&gt;if&lt;/code&gt;语句也是表达式(expression)而不是语句(statement)  &lt;/li&gt;
&lt;li&gt;尽量不用&lt;code&gt;return&lt;/code&gt;, 返回值就是最后一句expression  &lt;/li&gt;
&lt;li&gt;类型推导: 就不用写麻烦的类型标记了(有时又必须写, 比如必须要告诉Scala递归函数的返回类型)... 不过有时不标记类型又容易出错(心里以为的类型和实际的类型不一样). 另外Scala的类型是写在冒号后面的, 习惯了就好...   &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;for expression&lt;/strong&gt;: (和"for循环"不是一回事) 非常好用, 可以说是一大亮点, 比较复杂的&lt;code&gt;filter/map&lt;/code&gt;组成的表达式, 用for expr写出来非常容易理解, 超棒... 后来学OCaml的时候非常期待OCaml里也有类似的东西(不过好像没有...)  &lt;/li&gt;
&lt;li&gt;pattern matching: 用constructor来switch! 没什么好说的 非常好用的东西...  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://x-wei.github.io/progfun2_lec2_lazyeval.html#lecture-22-streams"&gt;lazy evaluation和Stream&lt;/a&gt;: 非常有用的东西, 学到这里时很受启发...   &lt;/li&gt;
&lt;li&gt;intellij真好用, 还有Scala worksheet...   &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尾递归优化&lt;/strong&gt;: 把递归函数做到和iterative的一样快, tailrec算是工具之一吧. &lt;br/&gt;
    一开始对tailrec有点不太会写, 其实后来大概明白了怎么回事: 尾递归要求&lt;code&gt;f(n)&lt;/code&gt;最后的return语句里应该直接是递归调用&lt;code&gt;f(n-1)&lt;/code&gt;, 不要加别的什么带&lt;code&gt;f(n-1)&lt;/code&gt;的表达式. &lt;br/&gt;
    一般的递归函数大概是: &lt;code&gt;f(n) = some_expr_of f(n-1)&lt;/code&gt;, 而tailrec的版本里, 加入了&lt;code&gt;acc&lt;/code&gt;这样一个参数, 保存累加结果. &lt;em&gt;可以把acc看做f(n-1)的代替品&lt;/em&gt;, 这时, 把那个f(n-1)的expr作用在&lt;code&gt;acc&lt;/code&gt;上, 就是尾递归了! f(n, acc)最后一句就成了&lt;code&gt;f(n-1, some_expr_of acc)&lt;/code&gt; — 简简单单一个递归调用~&lt;br/&gt;
    举个最简单的例子: 阶乘运算&lt;br/&gt;
    非尾递归的写法是:   &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;    &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改成尾递归以后:   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;factorialTR&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;    &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="nd"&gt;@tailrec&lt;/span&gt;    &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;fact&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;    &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;    &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;fact&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;    &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt;    &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;fact&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;    &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;简单的匿名函数有几种写法:   &lt;ul&gt;
&lt;li&gt;用&lt;code&gt;=&amp;gt;&lt;/code&gt;: &lt;code&gt;param  =&amp;gt; ret&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;用pattern matching(这时要用花括号): &lt;code&gt;{case(param list)  =&amp;gt; ret }&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;下划线就表示参数: &lt;code&gt;_*2&lt;/code&gt; — 相比之下 简直受够了Python里面写lambda.......  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一些概念和Java对应一下:   &lt;ul&gt;
&lt;li&gt;&lt;code&gt;Unit&lt;/code&gt;对应Java里的&lt;code&gt;void&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Option&lt;/code&gt;对应Java里的Object(有指针的对象), Java里的&lt;code&gt;null&lt;/code&gt;对应Scala里&lt;code&gt;None&lt;/code&gt;, Java里的某个对象(非null)&lt;code&gt;A&lt;/code&gt;对应Scala里的&lt;code&gt;Some[A]&lt;/code&gt;, Scala里和&lt;code&gt;Option&lt;/code&gt;类似的还有&lt;code&gt;Try&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;trait&lt;/code&gt;大概可以看做Java里的&lt;code&gt;Interface&lt;/code&gt;, 不过Scala的trait是可以包含函数实现的...   &lt;/li&gt;
&lt;li&gt;Scala的&lt;code&gt;object&lt;/code&gt;和Java里可不是一个意思, Scala里object是单例对象(&lt;em&gt;Singleton&lt;/em&gt;), 类似于java里的&lt;code&gt;static final&lt;/code&gt;的对象  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有人说Scala被过度设计了, 感觉有点道理: 快学完第二门Scala公开课的时候看看别人代码, 又发现了好多没见过的关键字... @@  &lt;/li&gt;
&lt;li&gt;并不太喜欢省略点号 省略括号/分号之类的语法糖...  &lt;/li&gt;
&lt;li&gt;Scala的collection有点多: &lt;code&gt;Seq/List/Array/IndexedSeq/Vector&lt;/code&gt;傻傻分不清楚....  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/scala-ocaml-impression/pasted_image.png"/&gt; &lt;/p&gt;
&lt;h1 id="ocaml"&gt;OCaml&lt;/h1&gt;
&lt;p&gt;OCaml也是工业界比较成功的语言了, 而且据说速度和Cpp不相上下, 我对它可以说是向往已久, 看到FUN平台上有公开课就赶紧报名了...   &lt;/p&gt;
&lt;p&gt;OCaml算是比较"正宗"的FP语言(或许还不够"纯"?), 风味和别的语言差了好多, 但是写着写着就喜欢上了...   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数参数不用括号! 这是第一个冲击...  &lt;/li&gt;
&lt;li&gt;不过总是把函数放在最前面, 还是不大习惯, 比如&lt;code&gt;List.map&lt;/code&gt;, 更希望可以写成 &lt;code&gt;a_list map a_fun&lt;/code&gt;这样...  &lt;/li&gt;
&lt;li&gt;运算符完全分隔: 整数加法是&lt;code&gt;+&lt;/code&gt;, 浮点数加法要显示写成&lt;code&gt;+.&lt;/code&gt;, 这样做的好处就是可以做异常强大的类型推导, 比Scala不知高到哪里去了~  &lt;/li&gt;
&lt;li&gt;各种错误都可以在编译时找到, 安全感倍增...   &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;let-in binding&lt;/strong&gt;: 理解了这个概念以后, 大脑有了一种开窍的感觉! 这个就非常接近数学推导了, 比如在数学上证明什么东西的时候, 令x y z等于什么什么, 其实最终都是为了在最后一个表达式里面体现. 只是起一个名字而已, 并不是改变了这些"identifier"的数值. Scala里面的"最后一个表达式即为返回值"这一点, 我当时有点不太习惯, 不过在OCaml里面用let-in绑定这么一写, 这不是显然的么?! ...总之这个写法理解了以后, 感觉非常美妙...   &lt;/li&gt;
&lt;li&gt;函数的类型为&lt;code&gt;para1_type -&amp;gt; para2_type -&amp;gt; ... -&amp;gt; ret_type&lt;/code&gt;, 这样写了以后对于理解partial function之类的就有很大帮助, 另外OCaml并不区分数值和函数了: 都是用let声明, 一个数值可以看做是接收0个参数的函数.   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;try-with&lt;/code&gt;处理异常: 除了处理异常以外, 由于没发现break对应的写法, 现在要break的时候我就也写成&lt;code&gt;try-with&lt;/code&gt;...   &lt;/li&gt;
&lt;li&gt;basic composed types: &lt;code&gt;tuple/record/array&lt;/code&gt;这三个, 个人感觉并不是特别好用... @@  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;taged type&lt;/strong&gt; (又叫sum type/variant type): 感觉非常强大, 定义了taged type以后再pattern matching不要太爽... 感觉我对这块理解还不太够, 看别人写的taged type可能可以写一些处理的函数, 自己定义taged type就比较虚了... 好的程序, 把类型定义写好了 基本上就完成一半了...   &lt;/li&gt;
&lt;li&gt;关于模块(module)的签名的写法什么的, 其实还是有点晕... 可能实践还是不够  &lt;/li&gt;
&lt;li&gt;OCaml里的"Polymorphism"大概相当于Java里的generic/Cpp里的template.   &lt;/li&gt;
&lt;li&gt;pattern matching: 在OCaml里被大量的应用, 感觉比Scala里面的还好用不少...   &lt;/li&gt;
&lt;li&gt;utop作为交互式终端体验还是很棒的  &lt;/li&gt;
&lt;li&gt;编辑器和ide还是不够丰富, 没找到(非vim/emacs)很好的方案... 不过FUN平台的网络编辑环境非常给力, 自动indent这个feature太喜欢了, 最后所有作业都是直接在web环境下写的...   &lt;/li&gt;
&lt;li&gt;opam包管理器有时候会出现一些模块安装不上的问题  &lt;/li&gt;
&lt;li&gt;听说&lt;code&gt;Core&lt;/code&gt;提供了比较完善的函数支持, 希望学一下(也就是看看real world OCaml)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="compared-with-python"&gt;compared with Python&lt;/h1&gt;
&lt;p&gt;那么这两个语言和我现在用得最多的语言(Python)相比较一下吧:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为Python, 非常羡慕Scala/OCaml的执行速度  &lt;/li&gt;
&lt;li&gt;眼馋pattern matching和各种compile time保护......   &lt;/li&gt;
&lt;li&gt;Python的REPL(&lt;a href="https://bpython-interpreter.org/"&gt;bpython&lt;/a&gt;)还是比Scala worksheet / ocaml utop体验好不少   &lt;/li&gt;
&lt;li&gt;Python的"自带电池"特色是很大的优点, 很好奇Scala/OCaml有没有提供defaultdict/counter/datetime之类的模块......   &lt;/li&gt;
&lt;/ul&gt;</summary><category term="scala"></category><category term="OCaml"></category></entry><entry><title>[Scala MOOC II] Lec4 - Timely Effects</title><link href="http://x-wei.github.io/progfun2_lec4_var.html" rel="alternate"></link><published>2016-11-09T00:00:00+01:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-11-09:progfun2_lec4_var.html</id><summary type="html">
&lt;p&gt;this week: discuss how to handle events in user-interface — MVC, functional reactive programming.  &lt;/p&gt;
&lt;h1 id="lecture-41-imperative-event-handling-the-observer-pattern"&gt;Lecture 4.1 - Imperative Event Handling: The Observer Pattern&lt;/h1&gt;
&lt;p&gt;Traditional way of handling events: &lt;em&gt;observer Pattern (MVC)&lt;/em&gt;. Used when views need to react to change in a model.  &lt;/p&gt;
&lt;p&gt;MVC: model-view-controller for user interface &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Views can announce themselves to a model (called "&lt;em&gt;substribe&lt;/em&gt;") &lt;/li&gt;
&lt;li&gt;Models can "&lt;em&gt;publish&lt;/em&gt;" new informations to views &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nc"&gt;Publisher&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;subscribers&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Subscriber&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;subscribe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subscriber&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Subscriber&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;unsubscribe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subscriber&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Subscriber&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;publish&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subscribers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nc"&gt;Substriber&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pub&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Publisher&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;make the &lt;code&gt;BankAccount&lt;/code&gt; a &lt;code&gt;Publisher&lt;/code&gt;:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec4_var/pasted_image.png"/&gt; &lt;/p&gt;
&lt;p&gt;create a &lt;code&gt;Consolidator&lt;/code&gt; that displays bank accounts:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec4_var/pasted_image001.png"/&gt; &lt;/p&gt;
&lt;p&gt;Advantages of MVC: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;decouples views from stat &lt;/li&gt;
&lt;li&gt;have varying number of views of a given state &lt;/li&gt;
&lt;li&gt;simple to set up  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Disadvantages:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;forces imperative style since handlers are of Unit type &lt;/li&gt;
&lt;li&gt;many moving parts that need to be coordinated &lt;/li&gt;
&lt;li&gt;concurrency will be more complicated (ex. 2 models update one view at the same time) &lt;/li&gt;
&lt;li&gt;Views are tightly bound to one state, view updates immediately &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="lecture-42-functional-reactive-programming"&gt;Lecture 4.2 - Functional Reactive Programming&lt;/h1&gt;
&lt;p&gt;FRP:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;reactive programming: react to seq of &lt;em&gt;events&lt;/em&gt; that happen in &lt;em&gt;time&lt;/em&gt;.  &lt;/li&gt;
&lt;li&gt;functional view: aggregate an event sequence to a &lt;strong&gt;signal&lt;/strong&gt;.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In our simple API, the most important concept is &lt;code&gt;Signal&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Signal:&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is a vlaue that &lt;em&gt;changes over time&lt;/em&gt; &lt;/li&gt;
&lt;li&gt;represented as a &lt;em&gt;function&lt;/em&gt; mapping time to value domain  &lt;/li&gt;
&lt;li&gt;define new signals from existing ones (instead of having &lt;em&gt;mutable&lt;/em&gt; state) &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;example: move mouse positions&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;event-based view:&lt;/strong&gt;&lt;br/&gt;
whenever mouse moves, an event &lt;code&gt;MouseMoved(toPos: Position)&lt;/code&gt; is fired &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FRP view:&lt;/strong&gt;&lt;br/&gt;
use a signal(function): &lt;code&gt;mousePosition: Signal[Position]&lt;/code&gt; , which at any point represents a current mouse position &lt;/p&gt;
&lt;h3 id="signal-opeartions"&gt;Signal opeartions&lt;/h3&gt;
&lt;p&gt;2 fundamental ops on signals:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;obtain value of signal at current time (the &lt;code&gt;apply&lt;/code&gt; function): &lt;code&gt;mousePosition()&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;define a signal in term of another signal (constructor &lt;code&gt;Signal(expr)&lt;/code&gt;) &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;example: from the mouse curve signal, define a new signal indicating whether the curve is inside the rectangle or not.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;inReactangle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;LL&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Position&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;UR&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Position&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mousePosition&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// the mouse pos signal &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="nc"&gt;LL&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nc"&gt;UR&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;use &lt;code&gt;Signal(_value)&lt;/code&gt; to define a constant signal:  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;val sig = Signal(3) // constant signal&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;then define a subclass &lt;code&gt;Var&lt;/code&gt; of &lt;code&gt;Signal&lt;/code&gt; for changable signals, which has an &lt;code&gt;update&lt;/code&gt; operation to redefine the value of a signal.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;sig&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// update  &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ In scala, &lt;code&gt;update&lt;/code&gt; is also a special function: assignments like &lt;code&gt;a(e1,...en)=e&lt;/code&gt; are translated to &lt;code&gt;a.update(e1...en, e)&lt;/code&gt;. (Here the n could be 0, i.e. no arguments in the assignment expression).  &lt;/p&gt;
&lt;p&gt;→ So &lt;code&gt;sig.update(5)&lt;/code&gt; can be re-written as &lt;code&gt;sig()=5&lt;/code&gt;. The &lt;code&gt;()&lt;/code&gt; is like dereferencing a varable.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Difference between &lt;code&gt;Var&lt;/code&gt;s and mutable &lt;code&gt;var&lt;/code&gt;s: we can &lt;em&gt;map over signals&lt;/em&gt;, i.e. maintain a relation between 2 signals forever in the future, whereas using mutable &lt;code&gt;var&lt;/code&gt;s have to propagate all updates manually.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="example-bank-account"&gt;example: bank account&lt;/h3&gt;
&lt;p&gt;add a signal &lt;code&gt;balance&lt;/code&gt; to &lt;code&gt;BankAccount&lt;/code&gt;s, define a &lt;em&gt;function&lt;/em&gt; &lt;code&gt;consolidated&lt;/code&gt; which takes sum of all balances of accounts in list.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BankAccount&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;balance&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// a Var signal &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;deposit&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;amount&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;amount&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;balance&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;balance&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;amount&lt;/span&gt; &lt;span class="c1"&gt;// otherwise cyclic definition of `balance` &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;withdraw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;amount&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;amount&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;amount&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;balance&lt;/span&gt;&lt;span class="o"&gt;()){&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;balance&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;balance&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;amount&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Error&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"insufficient balance"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;consolidated&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;accts&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;BankAccount&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;accts&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;balance&lt;/span&gt;&lt;span class="o"&gt;()).&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="c1"&gt;// similarly, define exange rate signals &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;xchange&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;246.0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;inDollar&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;()*&lt;/span&gt;&lt;span class="n"&gt;xchange&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;note the difference between var assignment and signal update:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;v = v+1&lt;/code&gt;: the new value is old value + 1 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;s() = s() + 1&lt;/code&gt;: the s is a function that is always 1 larger than itself (cyclic definitions) &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="lecture-43-a-simple-frp-implementation"&gt;Lecture 4.3 - A Simple FRP Implementation&lt;/h1&gt;
&lt;p&gt;implementation of &lt;code&gt;Singal&lt;/code&gt; and &lt;code&gt;Var&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;class API:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;](&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;???&lt;/span&gt; &lt;span class="c1"&gt;// s() give cur value &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;](&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// construct new signal &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;](&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;](&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;???&lt;/span&gt; &lt;span class="c1"&gt;// s()=expr for update &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;](&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or more convientently:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use &lt;code&gt;sig()&lt;/code&gt; get the signal's (current) value &lt;/li&gt;
&lt;li&gt;use &lt;code&gt;sig() = {new_expr}&lt;/code&gt; to update the signal's expression &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="implemention-idea"&gt;implemention idea&lt;/h2&gt;
&lt;h3 id="signal"&gt;Signal&lt;/h3&gt;
&lt;p&gt;each &lt;code&gt;sig: Signal[T]&lt;/code&gt; maintains:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;its *current value * &lt;/p&gt;
&lt;p&gt;&lt;code&gt;private var myValue: T&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;its *current expression * &lt;/p&gt;
&lt;p&gt;&lt;code&gt;private var myexpr: () =&amp;gt; T&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set of &lt;em&gt;observers &lt;/em&gt;: other signals (&lt;strong&gt;callersig&lt;/strong&gt;s) that depend on &lt;code&gt;this.myValue&lt;/code&gt;  — if &lt;code&gt;this.myValue&lt;/code&gt; changes, all signals in this.observers should be re-evaluated  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;private var observers: Set[Signal[_]]&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;protected  function to re-evaluate value &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;protected def computeValue(): Unit&lt;/code&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;protected function to change expression  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;protected def update(expr: =&amp;gt; T): Unit&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;How to record dependencies:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;when evaluating a &lt;code&gt;Signal&lt;/code&gt;, need to know which &lt;code&gt;callersig&lt;/code&gt; gets defined by &lt;code&gt;this&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;So we should add the caller to &lt;code&gt;this.observers&lt;/code&gt; when &lt;code&gt;apply&lt;/code&gt; is called (like: &lt;code&gt;sig()&lt;/code&gt;).  &lt;/li&gt;
&lt;li&gt;if &lt;code&gt;this.myValue&lt;/code&gt; changes (when calling &lt;code&gt;computeValue()&lt;/code&gt;), all caller signals in &lt;code&gt;this.observers&lt;/code&gt; are re-evaluated (&lt;code&gt;callersig.computeValue()&lt;/code&gt;); and &lt;code&gt;this.observers&lt;/code&gt; is &lt;strong&gt;cleared(!! see next item)&lt;/strong&gt;.  &lt;/li&gt;
&lt;li&gt;when &lt;code&gt;callersig&lt;/code&gt;s re-evaluate their expression, the &lt;code&gt;apply()&lt;/code&gt; method will add the &lt;code&gt;callersig&lt;/code&gt; again to &lt;code&gt;this.observers&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="caller"&gt;caller&lt;/h3&gt;
&lt;p&gt;How to find out &lt;em&gt;who is calling&lt;/em&gt; so that a signal is evaluated ? 
simplistic way: maintain a &lt;em&gt;global&lt;/em&gt; data structure (stack-fashion) referring to current &lt;code&gt;caller: StackableVariable[Signal[T]]&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;caller&lt;/code&gt; is a global "stack" of &lt;code&gt;callersig&lt;/code&gt;s that get poped/pushed.  &lt;/p&gt;
&lt;p&gt;The API of the &lt;code&gt;StackableVariable[Signal[T]]&lt;/code&gt; class:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;caller.value: Signal[T]&lt;/code&gt;:  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;get &lt;em&gt;the callersig on top of stack, which depends on currently evaluating signal&lt;/em&gt; (&lt;code&gt;this&lt;/code&gt;), and so should be added to &lt;code&gt;this.observers&lt;/code&gt;. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;caller.withValue(sig:Signal[T])(expr: () =&amp;gt; [T])&lt;/code&gt;:  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;first add &lt;code&gt;sig&lt;/code&gt; to the top of stack; then evaluate &lt;code&gt;expr&lt;/code&gt;; finally pop &lt;code&gt;sig&lt;/code&gt; off the stack.  &lt;/p&gt;
&lt;p&gt;Here is the implementation of the &lt;code&gt;caller&lt;/code&gt; : &lt;br/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun2_lec4_var/pasted_image005.png"/&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;So whenever &lt;code&gt;sig&lt;/code&gt; want to know who depends on it, it just use &lt;code&gt;caller.value&lt;/code&gt;;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;thus, in the &lt;code&gt;apply&lt;/code&gt; method of &lt;code&gt;Signal&lt;/code&gt;s, we write like this:   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;observers&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;caller&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="c1"&gt;// caller.value=top of stack, it depends on currenlty-evaluating value (this), so it should be added to this.observers &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="o"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;caller&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;observers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contains&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="s"&gt;"cyclic signal definition"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;myValue&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;And if &lt;code&gt;sig&lt;/code&gt; want to depend on other signals, in order to write the expression(which includes other signals that sig depends on), it use: &lt;code&gt;caller.withValue(this){expr...}&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;so in &lt;code&gt;computeValue()&lt;/code&gt;, as &lt;code&gt;this.myExpr&lt;/code&gt; may contain other signals that &lt;code&gt;this&lt;/code&gt; depend on, we should write:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;protected&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;computeValue&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sig&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;observed&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;observers&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;observed&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Nil&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;newValue&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;caller&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;withValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;myExpr&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt; &lt;span class="c1"&gt;// withValue will add this to the top of stack, so when eval other signals, they know that it's this signal that depends on them&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myValue&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;newValue&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// re-evaluate all callersigs that depends on this&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;myValue&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newValue&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;obs&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;observers&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;observers&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// clear observers for this: the callersigs may be added back in apply()&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;obs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;computeValue&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt; &lt;span class="c1"&gt;// here this.observers might be added with calersigs&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="o"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;problem: global stack is not good... especially for concurrency  ⇒ replace global state by &lt;em&gt;thread-local state&lt;/em&gt;.  &lt;/p&gt;
&lt;p&gt;Or use &lt;em&gt;implicit parameteres&lt;/em&gt;: pass current value of the thread-local variable into a signal expr as implicit parameter.  &lt;/p&gt;
&lt;h1 id="lecture-4445-latency-as-an-effect"&gt;Lecture 4.4/4.5 - Latency as an Effect&lt;/h1&gt;
&lt;p&gt;(I didn't quite get the point from this lecture on...) &lt;/p&gt;
&lt;p&gt;when computation takes a lot of time: register a &lt;strong&gt;callback&lt;/strong&gt; when computation terminates (either success or failure).  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;Future[T]&lt;/code&gt;: a &lt;strong&gt;monad&lt;/strong&gt; that handles both exceptions and latency &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nc"&gt;Future&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;onComplete&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Try&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;Unit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The callback use pattern matching:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ts&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Success&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;onNext&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Failure&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;onError&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;another option: give 2 callbacks, one for success, one for failure.  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;def onCompelet(success: T=&amp;gt;Unit, failed: Throwable =&amp;gt; Unit): Unit&lt;/code&gt; &lt;/p&gt;
&lt;h1 id="lecture-46474849410-combinators-on-futurescomposing-futures"&gt;Lecture 4.6/4.7/4.8/4.9/4.10 - Combinators on Futures/Composing Futures&lt;/h1&gt;
&lt;p&gt;higher-order funcitons on &lt;code&gt;Future&lt;/code&gt;s: map/filter/flatMap/... &lt;/p&gt;
&lt;p&gt;recover/recoverWith for Error case ⇔ map/flatMap for Future. &lt;/p&gt;
&lt;p&gt;fallbackTo:  &lt;/p&gt;
&lt;p&gt;retry: deal with failure...  &lt;/p&gt;
&lt;p&gt;turn recursion to foldleft/foldright...  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec4_var/pasted_image009.png"/&gt; &lt;/p&gt;
&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;lazy evaluation: infinite data structure &lt;/li&gt;
&lt;li&gt;distinction between computations and values: random/signal are computations &lt;/li&gt;
&lt;li&gt;monads: abstract over properties of computations, encapsulate mutations, ... &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mix FP and mutable state &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;laziness &lt;/li&gt;
&lt;li&gt;FRP &lt;/li&gt;
&lt;li&gt;monads &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec4_var/pasted_image010.png"/&gt; &lt;/p&gt;
&lt;h1 id="exercice-calculator"&gt;exercice: calculator&lt;/h1&gt;
&lt;p&gt;Use Function Reactive Programming (FRP), with the Signal[A] class that you have seen in the lectures, to implement a spreadsheet-like calculator. In this calculator, cells can depend on the value of other cells, and are recomputed automatically when the latter change.  &lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/X-Wei/Coursera-progfun2/tree/master/hw4-calculator"&gt;https://github.com/X-Wei/Coursera-progfun2/tree/master/hw4-calculator&lt;/a&gt; &lt;/p&gt;</summary><category term="scala"></category></entry><entry><title>[Scala MOOC II] Lec 3: Functions and State</title><link href="http://x-wei.github.io/progfun2_lec3_var.html" rel="alternate"></link><published>2016-10-31T00:00:00+01:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-10-31:progfun2_lec3_var.html</id><summary type="html">
&lt;p&gt;This week: scala for imperative programming.   &lt;/p&gt;
&lt;h1 id="lecture-31-functions-and-state"&gt;Lecture 3.1 - Functions and State&lt;/h1&gt;
&lt;p&gt;So far: pure functional programming&lt;br/&gt;
→ side-effect free: therefore &lt;em&gt;time doesn't matter&lt;/em&gt;. &lt;br/&gt;
Any rewriting that terminates lead to the same solution. (Churcher-Rosser Th)&lt;br/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun2_lec3_var/pasted_image.png"/&gt; &lt;/p&gt;
&lt;p&gt;Now: &lt;strong&gt;mutable states&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Stateful objects&lt;/em&gt;: objects can have state that change over time. (state is influenced by its history). ⇒ variables &lt;code&gt;var&lt;/code&gt; in scala, associates a value to a name, and can be changed by assignment.   &lt;/p&gt;
&lt;p&gt;ex. bank account — pretty much like java class  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BankAccount&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;balance&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;deposit&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;amount&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;amount&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;balance&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;balance&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;amount&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;withdraw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;amount&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;amount&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;amount&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;balance&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;balance&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;balance&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;amount&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;balance&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Error&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"insufficient balance"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;acct&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;BankAccount&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;acct&lt;/span&gt; &lt;span class="n"&gt;deposit&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;acct&lt;/span&gt; &lt;span class="n"&gt;withdraw&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;acct&lt;/span&gt; &lt;span class="n"&gt;withdraw&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ex2. streams impolemented using mutable variable  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec3_var/pasted_image001.png"/&gt; &lt;/p&gt;
&lt;h1 id="lecture-32-identity-and-change"&gt;Lecture 3.2 - Identity and Change&lt;/h1&gt;
&lt;p&gt;when are 2 (&lt;em&gt;mutable&lt;/em&gt;) objs equal ? → what is equal?   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;strong&gt;operationally equivalent&lt;/strong&gt; if no possible &lt;em&gt;test&lt;/em&gt; can distinguish between them.   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;to test if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are the same: &lt;br/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun2_lec3_var/pasted_image002.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;em&gt;The substitution model is no longer valid&lt;/em&gt;:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;x and y are &lt;code&gt;not&lt;/code&gt; the same:  &lt;/p&gt;
&lt;p&gt;val x = new BankAccount&lt;br/&gt;
val y = new BankAccount  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;x and y are the same:  &lt;/p&gt;
&lt;p&gt;val x = new BankAccount&lt;br/&gt;
val y = x  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="lecture-33-loops"&gt;Lecture 3.3 - Loops&lt;/h1&gt;
&lt;p&gt;prop: &lt;code&gt;var&lt;/code&gt;s are already enough to model all imperative programs. &lt;em&gt;Can model loops using functions&lt;/em&gt;.   &lt;/p&gt;
&lt;p&gt;ex. scala while loop   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;power&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;exp&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;r&lt;/span&gt;   &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This while loop can be implemented using a function &lt;code&gt;WHILE&lt;/code&gt;:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nc"&gt;WHILE&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;Unit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;// cond and cmd must be passed by name  &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;comd&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="nc"&gt;WHILE&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// or `()`=Unit (= void in java)  &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;exercice: write a REPEAT function: &lt;code&gt;REPEAT{cmd} (condition)&lt;/code&gt; , similar to &lt;code&gt;do...while&lt;/code&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nc"&gt;REPEAT&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;Unit&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;cmd&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// stop  &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="nc"&gt;REPEAT&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;do-while loop syntax in scala: &lt;code&gt;do{cmd}while(cond)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;the classical &lt;code&gt;for&lt;/code&gt; loop in java can NOT be modeled by higher-order function, because the for loop arguments contains declaration of a variable i. However, in scala, use:   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;for(i &amp;lt;- 1 until 3) println(i)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;This is similar to previously discussed &lt;code&gt;for-expression&lt;/code&gt;, but using &lt;code&gt;foreach&lt;/code&gt; instead of &lt;code&gt;map&lt;/code&gt;/&lt;code&gt;flatMap&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;example:   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;for(i&amp;lt;-i until 3; j&amp;lt;- "abc") println(i+" "+j)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;translates to:   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;(1 until 3) foreach (i =&amp;gt; "abc" foreach (j =&amp;gt; println(i+" "+j)))&lt;/code&gt; &lt;/p&gt;
&lt;h1 id="lecture-34-extended-example-discrete-event-simulation"&gt;Lecture 3.4 - Extended Example: Discrete Event Simulation&lt;/h1&gt;
&lt;p&gt;digital circuit simulator. &lt;br/&gt;
A digital circuit(DC) is composed of &lt;code&gt;wires&lt;/code&gt; and functional components.   &lt;/p&gt;
&lt;p&gt;Basic components: Inverter, AND gate, OR gate&lt;br/&gt;
components have reaction time (&lt;em&gt;delay&lt;/em&gt;)  &lt;/p&gt;
&lt;p&gt;diagrams: &lt;br/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun2_lec3_var/pasted_image003.png"/&gt; &lt;/p&gt;
&lt;p&gt;example: half adder (input=a,b, output=sum and carry)  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec3_var/pasted_image005.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;language&lt;/strong&gt; to describe digital circuits: using classes and functions  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Wire&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;inverter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;andGate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a2&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;orGate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a2&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ouput&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a half adder can be defined as:   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;halfAdder&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Wire&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;orGate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;andGate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;inverter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;andGate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec3_var/pasted_image006.png"/&gt; &lt;/p&gt;
&lt;p&gt;And this half adder can be used as another component, for example, for &lt;em&gt;full adder&lt;/em&gt;:   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec3_var/pasted_image007.png"/&gt; &lt;/p&gt;
&lt;h1 id="lecture-35-discrete-event-simulation-api-and-usage"&gt;Lecture 3.5 - Discrete Event Simulation: API and Usage&lt;/h1&gt;
&lt;p&gt;give implementations of the digital circuits, based on an API for discrete event simulation.   &lt;/p&gt;
&lt;h3 id="discrete-evenet-simulator"&gt;discrete evenet simulator&lt;/h3&gt;
&lt;p&gt;performs &lt;em&gt;actions&lt;/em&gt;, specified by user at a given &lt;em&gt;moment&lt;/em&gt;.  &lt;/p&gt;
&lt;p&gt;An &lt;code&gt;Action&lt;/code&gt;: a function that takes 0 parameters and returns &lt;code&gt;Unit&lt;/code&gt;.   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;type Action = () =&amp;gt; Unit&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;class hierachy:   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec3_var/pasted_image008.png"/&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nc"&gt;Simulation&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;currentTime&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;???&lt;/span&gt;   &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;afterDelay&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dalay&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;Unit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;???&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;???&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;abstract&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Gates&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Simulation&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;{...}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="o"&gt;...}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;abstract&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Circuits&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Gates&lt;/span&gt;&lt;span class="o"&gt;{...}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;sim&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Circuits&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;...&lt;/span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Wire&lt;/code&gt; class:&lt;br/&gt;
state of a wire is modeled by 2 private vars  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getSignal: Boolean&lt;/code&gt;: current value of signal in wire  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;setSignal(sig:Boolean):Unit&lt;/code&gt; : modifies value of signal  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;addAction(a: Action): Unit&lt;/code&gt;: attach actions to be &lt;em&gt;executed at each change of signal&lt;/em&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sigVal&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;actions&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Action&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;getSignal&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sigVal&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;setSignal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getSignal&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;sigVal&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sig&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;actions&lt;/span&gt; &lt;span class="n"&gt;foreach&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt; &lt;span class="c1"&gt;// for(a&amp;lt;-actions) a()  &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;addAction&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;actions&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;actions&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// have to perform it when added   &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Inverter&lt;/code&gt;:&lt;em&gt;install an action on its input wire&lt;/em&gt;, the change is effective after a delay.   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;inverter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;invertAction&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;inputSig&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSignal&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;afterDelay&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;InverterDelay&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;setSignal&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;inputSig&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;addAction&lt;/span&gt; &lt;span class="n"&gt;invertAction&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;andGate/orGate&lt;/code&gt;is similar:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec3_var/pasted_image009.png"/&gt; &lt;/p&gt;
&lt;h1 id="lecture-36-discrete-event-simulation-implementation-and-test"&gt;Lecture 3.6 - Discrete Event Simulation: Implementation and Test&lt;/h1&gt;
&lt;p&gt;implement the simulation trait: keep each instance of &lt;code&gt;Simulation&lt;/code&gt; in &lt;code&gt;agenda&lt;/code&gt; of actions to perform.   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;Agenda&lt;/code&gt; is a list of &lt;code&gt;Event&lt;/code&gt;s, each event consists of an &lt;code&gt;action&lt;/code&gt; and the &lt;code&gt;time&lt;/code&gt;, sorted by actions' time.   &lt;/p&gt;
&lt;p&gt;To run the simulation, use a &lt;code&gt;loop&lt;/code&gt; to handle events in agenda.   &lt;/p&gt;
&lt;p&gt;To examine the changes of the signals in wires, use funciton &lt;code&gt;probe&lt;/code&gt;.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nc"&gt;Simulation&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;Unit&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Event&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Action&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Agenda&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Event&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;agenda&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Agenda&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;curtime&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;currentTime&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;curtime&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;afterDelay&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;Unit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Event&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentTime&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;agenda&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;agenda&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//insert to the write time  &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ag&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Event&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Event&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Event&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ag&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rest&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rest&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ag&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="c1"&gt;// event handling loop  &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;agenda&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rest&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;agenda&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rest&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;curtime&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Nil&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;afterDelay&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;s"*** simulation started, time = &lt;/span&gt;&lt;span class="si"&gt;$currentTime&lt;/span&gt;&lt;span class="s"&gt; ***"&lt;/span&gt;&lt;span class="o"&gt;)}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;probe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wire&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Wire&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;probeAction&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;s"&lt;/span&gt;&lt;span class="si"&gt;$name&lt;/span&gt;&lt;span class="s"&gt; time = &lt;/span&gt;&lt;span class="si"&gt;$currentTime&lt;/span&gt;&lt;span class="s"&gt;, value = &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="n"&gt;wire&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getSignal&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// string formatting in scala  &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;addAction&lt;/span&gt; &lt;span class="n"&gt;probeAction&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to pack delay constrains into their own trait, use &lt;code&gt;extend..with..&lt;/code&gt; syntax:   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nc"&gt;Parameters&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nc"&gt;InverterDelay&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nc"&gt;AndGateDelay&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nc"&gt;OrGateDelay&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;sim&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Circuits&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;Paramters&lt;/span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="summary"&gt;summary&lt;/h3&gt;
&lt;p&gt;state and assignments make model more complicates, lose referential transparency&lt;br/&gt;
on the other hand, assignments allow formulate certain programs in an elegant way.   &lt;/p&gt;
&lt;h1 id="programming-assignment-quickcheck"&gt;Programming Assignment: Quickcheck&lt;/h1&gt;
&lt;p&gt;This assignment has nothing to do with the mutable data... but rather to use scalacheck for testing.   &lt;/p&gt;
&lt;p&gt;Write properties that a heap should have to test heap implementations.   &lt;/p&gt;
&lt;h3 id="about-generator"&gt;about Generator&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md#generators"&gt;https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md#generators&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;my code: &lt;br/&gt;
&lt;a href="https://github.com/X-Wei/Coursera-progfun2/tree/master/hw3-quickcheck/quickcheck"&gt;https://github.com/X-Wei/Coursera-progfun2/tree/master/hw3-quickcheck/quickcheck&lt;/a&gt;&lt;/p&gt;</summary><category term="scala"></category></entry><entry><title>[Scala MOOC II] Lec2: Lazy Evaluation</title><link href="http://x-wei.github.io/progfun2_lec2_lazyeval.html" rel="alternate"></link><published>2016-10-22T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-10-22:progfun2_lec2_lazyeval.html</id><summary type="html">
&lt;h1 id="lecture-21-structural-induction-on-trees-optional"&gt;Lecture 2.1 - Structural Induction on Trees (optional)&lt;/h1&gt;
&lt;p&gt;Generalize the structural induction on list to general structures like trees.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To prove a property &lt;code&gt;P(t)&lt;/code&gt; for all trees &lt;code&gt;t&lt;/code&gt;: &lt;br/&gt;
    * show for any leave l, &lt;code&gt;P(l)&lt;/code&gt; holds&lt;br/&gt;
    * for each internal node &lt;code&gt;t&lt;/code&gt; with subtrees &lt;code&gt;s1...sn&lt;/code&gt;, show &lt;code&gt;P(s1)&amp;amp;...&amp;amp;P(sn)&lt;/code&gt; holds  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="example-prove-correctness-for-intsets"&gt;Example: Prove correctness for IntSets&lt;/h2&gt;
&lt;p&gt;recall the &lt;code&gt;IntSet&lt;/code&gt; def: empty set or non-empty set organized in a binary (search) tree structure. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;abstract&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;IntSet&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;incl&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;IntSet&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;contains&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Boolean&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;Empty&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;IntSet&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;contains&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Boolean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;incl&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;IntSet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;NonEmpty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Empty&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Empty&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;NonEmpty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;IntSet&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;IntSet&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;IntSet&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="c1"&gt;// NonEmpty is just a BST &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;contains&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Boolean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="n"&gt;contains&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="n"&gt;contains&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;incl&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;IntSet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nc"&gt;NonEmpty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="n"&gt;incl&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nc"&gt;NonEmpty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="n"&gt;incl&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Prove the correctness&lt;/strong&gt; of this implementation: show that it respects certain laws:  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;prop1:&lt;/strong&gt; &lt;code&gt;Empty contains x = false&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;pf: easy... &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;prop2:&lt;/strong&gt; &lt;code&gt;(s incl x) contains x = true&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;pf: proof by structual induction on &lt;code&gt;s&lt;/code&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;base case: &lt;code&gt;s = Empty&lt;/code&gt;,  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;(Empty incl x) = NonEmpty(x, Empty, Empty) &lt;/span&gt;
&lt;span class="code-line"&gt;NonEmpty(x, Empty, Empty) contains x = true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;induction step: &lt;code&gt;s=NonEmpty(z,l,r)&lt;/code&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;first case, &lt;code&gt;z=x&lt;/code&gt; 
        s incl x = NonEmpty(x,l,r) incl x = NonEmpty(x,l,r) &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;so &lt;code&gt;NonEmpty(x, l, r) contains x = true&lt;/code&gt; 
- second case, z&amp;lt;x 
&lt;code&gt;s incl x = NonEmpty(z,l,r) incl x = NonEmpty(z,l,r incl x)&lt;/code&gt; 
so: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;(s incl x) contains x  &lt;/span&gt;
&lt;span class="code-line"&gt;= NonEmpty(z,l,r incl x) contains x  &lt;/span&gt;
&lt;span class="code-line"&gt;= (r incl x) contains x = ture // by induction hypothesis&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;third case, z&amp;gt;x: symmetric ... &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;prop3:&lt;/strong&gt; if x!=y, &lt;code&gt;(s incl x) contains y = s contains y&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;pf: by structual induction &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;base case: &lt;code&gt;s = Empty&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;induction step: &lt;code&gt;s=NonEmpty(z,l,r)&lt;/code&gt; 
    5 cases to consider... &lt;ul&gt;
&lt;li&gt;z=x &lt;/li&gt;
&lt;li&gt;z=y &lt;/li&gt;
&lt;li&gt;z&amp;lt;y&amp;lt;x &lt;/li&gt;
&lt;li&gt;y&amp;lt;z&amp;lt;x &lt;/li&gt;
&lt;li&gt;y&amp;lt;x&amp;lt;z &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="lecture-22-streams"&gt;Lecture 2.2 - Streams&lt;/h1&gt;
&lt;p&gt;motivation: 2nd prime number between 1000 and 10000:  &lt;/p&gt;
&lt;p&gt;elegant, but not efficient solution:&lt;br/&gt;
&lt;code&gt;( (1000 to 10000) filter isPrime) (1)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;→ ALL prime numbers are constructed in the code, only use the first 2 elements...  &lt;/p&gt;
&lt;p&gt;⇒ *avoid computing the tail of a seq until necessary * &lt;/p&gt;
&lt;p&gt;→ new data structure: &lt;code&gt;Stream&lt;/code&gt;s, like lists, but &lt;em&gt;tail is eval only on demand&lt;/em&gt; &lt;/p&gt;
&lt;h2 id="stream-class"&gt;Stream class&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;constructor&lt;/strong&gt; 
Streams defined from either constant &lt;code&gt;Stream.empty&lt;/code&gt; and constructor &lt;code&gt;Stream.cons&lt;/code&gt; 
ex: &lt;code&gt;val xs = Stream.cons(1, Stram.cons(2, Stream.empty))&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;(Stream.empty~=&lt;code&gt;Nil&lt;/code&gt;, Stream.cons~=&lt;code&gt;::&lt;/code&gt;) &lt;/p&gt;
&lt;p&gt;or by using the &lt;code&gt;Stream&lt;/code&gt; object as a factory (like other collections): &lt;code&gt;val xs = Stream(1,2,3)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;toStream()&lt;/strong&gt;
&lt;code&gt;toStream&lt;/code&gt; on a collection will turn the collection into a stream.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toStream&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;res1&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;scala.collection.immutable.Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;?)&lt;/span&gt; &lt;span class="c1"&gt;// the tail is (?) -- not evaled &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The tail is not evaled! &lt;/p&gt;
&lt;p&gt;let's write a function to return a range as Stream ( returns &lt;code&gt;(lo until hi).toStream)&lt;/code&gt; ):  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;streamRange&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cons&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stramRange&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;other methods&lt;/strong&gt;
&lt;code&gt;Stream&lt;/code&gt; supports almost all method of a &lt;code&gt;List&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;((1000 to 10000).toStream filter isPrime)(1)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;Exception: concat operator &lt;code&gt;::&lt;/code&gt; will always return a list instead of a stream. 
→ alternative: &lt;code&gt;#::&lt;/code&gt; returns a stream 
&lt;code&gt;x#::xs == Stream.cons(x,xs)&lt;/code&gt; &lt;/p&gt;
&lt;h2 id="implementation-of-streams"&gt;Implementation of Streams&lt;/h2&gt;
&lt;p&gt;similar to the implementation of lists.  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;scala
trait Stream[+A] extends Seq[A]{ 
    def isEmpty: Boolean 
    def head: A 
    def tail: Stream [A] 
}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;concrete implementations are in the &lt;code&gt;Stream&lt;/code&gt; &lt;em&gt;companion object&lt;/em&gt;: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;cons&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;](&lt;/span&gt;&lt;span class="n"&gt;hd&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tl&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="c1"&gt;// **`=&amp;gt;`: tl is by name, will be evaled later!  &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;]{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isEmpty&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hd&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;tail&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tl&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Nothing&lt;/span&gt;&lt;span class="o"&gt;]{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isEmpty&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;NoSuchElementException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"empty.head"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;tail&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;NoSuchElementException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"empty.tail"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;all other methods are implemented similar to list counterparts...&lt;br/&gt;
ex:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;+T&lt;/span&gt;&lt;span class="o"&gt;]{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="c1"&gt;//... &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isEmpty&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="n"&gt;cons&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="c1"&gt;// tail.filter(p) will be evaled on demande&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="c1"&gt;//... &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="lecture-23-lazy-evaluation"&gt;Lecture 2.3 - Lazy Evaluation&lt;/h1&gt;
&lt;p&gt;pb with the last implementation of Streams: if tail is called several times, the corresponding stram will be re-computed each time.  &lt;/p&gt;
&lt;p&gt;→ can store the 1st result of the eval and use it later. (As in FP, the eval result never change) &lt;/p&gt;
&lt;p&gt;⇒ this scheme is called &lt;strong&gt;lazy evaluation&lt;/strong&gt;, as opposed to both by-name evaluation (&lt;code&gt;def x&lt;/code&gt;) and strict-evaluation (&lt;code&gt;val x&lt;/code&gt;). avoids both unnessary and repeated eval.  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;lazy val x = expr&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;exercice:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec2_lazyeval/pasted_image.png"/&gt; 
→ this will print: "xzyz" &lt;/p&gt;
&lt;p&gt;adapt the lazy scheme for Stream implementation:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;cons&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;](&lt;/span&gt;&lt;span class="n"&gt;hd&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tl&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;]{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hd&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;lazy&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;tail&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tl&lt;/span&gt; &lt;span class="c1"&gt;// **lazy instead of `def`** &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="c1"&gt;//... &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="lecture-24-computing-with-infinite-sequences"&gt;Lecture 2.4 - Computing with Infinite Sequences&lt;/h1&gt;
&lt;p&gt;with lazyness, can deal with inf seqs. ⇒ &lt;em&gt;infinite Streams&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;example: the stream of all integers starting from a given number:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def from(n: Int): Stream[Int] =  &lt;/span&gt;
&lt;span class="code-line"&gt;n #:: from(n+1) // non-terminating recursive call here&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;all natural numbers:&lt;br/&gt;
&lt;code&gt;val nats = from(0)&lt;/code&gt; 
all multiples of 4:&lt;br/&gt;
&lt;code&gt;nats map (_ * 4)&lt;/code&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;#::&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;n:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="kt"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;nats&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;nats&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;?)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;m4s&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nats&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;m4s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;scala.collection.immutable.Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;?)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m4s&lt;/span&gt; &lt;span class="n"&gt;take&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toList&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;res2&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;28&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;36&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt; &lt;span class="err"&gt;``&lt;/span&gt;&lt;span class="n"&gt;`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;example1: Sieve of Eratosthenes &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;------------------------------- &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;![](../images/progfun2_lec2_lazyeval/pasted_image001.png) &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;written in scala:  &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;`&lt;/span&gt;&lt;span class="err"&gt;``&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;sieve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="c1"&gt;// param s is the prime numbers for sieve &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;#::&lt;/span&gt; &lt;span class="n"&gt;sieve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt; &lt;span class="n"&gt;filter&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;primes&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sieve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;primes&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;?)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;primes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;take&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toList&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;res0&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;29&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;41&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;47&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;53&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;59&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;61&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;67&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;71&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;73&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;79&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;83&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;89&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;97&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;101&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;103&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;107&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;109&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;113&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;127&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;131&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;137&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;139&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;149&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;151&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;157&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;163&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;167&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;173&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;179&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;181&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;191&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;193&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;197&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;199&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;211&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;223&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;227&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;229&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;233&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;239&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;241&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;251&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;257&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;263&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;269&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;271&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;277&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;281&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;283&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;293&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;307&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;311&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;313&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;317&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;331&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;337&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;347&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;349&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;353&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;359&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;367&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;373&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;379&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;383&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;389&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;397&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;401&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;409&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;419&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;421&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;431&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;433&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;439&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;443&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;449&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;457&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;461&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;463&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;467&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;479&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;487&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;491&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;499&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;503&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;509&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;521&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;523&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;541&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="example2-square-root"&gt;example2: square root&lt;/h2&gt;
&lt;p&gt;previous implementation: use &lt;code&gt;isGoodEnough&lt;/code&gt; test termination. 
now: express the converging seq without having to worry about when to terminate:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;sqrtStream&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;improve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guess&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;guess&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;lazy&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;guesses&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;#::&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guesses&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;improve&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//**this will not explod!** &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;guesses&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isGoodEnough&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guess&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;0.0001&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sqrtStream&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;filter&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isGoodEnough&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// get the 1st guess that is good enough &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="lecture-25-case-study-the-water-pouring-problem"&gt;Lecture 2.5 - Case Study: the Water Pouring Problem&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;task: "water pouring problem"&lt;/strong&gt; 
given: source, sink, glasses of different sizes, target size...&lt;br/&gt;
goal: fill/empty/move water from 1 glass to another 
&lt;img alt="" class="img-responsive" src="../images/progfun2_lec2_lazyeval/pasted_image002.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Model&lt;/strong&gt; 
Glass: &lt;code&gt;Int&lt;/code&gt; 
State: &lt;code&gt;Vector[Int]&lt;/code&gt; one entry per glass 
Moves:&lt;br/&gt;
&lt;code&gt;Empty(glass), Fill(glass), Pour(from, to)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec2_lazyeval/pasted_image004.png"/&gt; 
question: how to find the correct sequence of moves ?&lt;br/&gt;
⇒ BFS, generate all possible paths (from initial state where all glasses are empty) of length=1,2,3,...  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Implementation&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;first: define Move classes, they have a change method, take one state as param and return a state:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Pouring&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Vector&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;State&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Vector&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;initialState&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nc"&gt;Move&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;change&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;State&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;State&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Empty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;glass&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Move&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;change&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;State&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;updated&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;glass&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Fill&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;glass&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Move&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;change&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;State&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;updated&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;glass&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;glass&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Pour&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Move&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;change&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;State&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;={&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;amount&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;)-&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;//the amount to move &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="n"&gt;updated&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;)-&lt;/span&gt;&lt;span class="n"&gt;amount&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;updated&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;)+&lt;/span&gt;&lt;span class="n"&gt;amount&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;...&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;generate all possible moves:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;glasses&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;indices&lt;/span&gt; &lt;span class="c1"&gt;// equal to `0 until capacity.length` &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;moves&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt;  &lt;span class="c1"&gt;// all possible moves &lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="k"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="n"&gt;glasses&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="nc"&gt;Empty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="k"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="n"&gt;glasses&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="nc"&gt;Fill&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gfrom&lt;/span&gt;&lt;span class="k"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="n"&gt;glasses&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;gto&lt;/span&gt;&lt;span class="k"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="n"&gt;glasses&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;gfrom&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;gto&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="nc"&gt;Pour&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gfrom&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;gto&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then define a &lt;code&gt;Path&lt;/code&gt; class: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Path&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;history&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Move&lt;/span&gt;&lt;span class="o"&gt;]){&lt;/span&gt;&lt;span class="c1"&gt;// history: moves in reversed order&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;endState&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;State&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="c1"&gt;// given a path (list ot moves), return the final state by following the path&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;history&lt;/span&gt; &lt;span class="n"&gt;foldRight&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initialState&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mv&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Move&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stt&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;State&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;mv&lt;/span&gt; &lt;span class="n"&gt;change&lt;/span&gt; &lt;span class="n"&gt;stt&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// as in the list are reversed order of moves, use foldright&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Move&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Path&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;history&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toString&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;history&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reverse&lt;/span&gt; &lt;span class="n"&gt;mkString&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;"--&amp;gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;endState&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;initialPath&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Path&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Nil&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then define a &lt;code&gt;Stream&lt;/code&gt; of path sets: given current (set of) paths, extend one move and generate (a set of) paths of longer length:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;paths&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Path&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Path&lt;/span&gt;&lt;span class="o"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;={&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;paths&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isEmpty&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="k"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="n"&gt;paths&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;moves&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extend&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;paths&lt;/span&gt; &lt;span class="o"&gt;#::&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;more&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="o"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;pathSets&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initialPath&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;finally, solve the problem: for each path, track its end state, and if the target value is in the end state, return the path.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;solutions&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Path&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;pathsets&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;pathSets&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;pathsets&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endState&lt;/span&gt; &lt;span class="n"&gt;contains&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pb: too slow for some case 
→ we generate ALL paths of a certain length in the stream, but in the paths, we should avoid returning to a preivous state !&lt;br/&gt;
→ re-define the &lt;code&gt;from&lt;/code&gt; function: add a param of explored set of states.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;paths&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Path&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt; &lt;span class="n"&gt;explored&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;State&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Path&lt;/span&gt;&lt;span class="o"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;={&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;paths&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isEmpty&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="k"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="n"&gt;paths&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;nextpath&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;moves&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extend&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;explored&lt;/span&gt; &lt;span class="n"&gt;contains&lt;/span&gt; &lt;span class="n"&gt;nextpath&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endState&lt;/span&gt;&lt;span class="o"&gt;)==&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;nextpath&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;newstates&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endState&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;      &lt;span class="n"&gt;paths&lt;/span&gt; &lt;span class="o"&gt;#::&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;more&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;explored&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;union&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newstates&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="o"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="o"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;pathSets&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initialPath&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="nc"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initialState&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;→ more improvement: avoid computing &lt;code&gt;endState&lt;/code&gt;(a &lt;code&gt;foldRight&lt;/code&gt;) over and over again — add to class param.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Path&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;history&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Move&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;endState&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;State&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;&lt;span class="c1"&gt;// history: moves in reversed order&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Move&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Path&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;history&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;move&lt;/span&gt; &lt;span class="n"&gt;change&lt;/span&gt; &lt;span class="n"&gt;endState&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toString&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;history&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reverse&lt;/span&gt; &lt;span class="n"&gt;mkString&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;"--&amp;gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;endState&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec2_lazyeval/pasted_image005.png"/&gt; &lt;/p&gt;
&lt;h1 id="programming-assignment-bloxorz"&gt;Programming Assignment: Bloxorz&lt;/h1&gt;
&lt;p&gt;https://github.com/X-Wei/Coursera-progfun2/tree/master/hw2-stream-bloxorz/streams&lt;/p&gt;</summary><category term="scala"></category></entry><entry><title>[Scala MOOC II] Lec1: For Expressions and Monads</title><link href="http://x-wei.github.io/progfun2_lec1_forexpr.html" rel="alternate"></link><published>2016-08-12T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-08-12:progfun2_lec1_forexpr.html</id><summary type="html">
&lt;h1 id="recap-functions-and-pattern-matching"&gt;Recap: Functions and Pattern Matching&lt;/h1&gt;
&lt;h3 id="case-classes"&gt;case classes&lt;/h3&gt;
&lt;p&gt;ex: json
json objects can be seq, num, str, bool,...&lt;/p&gt;
&lt;p&gt;⇒ represented as abstract class and case classes. &lt;/p&gt;
&lt;h3 id="pattern-matching"&gt;pattern matching&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image002.png"/&gt;&lt;/p&gt;
&lt;p&gt;→ question: what is the type of the &lt;code&gt;{case(key, value)=&amp;gt;"..."}&lt;/code&gt; clause? &lt;/p&gt;
&lt;p&gt;it is &lt;code&gt;(JBinding =&amp;gt; String)&lt;/code&gt; type, which is a shorthand for &lt;code&gt;Function1[JBinding, String]&lt;/code&gt;. &lt;/p&gt;
&lt;h3 id="function1-trait"&gt;Function1 Trait&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image003.png"/&gt;&lt;/p&gt;
&lt;h3 id="subclass-a-function-type"&gt;subclass a function type&lt;/h3&gt;
&lt;p&gt;function types can also be extended ! &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image005.png"/&gt;&lt;/p&gt;
&lt;p&gt;element accessing can be written as function calls because &lt;code&gt;Seq&lt;/code&gt;s are functions!&lt;/p&gt;
&lt;h3 id="partial-match"&gt;Partial Match&lt;/h3&gt;
&lt;p&gt;if there is no match → throw MatchError&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val f: String=&amp;gt;String  = {case "ping" =&amp;gt; "pong"}&lt;/span&gt;
&lt;span class="code-line"&gt;f("ping") // no pb&lt;/span&gt;
&lt;span class="code-line"&gt;f("abc") // MatchError&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ define f as partial function&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val f: PartialFunction[String,String]  = {case "ping" =&amp;gt; "pong"}&lt;/span&gt;
&lt;span class="code-line"&gt;f.isDefinedAt("ping")&lt;/span&gt;
&lt;span class="code-line"&gt;f.isDefinedAt("abc")&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;isDefinedAt&lt;/code&gt; is a method for the &lt;code&gt;PartialFunction&lt;/code&gt; class. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image006.png"/&gt;&lt;/p&gt;
&lt;p&gt;The f definition is translated to: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image007.png"/&gt;&lt;/p&gt;
&lt;p&gt;But the &lt;code&gt;PartialFunction&lt;/code&gt; will only apply for level 1: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image008.png"/&gt;&lt;/p&gt;
&lt;h1 id="recap-collections"&gt;Recap: Collections&lt;/h1&gt;
&lt;p&gt;scala collections hirarchy: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image009.png"/&gt;&lt;/p&gt;
&lt;p&gt;collections &lt;em&gt;share&lt;/em&gt; some general methods (&lt;strong&gt;core methods&lt;/strong&gt;): &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;map&lt;/li&gt;
&lt;li&gt;flatMap&lt;/li&gt;
&lt;li&gt;filter&lt;/li&gt;
&lt;li&gt;foldLeft/foldRight&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(idealized) implementation of &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; on Lists: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image011.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image013.png"/&gt;&lt;/p&gt;
&lt;h3 id="for-expressions"&gt;For expressions&lt;/h3&gt;
&lt;p&gt;for-expr can &lt;em&gt;simplify combinations of core methods&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image014.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;the&lt;/strong&gt; &lt;strong&gt;lhs of a generator can also be a pattern!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image015.png"/&gt;&lt;/p&gt;
&lt;p&gt;pat &amp;lt;- expr &lt;/p&gt;
&lt;p&gt;is translated to : &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;x &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; expr withFilter &lt;span class="p"&gt;{&lt;/span&gt;case pat &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; true&lt;span class="p"&gt;;&lt;/span&gt; case _ &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; false&lt;/span&gt;
&lt;span class="code-line"&gt;                &lt;span class="p"&gt;}&lt;/span&gt; map &lt;span class="p"&gt;{&lt;/span&gt;case pat &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; x&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="11-queries-with-for"&gt;1.1 - Queries with For&lt;/h1&gt;
&lt;p&gt;for notation is equivalent to common ops on databases(ex. sql). &lt;/p&gt;
&lt;p&gt;ex. books in library&lt;/p&gt;
&lt;p&gt;&lt;code&gt;case class Book(title: String, authors: List[String])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;query1: books with author name is "Bird"&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; b&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;books&lt;span class="p"&gt;;&lt;/span&gt; a &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; b.authors &lt;span class="kr"&gt;if&lt;/span&gt; a startsWith &lt;span class="s"&gt;"Bird,"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;yield b.title&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;query2: books with "Program" in the title: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; b&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;books &lt;span class="kr"&gt;if&lt;/span&gt; b.title indexOf &lt;span class="s"&gt;"Program"&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;yield b.title&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;query3: names of authors who wrote &amp;gt;=2 books&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    b1 &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; books&lt;/span&gt;
&lt;span class="code-line"&gt;    b2 &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; books &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kr"&gt;if&lt;/span&gt; b1&lt;span class="o"&gt;!=&lt;/span&gt;b2&lt;/span&gt;
&lt;span class="code-line"&gt;    a1 &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; b1.authors&lt;/span&gt;
&lt;span class="code-line"&gt;    a2 &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; b2.authors&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kr"&gt;if&lt;/span&gt; a1&lt;span class="o"&gt;==&lt;/span&gt;a2&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield a1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;→ pb: the authors will be doubled → b1,b2 and b2,b1
⇒ change line 3 to &lt;code&gt;b1.title &amp;lt; b2.title&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;→ still pb: print 3 times if authors write 3 books... 
⇒ 
sol1. use &lt;code&gt;distinct&lt;/code&gt; function 
sol2. decalre books as Set instead of List. &lt;/p&gt;
&lt;h1 id="12-translation-of-for"&gt;1.2 - Translation of For&lt;/h1&gt;
&lt;p&gt;for expressions → higer order functions&lt;/p&gt;
&lt;p&gt;map, flatMap, filter can all be implemented with for expression:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image016.png"/&gt;&lt;/p&gt;
&lt;p&gt;In reality: scala translates for expr to map/flatMap/filter. &lt;/p&gt;
&lt;h3 id="implemention-of-for-expr-3-rules"&gt;implemention of for-expr: 3 rules&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rule 1: in for(..) only a simple generator &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;for(x &amp;lt;- l1) yield e2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;is translated to: &lt;code&gt;l1.map(x =&amp;gt; e2)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rule2: in for(..), followed by the generator there is a filter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;for(x &amp;lt;- l1 if f; s) yield e2 //s is seq of other generators and filters&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;is translated to: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;for( x &amp;lt;- l1.withFilter(x=&amp;gt;f) ) yield e2&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rule3: in for(..), starts with 2 generators → flatMap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;for( x&amp;lt;-l1; y&amp;lt;-l2; s) yield e3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;is translated to: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;l1.flatMap( x =&amp;gt; for(y&amp;lt;-l2; s) yield e3 )&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;example: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;b &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; books&lt;/span&gt;
&lt;span class="code-line"&gt;a &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; b.authors &lt;span class="kr"&gt;if&lt;/span&gt; a startsWith &lt;span class="s"&gt;"Bird"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield b.title&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;translated to: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;books flatMap ( &lt;/span&gt;
&lt;span class="code-line"&gt;    b =&amp;gt; b.authors.filter( a =&amp;gt; a startsWith "Bird").map(y=&amp;gt;y.title)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;NB: for expr is not restricted to collections, it supports any types with &lt;code&gt;map/flatMap/withFilter&lt;/code&gt; method. ⇒ use for expr for your own types as well. &lt;/p&gt;
&lt;h1 id="13-functional-random-generators"&gt;1.3 - Functional Random Generators&lt;/h1&gt;
&lt;p&gt;goal: use for expr on rand generators. &lt;/p&gt;
&lt;p&gt;for expr support any type with map/flatMap/filter ⇒ ex. rand value generator. &lt;/p&gt;
&lt;p&gt;generate rand value of type T: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;trait Generator[+T] { &lt;/span&gt;
&lt;span class="code-line"&gt;def generate: T&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;first implement Generator[Int], then use this to implement booleans, pairs, lists, sets, trees,......&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val integers = new Generator[Int]{&lt;/span&gt;
&lt;span class="code-line"&gt;    val rand = new java.util.Random&lt;/span&gt;
&lt;span class="code-line"&gt;    def generate = rand.nextInt()&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;val booleans = new Generator[Boolean{&lt;/span&gt;
&lt;span class="code-line"&gt;    def generate = integers.generate &amp;gt; 0&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;val pairs = new Generator[(Int, Int)]{&lt;/span&gt;
&lt;span class="code-line"&gt;    def generate = (integers.generate, integers.generate)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;→ can we avoid the &lt;code&gt;new Generator[...]&lt;/code&gt; ? &lt;/p&gt;
&lt;p&gt;&lt;em&gt;ideally we want to write booleans as pairs as:&lt;/em&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val booleans &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; x &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; integers &lt;span class="p"&gt;)&lt;/span&gt; yield x&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def pairs&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;U&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="kp"&gt;t&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; Generator&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;T&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; u&lt;span class="o"&gt;:&lt;/span&gt; Generator&lt;span class="p"&gt;[&lt;/span&gt;U&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;x &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; y &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; u&lt;span class="p"&gt;}&lt;/span&gt; yield &lt;span class="p"&gt;(&lt;/span&gt;x&lt;span class="p"&gt;,&lt;/span&gt;y&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the for expr will be translated to map/flatMap/filter... &lt;/p&gt;
&lt;p&gt;⇒ define map and flatMap on the Generator trait so that it supports for expr!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;trait Generator[+T]{&lt;/span&gt;
&lt;span class="code-line"&gt;    self =&amp;gt; // syntax: `self` is an alias of `this`&lt;/span&gt;
&lt;span class="code-line"&gt;    def generate: T&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    def map[S](f: T=&amp;gt;S): Generator[S] = &lt;/span&gt;
&lt;span class="code-line"&gt;        new Generator[S]{&lt;/span&gt;
&lt;span class="code-line"&gt;            def generate = f(self.generate) // can't use `this` here: inf loop&lt;/span&gt;
&lt;span class="code-line"&gt;            // or use Generator.this.generate&lt;/span&gt;
&lt;span class="code-line"&gt;        }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    def flatMap(f: T=&amp;gt;Generator[S]): Generator[S] = &lt;/span&gt;
&lt;span class="code-line"&gt;        new Generator[S]{   &lt;/span&gt;
&lt;span class="code-line"&gt;            def generate = f(self.generate).generate &lt;/span&gt;
&lt;span class="code-line"&gt;        }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ex. the booleans expression: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;val booleans = for (x&amp;lt;-integers) yield x&amp;gt;0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;is translated to: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;val booleans = integers map (x=&amp;gt;x&amp;gt;0)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;which is then expands to: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val booleans = &lt;/span&gt;
&lt;span class="code-line"&gt;new Generator[Boolean]{&lt;/span&gt;
&lt;span class="code-line"&gt;    val f = (x =&amp;gt; x&amp;gt;0)&lt;/span&gt;
&lt;span class="code-line"&gt;    def generate = f(integers.generate)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;after reduction, the expression is: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val booleans = new Generator[Boolean{&lt;/span&gt;
&lt;span class="code-line"&gt;    def generate = integers.generate &amp;gt; 0&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is the initial implementation... &lt;/p&gt;
&lt;h3 id="other-base-generators"&gt;other base Generators&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image017.png"/&gt;&lt;/p&gt;
&lt;p&gt;(The &lt;code&gt;T*&lt;/code&gt; syntax is variable parameter)&lt;/p&gt;
&lt;h3 id="rand-list-generator"&gt;rand List Generator&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def lists&lt;span class="o"&gt;:&lt;/span&gt; Generator&lt;span class="p"&gt;[&lt;/span&gt;List&lt;span class="p"&gt;[&lt;/span&gt;Int&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    isEmpty &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; booleans&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kt"&gt;list&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kr"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;isEmpty&lt;span class="p"&gt;)&lt;/span&gt; emptyLists &lt;span class="kr"&gt;else&lt;/span&gt; nonEmptyLists&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield &lt;span class="kt"&gt;list&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def emptyLists &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;single&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;Nil&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def nonEmptyLists &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    head &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; integers&lt;/span&gt;
&lt;span class="code-line"&gt;    tail &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; lists &lt;span class="o"&gt;//&lt;/span&gt; recursive call to &lt;span class="sb"&gt;`lists`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield &lt;span class="kp"&gt;head&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kp"&gt;tail&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="rand-binary-tree-generator"&gt;rand (binary) Tree Generator&lt;/h3&gt;
&lt;p&gt;two types of tree nodes: leaf or inner node&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def trees&lt;span class="o"&gt;:&lt;/span&gt; Generator&lt;span class="p"&gt;[&lt;/span&gt;Tree&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    isLeaf &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; booleans&lt;/span&gt;
&lt;span class="code-line"&gt;    tree &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;isLeaf&lt;span class="p"&gt;)&lt;/span&gt; leafs &lt;span class="kr"&gt;else&lt;/span&gt; inners&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield tree&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def leafs&lt;span class="o"&gt;:&lt;/span&gt; Generator&lt;span class="p"&gt;[&lt;/span&gt;Leaf&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    x &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; integers&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield Leaf&lt;span class="p"&gt;(&lt;/span&gt;x&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def inners&lt;span class="o"&gt;:&lt;/span&gt; Generator&lt;span class="p"&gt;[&lt;/span&gt;Inner&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    l &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; trees&lt;/span&gt;
&lt;span class="code-line"&gt;    r &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; trees&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield Inner&lt;span class="p"&gt;(&lt;/span&gt;l&lt;span class="p"&gt;,&lt;/span&gt; r&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="application-random-testing"&gt;Application: random testing&lt;/h2&gt;
&lt;p&gt;test: check &lt;em&gt;postconditions&lt;/em&gt; (expected results)&lt;/p&gt;
&lt;p&gt;→ generate random test inputs&lt;/p&gt;
&lt;p&gt;a generic wrapper:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def randTest[T](g: Generator[T], numTimes: Int=100)(testfcn: T=&amp;gt;Boolean): Unit = {&lt;/span&gt;
&lt;span class="code-line"&gt;    for( i &lt;span class="nt"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="err"&gt;0&lt;/span&gt; &lt;span class="err"&gt;until&lt;/span&gt; &lt;span class="err"&gt;numTimes){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="err"&gt;val&lt;/span&gt; &lt;span class="na"&gt;value:T =&lt;/span&gt; &lt;span class="s"&gt;g.generate&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="err"&gt;assert(testfcn(value),&lt;/span&gt; &lt;span class="err"&gt;"test&lt;/span&gt; &lt;span class="err"&gt;failed&lt;/span&gt; &lt;span class="err"&gt;for&lt;/span&gt; &lt;span class="err"&gt;"+value)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="err"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="err"&gt;println("passed"&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="err"&gt;numTime&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="err"&gt;"tests")&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="scalacheck"&gt;ScalaCheck&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;instead of writing tests, write properties that are assumed to hold.&lt;/em&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;forAll { &lt;/span&gt;
&lt;span class="code-line"&gt;    (l1:List[Int], l2:List[Int]) =&amp;gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        l1.size + l2.size == (l1++l2).size&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="14-monads"&gt;1.4 - Monads&lt;/h1&gt;
&lt;p&gt;from last section: not only collections, but also any type with map and flatmap can use for expr ⇒ monads. &lt;/p&gt;
&lt;p&gt;&lt;def&gt;. Monads is a type M[T] with 2 operations: &lt;code&gt;flatMap&lt;/code&gt; ("bind") and &lt;code&gt;unit&lt;/code&gt;, and satisfy some laws.&lt;/def&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;train M[T]{&lt;/span&gt;
&lt;span class="code-line"&gt;    def flatMap[U](f: T=&amp;gt;M[U]): M[U]): M[U]&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;def unit[T](x:T): M[T]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;examples: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt; is a monad, &lt;code&gt;unit(x) = List(x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&lt;/code&gt;, with &lt;code&gt;unit(x) = Set(x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Option&lt;/code&gt;, with &lt;code&gt;unit(x) = Some(x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Generator&lt;/code&gt;, with &lt;code&gt;unit(x) = single(x)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt; can be defined as a combination of &lt;code&gt;flatMap&lt;/code&gt; and &lt;code&gt;unit&lt;/code&gt;: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;m map f == m flatMap (x =&amp;gt; unit( f(x)) )&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="monad-laws"&gt;Monad laws&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;associativity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;(m flatMap f) flatMap g == m flatMap ( x =&amp;gt; f(x) flatMap g )&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;↔ (x+y+z) = x+(y+z)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;left unit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;unit(x) flatMap f == f(x)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;right unit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;m flatMap unit == m&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="the-try-type"&gt;the Try type&lt;/h2&gt;
&lt;p&gt;We define a Try class, which is similar to Option class. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;abstraxt class Try[+T]&lt;/span&gt;
&lt;span class="code-line"&gt;case class Success[T](x:T) extends Try[T]&lt;/span&gt;
&lt;span class="code-line"&gt;case class Failure(ex: Exception) extends Try[Nothing]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we can write &lt;code&gt;Try(expr)&lt;/code&gt; to give a computation a try, by implementing the &lt;code&gt;apply&lt;/code&gt; method of object Try:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;object Try{&lt;/span&gt;
&lt;span class="code-line"&gt;def apply[T](expr: =&amp;gt;T): Try[T]= // expr is passed BY NAME, otherwise will cause exception in eval&lt;/span&gt;
&lt;span class="code-line"&gt;    try Success(expr) // java syntax of try-catch&lt;/span&gt;
&lt;span class="code-line"&gt;    catch{ case NonFatal(ex) =&amp;gt; Failure(ex) }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;if Try is a Monad ⇒ can be written in for expr: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image018.png"/&gt;&lt;/p&gt;
&lt;p&gt;⇒ define map and flatMap on &lt;code&gt;Try&lt;/code&gt; type. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun2_lec1_forexpr/pasted_image019.png"/&gt;&lt;/p&gt;
&lt;p&gt;question: is Try a monad with &lt;code&gt;unit(x)=Try(x)&lt;/code&gt;?
⇒ no, left-unit fails: &lt;code&gt;Try(expr) flatMap f != f(expr)&lt;/code&gt;
(lhs never nonfatal exception, but rhs will raise)&lt;/p&gt;
&lt;p&gt;Try is not a monad, but it can still use for expr...&lt;/p&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;for exprs are useful not only for collections: &lt;code&gt;Generator&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt;, &lt;code&gt;Try&lt;/code&gt;&lt;/p&gt;</summary><category term="scala"></category></entry><entry><title>[Scala MOOC I] Lec6: Collections</title><link href="http://x-wei.github.io/progfun1_lec6_collections.html" rel="alternate"></link><published>2016-07-30T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-07-30:progfun1_lec6_collections.html</id><summary type="html">
&lt;h1 id="61-other-collections"&gt;6.1 - Other Collections&lt;/h1&gt;
&lt;p&gt;so far: only seen List. → more (&lt;strong&gt;immutable&lt;/strong&gt;) collections. &lt;/p&gt;
&lt;h3 id="vector"&gt;vector&lt;/h3&gt;
&lt;p&gt;List:  is linear -- access to head is faster than middle or end element. 
Vector: better rand access performance. &lt;/p&gt;
&lt;p&gt;represented as very shallow trees(32-split at each node)&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec6_collections/pasted_image.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt; support similar operations as List (head, tail,map, fold) , except concat &lt;code&gt;::&lt;/code&gt;, instead Vectors have &lt;code&gt;+:&lt;/code&gt; and &lt;code&gt;:+&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x +: xs&lt;/code&gt; create new vector with x in head&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs :+ x&lt;/code&gt; create new vector with x in tail&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;implementation of &lt;code&gt;:+&lt;/code&gt;: create copies&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec6_collections/pasted_image002.png"/&gt;&lt;/p&gt;
&lt;h3 id="seq"&gt;Seq&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Seq&lt;/code&gt; is base class for &lt;code&gt;Vector&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Seq&lt;/code&gt; itself is subclass of &lt;code&gt;Iterable&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Hierarchy of Iterables: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec6_collections/pasted_image005.png"/&gt;&lt;/p&gt;
&lt;h3 id="array-ans-string"&gt;Array ans String&lt;/h3&gt;
&lt;p&gt;Array and String support same op as Seq, can implicitly be converted to seq when needed. But they are NOT subclasses of Seq as they come from java. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;scala&amp;gt; val xs: Array[Int] = Array(1,2,3)&lt;/span&gt;
&lt;span class="code-line"&gt;xs: Array[Int] = Array(1, 2, 3)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; xs map (2*_)&lt;/span&gt;
&lt;span class="code-line"&gt;res3: Array[Int] = Array(2, 4, 6)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; val ys = "Hello"&lt;/span&gt;
&lt;span class="code-line"&gt;ys: String = Hello&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; ys filter (_.isUpper)&lt;/span&gt;
&lt;span class="code-line"&gt;res4: String = H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="range"&gt;Range&lt;/h3&gt;
&lt;p&gt;represents a seq of evenly spaced integers.&lt;/p&gt;
&lt;p&gt;represented as an obj with 3 values: lower bound, upper bound, step value. &lt;/p&gt;
&lt;p&gt;3 op: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;to&lt;/code&gt;: inclusive &lt;/li&gt;
&lt;li&gt;&lt;code&gt;until&lt;/code&gt;: exclusive&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;by&lt;/code&gt;: step value&lt;/p&gt;
&lt;p&gt;1 to 6       // 1 2 3 4 5 6
1 until 6    // 1 2 3 4 5
1 to 6 by 2  // 1 3 5
6 to 1 by -2 // 6 4 2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="more-ops-on-seq"&gt;More ops on Seq&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xs exists p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs forall p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xs zip ys&lt;/code&gt;: takes 2 seq, returns a single seq, each elem is a pair&lt;/p&gt;
&lt;p&gt;scala&amp;gt; List(1,2,3) zip Vector(2,3,4)
res7: List[(Int, Int)] = List((1,2), (2,3), (3,4))&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xs.unzip&lt;/code&gt;: reverse zip, return 2 lists &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xs flatMap f&lt;/code&gt;: apply f to all elements, and &lt;strong&gt;concat the results&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;scala&amp;gt; "hello" flatMap (c =&amp;gt; List('.', c))
res9: String = .h.e.l.l.o&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;flatten&lt;/code&gt;: flatten a seq of seq into just one seq...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;xs flatMap f = (xs map f).flatten&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The result is concated, instead of being a list of list. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xs.sum&lt;/code&gt;/&lt;code&gt;xs.product&lt;/code&gt;: for numeric collection&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.max&lt;/code&gt;/&lt;code&gt;xs.min&lt;/code&gt;: an ordering must exist&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="examples"&gt;Examples&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;cartesen product: 1..M x 1..N:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;(1 to M) flatMap( x =&amp;gt; (1 to N) map (y =&amp;gt; (x,y)) )&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scalar of 2 vectors&lt;/p&gt;
&lt;p&gt;def scalaProd(xs: Vector[Double], ys: Vector[Double]): Double = 
  (xs zip ys) map (xy =&amp;gt; xy._1 * xy._2).sum&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;alternative: use pattern matching in map (need to add braces &lt;code&gt;{}&lt;/code&gt;!): &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;(xs zip ys) map ( {case(x,y) =&amp;gt; x*y}).sum&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;test isPrime for a number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;def isPrime(n: Int): Boolean = (2 until n) forall (d =&amp;gt; n%d!=0)&lt;/code&gt;&lt;/p&gt;
&lt;h1 id="62-combinatorial-search-and-for-expressions"&gt;6.2 - Combinatorial Search and For-Expressions&lt;/h1&gt;
&lt;p&gt;goal: handle nested seq. &lt;/p&gt;
&lt;p&gt;⇒ extend usage of higher order functions instead of using nested loops. &lt;/p&gt;
&lt;p&gt;example:   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;given n, find all (i,j) st: 1&amp;lt;=j&amp;lt;i&amp;lt;=n, and i+j is prime.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(1 until n) flatMap ( i =&amp;gt; (1 until i) map (j =&amp;gt; (i,j)) ) filter ( {case(i,j) =&amp;gt; isPrime(i+j)})&lt;/p&gt;
&lt;p&gt;this works, but less understandable... ⇒ for expressions. &lt;/p&gt;
&lt;h3 id="foryield-expressions"&gt;for/yield expressions&lt;/h3&gt;
&lt;p&gt;example: class of person&lt;/p&gt;
&lt;p&gt;&lt;code&gt;case class Person(name: String, age: Int)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;To obtain names of persons over 20 years old: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;persons filter (_.age&amp;gt;20) map (_.name)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;equivalent to :&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for (p &amp;lt;- person if p.age &amp;gt; 20) yield p.name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The for expression is similar to jave for-loop, except &lt;strong&gt;it builds a list of the results of all iterations&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;for expression form: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;for( s ) yield e&lt;/code&gt;
where &lt;code&gt;s&lt;/code&gt; can contain &lt;strong&gt;generators&lt;/strong&gt; and &lt;strong&gt;filters&lt;/strong&gt;: &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;generator: &lt;code&gt;p&amp;lt;-e&lt;/code&gt; where &lt;code&gt;e&lt;/code&gt; is a collection, &lt;code&gt;p&lt;/code&gt; is a pattern&lt;/li&gt;
&lt;li&gt;filter: &lt;code&gt;if f&lt;/code&gt; where t is boolean expr&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;rewrite the prime sum example: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  i &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; until n&lt;/span&gt;
&lt;span class="code-line"&gt;  j &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; until i&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="kr"&gt;if&lt;/span&gt; isPrime&lt;span class="p"&gt;(&lt;/span&gt;i&lt;span class="o"&gt;+&lt;/span&gt;j&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt; yield &lt;span class="p"&gt;(&lt;/span&gt;i&lt;span class="p"&gt;,&lt;/span&gt;j&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;exercice: write the scalaProd using for expr: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def scalaProd&lt;span class="p"&gt;(&lt;/span&gt;xs&lt;span class="o"&gt;:&lt;/span&gt; Vector&lt;span class="p"&gt;[&lt;/span&gt;Double&lt;span class="p"&gt;],&lt;/span&gt; ys&lt;span class="o"&gt;:&lt;/span&gt; Vector&lt;span class="p"&gt;[&lt;/span&gt;Double&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; Double &lt;span class="o"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;x&lt;span class="p"&gt;,&lt;/span&gt;y&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; xs zip ys &lt;span class="p"&gt;)&lt;/span&gt; yield x&lt;span class="o"&gt;*&lt;/span&gt;y &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kp"&gt;sum&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;more on scala for expr: 
&lt;a href="http://www.artima.com/pins1ed/for-expressions-revisited.html"&gt;http://www.artima.com/pins1ed/for-expressions-revisited.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="63-combinatorial-search-example"&gt;6.3 - Combinatorial Search Example&lt;/h1&gt;
&lt;p&gt;goal: combine &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt;-expr to solve the n-queens problem. &lt;/p&gt;
&lt;h3 id="sets"&gt;Sets&lt;/h3&gt;
&lt;p&gt;3 fundamental iterable collection types: seq, &lt;strong&gt;set&lt;/strong&gt;, map. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set support most operations on seq (c.f. doc on Iterable)&lt;/li&gt;
&lt;li&gt;sets are unordered&lt;/li&gt;
&lt;li&gt;set don't have dup elements&lt;/li&gt;
&lt;li&gt;contains: &lt;code&gt;s contains e&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="example-n-queens"&gt;Example: N-Queens&lt;/h3&gt;
&lt;p&gt;8*8 chess board, 8 queens 
⇒ places queens st: no two queen in same row/col/diag&lt;/p&gt;
&lt;p&gt;algo: put one queen in each row (in the right column) &lt;/p&gt;
&lt;p&gt;recursive solution: suppose already have solutions for first n-1 rows. 
represent each (partial)solution as a list of column index. &lt;/p&gt;
&lt;p&gt;return all possible solutions (as a Set). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def queens(n: Int): Set[List[Int]] = {&lt;/span&gt;
&lt;span class="code-line"&gt;    def placeQueens(k: Int): Set[List[Int]] = ???// place first k rows&lt;/span&gt;
&lt;span class="code-line"&gt;    placeQueens(n)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fill in the helper function: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def placeQueens&lt;span class="p"&gt;(&lt;/span&gt;k&lt;span class="o"&gt;:&lt;/span&gt; Int&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; Set&lt;span class="p"&gt;[&lt;/span&gt;List&lt;span class="p"&gt;[&lt;/span&gt;Int&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kr"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;k&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; Set&lt;span class="p"&gt;(&lt;/span&gt;List&lt;span class="p"&gt;())&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kr"&gt;else&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        queens &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; placeQueens&lt;span class="p"&gt;(&lt;/span&gt;k&lt;span class="m"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; queens&lt;span class="p"&gt;(&lt;/span&gt;List&lt;span class="p"&gt;[&lt;/span&gt;Int&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; one solution to k&lt;span class="m"&gt;-1&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="kt"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; until n&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="kr"&gt;if&lt;/span&gt; isSafe&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; queens&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="kr"&gt;if&lt;/span&gt; column &lt;span class="kt"&gt;c&lt;/span&gt; doesn&lt;span class="s"&gt;'&lt;/span&gt;&lt;span class="err"&gt;t conflict with the partial solution queens&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt; yield &lt;span class="kt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;queens &lt;span class="o"&gt;//&lt;/span&gt; the kth row solution is &lt;span class="kr"&gt;in&lt;/span&gt; head of &lt;span class="kt"&gt;list&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now fill in the function isSafe that check if a column is valid wrt queens for above rows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def isSafe(col: Int, queens: List[Int]): Boolean = {&lt;/span&gt;
&lt;span class="code-line"&gt;    val k = queens.length // current row is k&lt;/span&gt;
&lt;span class="code-line"&gt;    val indexedQueens = (k-1 to 0 by -1) zip queens // List[(row, col)]&lt;/span&gt;
&lt;span class="code-line"&gt;    indexedQueens forall { &lt;/span&gt;
&lt;span class="code-line"&gt;            case(r,c) =&amp;gt; c!=col &amp;amp;&amp;amp; k-r!=math.abs(c-col) }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now the queens function will work. &lt;/p&gt;
&lt;p&gt;Write another function to print the solution out: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def show&lt;span class="p"&gt;(&lt;/span&gt;queens&lt;span class="o"&gt;:&lt;/span&gt; List&lt;span class="p"&gt;[&lt;/span&gt;Int&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; String &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    val lines &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;col &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; queens.reverse&lt;span class="p"&gt;)&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;                yield Vector.fill&lt;span class="p"&gt;(&lt;/span&gt;queens.length&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"* "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="m"&gt;.&lt;/span&gt;updated&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;col&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"X "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="m"&gt;.&lt;/span&gt;mkString&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="s"&gt;"\n"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; lines.mkString&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;(&lt;/span&gt;queens&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; map show&lt;span class="p"&gt;)&lt;/span&gt; mkString &lt;span class="s"&gt;"====\n"&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="64-maps"&gt;6.4 - Maps&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Map[Key, Value]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ex: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val romanNumerals = Map("I" -&amp;gt;1, "V" -&amp;gt;5, "X" -&amp;gt; 10)&lt;/span&gt;
&lt;span class="code-line"&gt;val captial = Map("France" -&amp;gt; "Paris", "US" -&amp;gt; "Washington")&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Maps are iterables and &lt;strong&gt;functions&lt;/strong&gt;: maps Key to Value like a function call &lt;/p&gt;
&lt;p&gt;ex. &lt;code&gt;romanNumerals("I")&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;will throw &lt;code&gt;NoSuchElementException&lt;/code&gt; if the key is not in map. &lt;/p&gt;
&lt;p&gt;⇒ use &lt;code&gt;get&lt;/code&gt;: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;scala&amp;gt; captial("France")&lt;/span&gt;
&lt;span class="code-line"&gt;res3: String = Paris&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; captial get "France"&lt;/span&gt;
&lt;span class="code-line"&gt;res4: Option[String] = Some(Paris)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; captial get "China"&lt;/span&gt;
&lt;span class="code-line"&gt;res5: Option[String] = None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;have a look at the Option type:&lt;/p&gt;
&lt;h3 id="the-option-type"&gt;The Option Type&lt;/h3&gt;
&lt;p&gt;definition: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;trait Option[+A]&lt;/span&gt;
&lt;span class="code-line"&gt;case class Some[+A](value: A] extends Option[A]&lt;/span&gt;
&lt;span class="code-line"&gt;object None extends Option[Nothing]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;so the get function of map gives: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;None&lt;/code&gt; if key is not in map&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Some(x)&lt;/code&gt; if map associates key to x&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;since &lt;code&gt;Some&lt;/code&gt; is case class, can use pattern matching to decompose. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def showCaptical(country: String) = captial.get(country) match{&lt;/span&gt;
&lt;span class="code-line"&gt;    case Some(cap) =&amp;gt; cap&lt;/span&gt;
&lt;span class="code-line"&gt;    case None =&amp;gt; "missing data"&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="sorted-and-groupby"&gt;Sorted and GroupBy&lt;/h3&gt;
&lt;p&gt;two useful SQL queries. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;orderBy can be expressed using sortWith and sorted: &lt;/p&gt;
&lt;p&gt;val fruit = List("apple", "pear", "orange", "pineapple")
scala&amp;gt; fruit sortWith (&lt;em&gt;.length &amp;lt; &lt;/em&gt;.length)
res7: List[String] = List(pear, apple, orange, pineapple)
scala&amp;gt; fruit.sorted
res8: List[String] = List(apple, orange, pear, pineapple)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;GroupBy(f)&lt;/code&gt;: &lt;strong&gt;partition a collection into a map of collections&lt;/strong&gt; according to &lt;code&gt;f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; fruit groupBy (_.head)
res9: scala.collection.immutable.Map[Char,List[String]] = 
        Map(p -&amp;gt; List(pear, pineapple), 
            a -&amp;gt; List(apple), 
            o -&amp;gt; List(orange))&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="map-example-polynomials"&gt;map Example: polynomials&lt;/h3&gt;
&lt;p&gt;can be seen as map from exponents to coefficients:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec6_collections/pasted_image006.png"/&gt;&lt;/p&gt;
&lt;p&gt;⇒ represent polynm as maps&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;class Poly(val terms: Map[Int, Double]) {&lt;/span&gt;
&lt;span class="code-line"&gt;    def + (other: Poly) = new Poly(terms ++ // ++ on maps: will override older entries in terms!&lt;/span&gt;
&lt;span class="code-line"&gt;                            (other.terms maps adjust)) // adjust defined below&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    def adjust(term: (Int, Double)):(Int, Double) = {&lt;/span&gt;
&lt;span class="code-line"&gt;        val (exp, coeff) = term&lt;/span&gt;
&lt;span class="code-line"&gt;        terms get exp match{&lt;/span&gt;
&lt;span class="code-line"&gt;            case None =&amp;gt; Pair(exp, coeff) // or write: exp -&amp;gt; coeff&lt;/span&gt;
&lt;span class="code-line"&gt;            case Some(coeff1) =&amp;gt; Pair(exp, coeff+coeff1)&lt;/span&gt;
&lt;span class="code-line"&gt;        }&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;    override def toString = &lt;/span&gt;
&lt;span class="code-line"&gt;    (for( (exp, coeff) &lt;span class="nt"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="err"&gt;terms.toList.sorted.reverse)&lt;/span&gt; &lt;span class="err"&gt;yield&lt;/span&gt; &lt;span class="err"&gt;coeff+"x^"+exp)&lt;/span&gt; &lt;span class="err"&gt;mkString&lt;/span&gt; &lt;span class="err"&gt;"+&lt;/span&gt; &lt;span class="err"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="default-values"&gt;default values&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;withDefulatValue&lt;/code&gt;: makes a map into a &lt;strong&gt;total map&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rewrite the poly example: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;class Poly&lt;span class="p"&gt;(&lt;/span&gt;terms0&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kp"&gt;Map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;Int&lt;span class="p"&gt;,&lt;/span&gt; Double&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    val terms &lt;span class="o"&gt;=&lt;/span&gt; terms0 withDefaultValue &lt;span class="m"&gt;0.0&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    def &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;other&lt;span class="o"&gt;:&lt;/span&gt; Poly&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; new Poly&lt;span class="p"&gt;(&lt;/span&gt;terms &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; on maps&lt;span class="o"&gt;:&lt;/span&gt; will override older entries &lt;span class="kr"&gt;in&lt;/span&gt; terms&lt;span class="o"&gt;!&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;                            &lt;span class="p"&gt;(&lt;/span&gt;other.terms maps adjust&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; adjust defined below&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    def adjust&lt;span class="p"&gt;(&lt;/span&gt;term&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;Int&lt;span class="p"&gt;,&lt;/span&gt; Double&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;Int&lt;span class="p"&gt;,&lt;/span&gt; Double&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        val &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; coeff&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; term&lt;/span&gt;
&lt;span class="code-line"&gt;        exp &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;coeff &lt;span class="o"&gt;+&lt;/span&gt; terms&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    override def toString &lt;span class="o"&gt;=&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; coeff&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; terms.toList.sorted.reverse&lt;span class="p"&gt;)&lt;/span&gt; yield coeff&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;"x^"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="kp"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; mkString &lt;span class="s"&gt;"+ "&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;change to variable parameter for better constructor calling: add another constructor&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def this(bindings: (int, Double)*) = // bindings is s sequence&lt;/span&gt;
&lt;span class="code-line"&gt;this(bindings.toMap)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Exercie: re-implement the &lt;code&gt;+&lt;/code&gt; using foldLeft : &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def + (other: Poly) =&lt;/span&gt;
&lt;span class="code-line"&gt;    new Poly( (other.terms foldLeft terms)(addTerm) )&lt;/span&gt;
&lt;span class="code-line"&gt;def addTerm(terms:Map[Int, Double], term: (Int, Double)): Map[Int, Double] = {&lt;/span&gt;
&lt;span class="code-line"&gt;    val (exp, coeff) = term&lt;/span&gt;
&lt;span class="code-line"&gt;    terms + ( exp -&amp;gt; (coeff + terms(exp)) ) // map + (k,v) updates the map&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="65-putting-the-pieces-together-t9-keyboard-mnem"&gt;6.5 - Putting the Pieces Together: T9 keyboard mnem&lt;/h1&gt;
&lt;p&gt;convert a seq of numbers to a scentence&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val mnem  = Map('2'-&amp;gt;"ABC", '3'-&amp;gt;"DEF", 4-&amp;gt;"GHI", '5'-&amp;gt;"JKL",&lt;/span&gt;
&lt;span class="code-line"&gt;            '6'-&amp;gt;"MNO", '7'-&amp;gt;"PQRS", '8'-&amp;gt;"TUV", '9'-&amp;gt;"WXYZ" )&lt;/span&gt;
&lt;span class="code-line"&gt;val in = Source.fromURL("...")&lt;/span&gt;
&lt;span class="code-line"&gt;val words = in.getLines.toList // dictionary: list of valid words&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;goal: design a &lt;code&gt;translate(phoneNumber)&lt;/code&gt; that produces all phrases of words that can serve as mnemonics(助忆) for a phone number. &lt;/p&gt;
&lt;p&gt;Step 1: invert the mnem map to a map from A~Z to 2~9: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val charCode: Map[Char, Char] = &lt;/span&gt;
&lt;span class="code-line"&gt;for ( (digit, str) &lt;span class="nt"&gt;&amp;lt;-mnem&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt; &lt;span class="err"&gt;ltr&amp;lt;-str)&lt;/span&gt; &lt;span class="err"&gt;yield&lt;/span&gt; &lt;span class="err"&gt;ltr-&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;digit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step 2: map a word to the string it represents, ex. "java"-&amp;gt;"5282"&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def wordCode(word: String):String = &lt;/span&gt;
&lt;span class="code-line"&gt;    word.toUpperCase map charCode&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step 3: maps from digit string to all possible valid strings, ex. "5282"-&amp;gt;List("java", "kata",...)
⇒ just a groupby!!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val wordsForNum: Map[String, Seq[String]] = &lt;/span&gt;
&lt;span class="code-line"&gt;    words groupBy wordCode&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;→ Error: key not found: "-", some words contains a "-"... → drop such words... &lt;/p&gt;
&lt;p&gt;&lt;code&gt;val words = in.getLines.toList filter (wd =&amp;gt; wd forall (ch =&amp;gt; ch.isLetter))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Step 4: return all ways to encode a number as a list of words →  recursive, recurse on the nb of first words~&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def encode&lt;span class="p"&gt;(&lt;/span&gt;number&lt;span class="o"&gt;:&lt;/span&gt; String&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; Set&lt;span class="p"&gt;[&lt;/span&gt;List&lt;span class="p"&gt;[&lt;/span&gt;String&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;number.isEmpty&lt;span class="p"&gt;)&lt;/span&gt; Set&lt;span class="p"&gt;(&lt;/span&gt;List&lt;span class="p"&gt;())&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="kp"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;        val phraseList &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;            split &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; to number.length &lt;span class="o"&gt;//&lt;/span&gt; the first word &lt;span class="kr"&gt;in&lt;/span&gt; phrase uses numbers&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="kp"&gt;split&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            firstWd &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; wordsForNum&lt;span class="p"&gt;[&lt;/span&gt; number.take&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;split&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            followingWds &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; encode&lt;span class="p"&gt;(&lt;/span&gt;number.drop&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;split&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="p"&gt;}&lt;/span&gt; yield firstWd&lt;span class="o"&gt;::&lt;/span&gt;follwingWds&lt;/span&gt;
&lt;span class="code-line"&gt;        phraseList.toSet&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ error in the line with &lt;code&gt;wordsForNum&lt;/code&gt;: key not found... 
⇒ &lt;code&gt;wordsForNum["7"]&lt;/code&gt; will give error 
⇒ make the &lt;code&gt;wordsForNum&lt;/code&gt; a total map, using withDefaultValue&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val wordsForNum: Map[String, Seq[String]] = &lt;/span&gt;
&lt;span class="code-line"&gt;    (words groupBy wordCode) withDefaultValue( Seq() )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step 5: return strings (instead of List[String])&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def translate(number: String): Set[String] = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    encode(number) map (_.mkString(" "))&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;summary: 
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec6_collections/pasted_image007.png"/&gt;&lt;/p&gt;
&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec6_collections/pasted_image009.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.scala-exercises.org/"&gt;https://www.scala-exercises.org/&lt;/a&gt;&lt;/p&gt;</summary><category term="scala"></category></entry><entry><title>[Scala MOOC I] Lec5: Lists</title><link href="http://x-wei.github.io/progfun1_lec5_lists.html" rel="alternate"></link><published>2016-07-29T21:30:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-07-29:progfun1_lec5_lists.html</id><summary type="html">
&lt;h1 id="51-more-functions-on-lists"&gt;5.1 - More Functions on Lists&lt;/h1&gt;
&lt;p&gt;already known methods: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;xs.head&lt;/span&gt;
&lt;span class="code-line"&gt;xs.tail&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sublist and ele access: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xs.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.last&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.init&lt;/code&gt;: all elementh except last element&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.take(n)&lt;/code&gt;: sublist of first n elements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.drop(n)&lt;/code&gt;: the rest of list after taking first n elements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs(n)&lt;/code&gt;: = &lt;code&gt;xs.apply(n)&lt;/code&gt; , element at index n&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;More methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;concatenation: &lt;code&gt;xs ++ ys&lt;/code&gt; (&lt;code&gt;:::&lt;/code&gt; is legacy usage)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.reverse&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.updated(n,x)&lt;/code&gt;: return a same list, except xs(n)=x (Note: Lists are immutable, so cannot modify)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.indexOf(x)&lt;/code&gt;: index or -1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xs.contains(x)&lt;/code&gt;: same as &lt;code&gt;xs.indexOf(x)&amp;gt;=0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;complexity: 
head, tail: simple to implement
⇒ complexity of &lt;code&gt;last&lt;/code&gt;?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def last[T](xs: List[T]): T = xs match{&lt;/span&gt;
&lt;span class="code-line"&gt;    case List() =&amp;gt; throw new Error("last of Nil")&lt;/span&gt;
&lt;span class="code-line"&gt;    case List(x) =&amp;gt; x&lt;/span&gt;
&lt;span class="code-line"&gt;    case y::ys =&amp;gt; last(ys)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ complexity of last = O(n)&lt;/p&gt;
&lt;p&gt;implement &lt;code&gt;init&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def init[T](xs: List[T]): T = xs match{&lt;/span&gt;
&lt;span class="code-line"&gt;    case List() =&amp;gt; throw new Error("init of Nil")&lt;/span&gt;
&lt;span class="code-line"&gt;    case List(x) =&amp;gt; List()&lt;/span&gt;
&lt;span class="code-line"&gt;    case y::ys =&amp;gt; y::init(ys)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ complexity = O(length of xs)&lt;/p&gt;
&lt;p&gt;implement concatenation &lt;code&gt;:::&lt;/code&gt;/&lt;code&gt;++&lt;/code&gt;
(NB: &lt;code&gt;:::&lt;/code&gt; is right-associative, &lt;code&gt;xs:::ys&lt;/code&gt; = &lt;code&gt;ys. :::(xs)&lt;/code&gt;. )&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def concat[T](xs: List[T], ys: List[T]) = xs match{&lt;/span&gt;
&lt;span class="code-line"&gt;    case List() =&amp;gt; ys&lt;/span&gt;
&lt;span class="code-line"&gt;    case z::zs =&amp;gt; x:concat(xs, ys)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ complexity of concat = O(length of xs)&lt;/p&gt;
&lt;p&gt;implement of reverse&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def reverse[T](xs: List[T]) = xs match{&lt;/span&gt;
&lt;span class="code-line"&gt;    case List() =&amp;gt; List()&lt;/span&gt;
&lt;span class="code-line"&gt;    case y::ys =&amp;gt; reverse(ys) ++ y&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ complexity of reverse: every call contains a concat, thus complexity=O(n2)&lt;/p&gt;
&lt;p&gt;exercice: remove nth element: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def removeAt[T](n:Int, xs: List[T]): List[T] = &lt;/span&gt;
&lt;span class="code-line"&gt;(xs take n ) ++ (xs drop n+1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="52-pairs-and-tuples"&gt;5.2 - Pairs and Tuples&lt;/h1&gt;
&lt;p&gt;example: sort list faster than insertion sort → merge sort. &lt;/p&gt;
&lt;p&gt;sort 2 sublist, merge them ⇒ list is sorted&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def msort(xs: List[Int]): List[Int] = {&lt;/span&gt;
&lt;span class="code-line"&gt;    val n = xs.length/2&lt;/span&gt;
&lt;span class="code-line"&gt;    if(n==0) xs&lt;/span&gt;
&lt;span class="code-line"&gt;    else{&lt;/span&gt;
&lt;span class="code-line"&gt;        def merge(xs: List[Int], ys: List[Int]) = ... // see below&lt;/span&gt;
&lt;span class="code-line"&gt;        val (fst, snd) = x splitAt n // splitAt returns 2 sublists&lt;/span&gt;
&lt;span class="code-line"&gt;        merge(msort(fst), msort(snd))&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;merge: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def merge(xs: List[Int], ys: List[Int]): List[Int] = xs match {&lt;/span&gt;
&lt;span class="code-line"&gt;    case Nil =&amp;gt; ys&lt;/span&gt;
&lt;span class="code-line"&gt;    case x::zs =&amp;gt; match ys{&lt;/span&gt;
&lt;span class="code-line"&gt;        case Nil =&amp;gt; xs&lt;/span&gt;
&lt;span class="code-line"&gt;        case y::ws =&amp;gt; {&lt;/span&gt;
&lt;span class="code-line"&gt;            if(x&amp;lt;y) x::merge(zs, ys)&lt;/span&gt;
&lt;span class="code-line"&gt;            else y::merge(xs, ws)&lt;/span&gt;
&lt;span class="code-line"&gt;        }&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="pairtuple"&gt;Pair/Tuple&lt;/h3&gt;
&lt;p&gt;written as &lt;code&gt;(x, y)&lt;/code&gt; in scala. pair can be used as patterns :  similar for tuples. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val pair = ("a", 2)&lt;/span&gt;
&lt;span class="code-line"&gt;val (label, value) = pair&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image.png"/&gt;&lt;/p&gt;
&lt;p&gt;tuple implementation: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image001.png"/&gt;&lt;/p&gt;
&lt;p&gt;⇒ can use &lt;code&gt;_1&lt;/code&gt; &lt;code&gt;_2&lt;/code&gt; to access elements&lt;/p&gt;
&lt;p&gt;exercice: rewrite the merge function using a &lt;em&gt;pattern matching over pairs&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def merge(xs: List[Int], ys: List[Int]): List[Int] =&lt;/span&gt;
&lt;span class="code-line"&gt;(xs, ys) match {&lt;/span&gt;
&lt;span class="code-line"&gt;    case (Nil, ys) =&amp;gt; ys&lt;/span&gt;
&lt;span class="code-line"&gt;    case (xs, Nil) =&amp;gt; xs&lt;/span&gt;
&lt;span class="code-line"&gt;    case (x:zs, y:ws) =&amp;gt; &lt;/span&gt;
&lt;span class="code-line"&gt;        if(x&amp;lt;y) x::merge(zs, ys)&lt;/span&gt;
&lt;span class="code-line"&gt;        else y::merge(xs, ws)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="53-implicit-parameters"&gt;5.3 - Implicit Parameters&lt;/h1&gt;
&lt;p&gt;pb: how to apply msort to list of other element types. &lt;/p&gt;
&lt;p&gt;using type parameters ? &lt;code&gt;msort[T]&lt;/code&gt;⇒ the compare operator is not always defined ! &lt;/p&gt;
&lt;p&gt;⇒ &lt;em&gt;pass the lt function as a parameter&lt;/em&gt;: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;def msort[T](xs: List[T])(lt: (T,T)=&amp;gt;Boolean) = ...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;another option: &lt;code&gt;scala.math.Ordering[T]&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;impor math.Ordering&lt;/span&gt;
&lt;span class="code-line"&gt;def msort[T](xs: List[T])(ord: Ordering) = ...// use ord.lt(x,y)&lt;/span&gt;
&lt;span class="code-line"&gt;msort(nums)(Ordering.Int)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pb: pass each time the function parameter is cumbersome... ⇒ use &lt;strong&gt;implicite&lt;/strong&gt; parameters&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def msort[T](xs: List[T])(implicite ord: Ordering) = ...// use ord.lt(x,y)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⇒ the function calls can ignore the implicite parameter, the compiler will figure it out. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image002.png"/&gt;&lt;/p&gt;
&lt;h1 id="54-higher-order-list-functions"&gt;5.4 - Higher-Order List Functions&lt;/h1&gt;
&lt;p&gt;functions over list have similar pattern: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;transform each element &lt;/li&gt;
&lt;li&gt;retrive elements that satisfy some cretirion&lt;/li&gt;
&lt;li&gt;combing elements using an operator&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="map"&gt;map&lt;/h3&gt;
&lt;p&gt;apply an operation to every elements. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;abstract class List[T]{&lt;/span&gt;
&lt;span class="code-line"&gt;    def map[U](f: T=&amp;gt;U): List[U] = this match {&lt;/span&gt;
&lt;span class="code-line"&gt;        case Nil =&amp;gt; this&lt;/span&gt;
&lt;span class="code-line"&gt;        case x:xs =&amp;gt; f(x)::xs.map(f)&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="filtering"&gt;filtering&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def filter(p: T=&amp;gt;Boolean): List[T] = this match {&lt;/span&gt;
&lt;span class="code-line"&gt;    case Nil =&amp;gt; this&lt;/span&gt;
&lt;span class="code-line"&gt;    case x:xs =&amp;gt; f(p(x)) x::xs.filter(p) else xs.filter(p)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;other methods that extracts sublist: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image003.png"/&gt;&lt;/p&gt;
&lt;p&gt;exercice: implement a function &lt;code&gt;pack&lt;/code&gt;: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image004.png"/&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def pack[T](xs: List[T]): List[List[T]] = xs match {&lt;/span&gt;
&lt;span class="code-line"&gt;    case Nil =&amp;gt; Nil&lt;/span&gt;
&lt;span class="code-line"&gt;    case x::ys =&amp;gt; {&lt;/span&gt;
&lt;span class="code-line"&gt;        val (head, tail) = xs span (c =&amp;gt; c==x)&lt;/span&gt;
&lt;span class="code-line"&gt;        head :: pack(tail)&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;exercice2: implement  a function &lt;code&gt;encode&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image005.png"/&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def encode[T](xs: List[T]): List[(T, Int)] = xs match {&lt;/span&gt;
&lt;span class="code-line"&gt;    case Nil =&amp;gt; Nil&lt;/span&gt;
&lt;span class="code-line"&gt;    case x::ys =&amp;gt; {&lt;/span&gt;
&lt;span class="code-line"&gt;        val (head, tail) = xs span (c =&amp;gt; c==x)&lt;/span&gt;
&lt;span class="code-line"&gt;        (x, head.length) :: pack(tail)&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;another version: use the pack: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def encode[T](xs: List[T]): List[(T, Int)] = &lt;/span&gt;
&lt;span class="code-line"&gt;    pack(xs) map (l =&amp;gt; (l.head, l.length))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="55-reduction-of-lists"&gt;5.5 - Reduction of Lists&lt;/h1&gt;
&lt;p&gt;fold/reduce: combine elements using an operator. &lt;/p&gt;
&lt;h3 id="reduceleft"&gt;reduceLeft&lt;/h3&gt;
&lt;p&gt;(can apply only to non-empty lists) 
inserts a binary operator between adj elements: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image006.png"/&gt;&lt;/p&gt;
&lt;p&gt;ex. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum(xs: List[Int]) = (0::xs) reduceLeft ( (x,y)=&amp;gt; x+y)&lt;/span&gt;
&lt;span class="code-line"&gt;def prod(xs: List[Int]) = (1::xs) reduceLeft ( (x,y)=&amp;gt; x*y)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;write shorter function values using underscore &lt;code&gt;_&lt;/code&gt;:  every &lt;code&gt;_&lt;/code&gt; represents a new parameter&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum(xs: List[Int]) = (0::xs) reduceLeft ( _+_ )&lt;/span&gt;
&lt;span class="code-line"&gt;def prod(xs: List[Int]) = (1::xs) reduceLeft ( _*_ )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="foldleft"&gt;foldLeft&lt;/h3&gt;
&lt;p&gt;foldLeft is like reduceLeft, but can apply on Nil, and takes an &lt;strong&gt;accumulator&lt;/strong&gt; &lt;code&gt;z&lt;/code&gt; =&amp;gt; returns z when calling on Nil. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image007.png"/&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum(xs: List[Int]) = (xs foldleft 0) ( _+_ )&lt;/span&gt;
&lt;span class="code-line"&gt;def prod(xs: List[Int]) = (xs foldleft 1) ( _*_ )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image008.png"/&gt;&lt;/p&gt;
&lt;h3 id="foldrightreduceright"&gt;foldRight/reduceRight&lt;/h3&gt;
&lt;p&gt;dual functions to &lt;code&gt;foldLeft&lt;/code&gt; and &lt;code&gt;reduceLeft&lt;/code&gt;, but produce a tree leaned to right&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image010.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image011.png"/&gt;&lt;/p&gt;
&lt;p&gt;if the operation is associative and communitive, foldLeft and foldRight should give same results. Other times need to think. &lt;/p&gt;
&lt;p&gt;ex. concat&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image012.png"/&gt;
if apply foldLeft ⇒ type error, because the &lt;code&gt;::&lt;/code&gt; operator will be applied to 2 elements of type T.&lt;/p&gt;
&lt;h1 id="56-reasoning-about-concat"&gt;5.6 - Reasoning About Concat&lt;/h1&gt;
&lt;p&gt;proof of programs&lt;/p&gt;
&lt;h3 id="structural-induction"&gt;structural induction&lt;/h3&gt;
&lt;p&gt;pb: prove some properties of concat:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image015.png"/&gt;&lt;/p&gt;
&lt;p&gt;类似数学归纳法: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image016.png"/&gt;&lt;/p&gt;
&lt;p&gt;ex. prove &lt;code&gt;(xs ++ ys) ++ zs = xs ++ (ys ++ zs)&lt;/code&gt;: induction on &lt;code&gt;xs&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def concat[T](xs: List[T], ys: List[T]) = xs match{&lt;/span&gt;
&lt;span class="code-line"&gt;    case Nil =&amp;gt; ys&lt;/span&gt;
&lt;span class="code-line"&gt;    case z::zs =&amp;gt; x:concat(xs, ys)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;base case: &lt;code&gt;xs=Nil&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;(Nil ++ ys ) ++ zs = Nil ++ (ys ++ zs)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;induction step: &lt;code&gt;x::xs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image017.png"/&gt;&lt;/p&gt;
&lt;h2 id="57-a-larger-equational-proof-on-lists"&gt;5.7 - A Larger Equational Proof on Lists&lt;/h2&gt;
&lt;p&gt;pb: want to prove that &lt;code&gt;xs.reverse.revese == xs&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;base case: &lt;code&gt;Nil.reverse.revers = Nil&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;induction step&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pb: cannot advance 
⇒ generalize the argument. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec5_lists/pasted_image018.png"/&gt;&lt;/p&gt;</summary><category term="scala"></category></entry><entry><title>[Scala MOOC I] Lec4: Types and Pattern Matching</title><link href="http://x-wei.github.io/progfun1_lec4_pattern_matching.html" rel="alternate"></link><published>2016-07-17T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-07-17:progfun1_lec4_pattern_matching.html</id><summary type="html">
&lt;h2 id="41-objects-everywhere"&gt;4.1 - Objects Everywhere&lt;/h2&gt;
&lt;p&gt;scala is &lt;em&gt;pure&lt;/em&gt; OO: every value is an obj, every operation is a method of obj.  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;scala.Int&lt;/code&gt; &lt;code&gt;scala.Boolean&lt;/code&gt; maps to JVM standard primitive types.  &lt;/p&gt;
&lt;p&gt;Implement &lt;code&gt;Boolean&lt;/code&gt; withous primitive type in scala:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image.png"/&gt; &lt;/p&gt;
&lt;p&gt;Then defin &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; as objects, give implementation for &lt;code&gt;ifThenElse()&lt;/code&gt; funciton:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;object true extends Boolean{ &lt;/span&gt;
&lt;span class="code-line"&gt;    def ifThenElse[T](t: =&amp;gt;T, e: =&amp;gt;T) = t &lt;/span&gt;
&lt;span class="code-line"&gt;} &lt;/span&gt;
&lt;span class="code-line"&gt;object false extends Boolean{ &lt;/span&gt;
&lt;span class="code-line"&gt;    def ifThenElse[T](t: =&amp;gt;T, e: =&amp;gt;T) = e &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="42-functions-as-objects"&gt;4.2 - Functions as Objects&lt;/h2&gt;
&lt;p&gt;Function values are treated as objects in scala.&lt;br/&gt;
the type &lt;code&gt;A =&amp;gt; B&lt;/code&gt; is an abbrevation for &lt;code&gt;scala.Function1[A, B]&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image001.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Functions are objects with &lt;/strong&gt;&lt;code&gt;apply&lt;/code&gt;&lt;strong&gt; methods.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;anonymous function &lt;code&gt;(x: Int) =&amp;gt; x*x&lt;/code&gt; is expanded to :  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;new Function1[Int, Int]{ &lt;/span&gt;
&lt;span class="code-line"&gt;def apply(x: Int) = x*x &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;function call &lt;code&gt;f(a,b)&lt;/code&gt; is expanded to:  &lt;code&gt;f.apply(a,b)&lt;/code&gt;
&lt;code&gt;List(1,2)&lt;/code&gt; is expanded to : &lt;code&gt;List.apply(1,2)&lt;/code&gt; &lt;/p&gt;
&lt;h2 id="43-subtyping-and-generics"&gt;4.3 - Subtyping and Generics&lt;/h2&gt;
&lt;p&gt;2 forms of polymorphism: &lt;em&gt;subtyping and generics&lt;/em&gt; &lt;/p&gt;
&lt;h3 id="type-bounds"&gt;Type Bounds&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image003.png"/&gt;
&lt;code&gt;assertAllPos&lt;/code&gt; taks either &lt;code&gt;EmptySet&lt;/code&gt; or &lt;code&gt;NonEmptySet&lt;/code&gt;, the return type is EmptySet (when para=EmptySet) or NonEmptySet (when para=NonEmpty).&lt;br/&gt;
To express this situation:  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;def assertAllPos[S &amp;lt;: IntSet](r: S): S = ...&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;Here &lt;code&gt;&amp;lt;: IntSet&lt;/code&gt; means IntSet is an upper bound of the type parameter.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image004.png"/&gt; 
and we can mix the two notations:  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;[S &amp;gt;: NonEmpty &amp;lt;: IntSet]&lt;/code&gt; &lt;/p&gt;
&lt;h3 id="covariance"&gt;Covariance&lt;/h3&gt;
&lt;p&gt;Given &lt;code&gt;NonEmpty &amp;lt;: IntSet&lt;/code&gt;,&lt;br/&gt;
should we have: &lt;code&gt;List[NonEmpty] &amp;lt;: List[IntSet]&lt;/code&gt; ? &lt;/p&gt;
&lt;p&gt;In this case the typse are called *covariant. * &lt;/p&gt;
&lt;p&gt;In java, arrays are covariant: &lt;code&gt;NonEmpty[] &amp;lt;: IntSet[]&lt;/code&gt; 
but this might cause problems:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image005.png"/&gt; &lt;/p&gt;
&lt;p&gt;will get ArrayStoreException in 3rd line.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Liskov substitution principle&lt;/strong&gt;: when a type can be a subtype of another  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;If A&amp;lt;:B, then everything one can do with an object of type B, one should also be able to do it with object of type A.&lt;/em&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In scala the Array is not covariant: &lt;code&gt;Array[IntSet]&lt;/code&gt; is not supertype of &lt;code&gt;Array[NonEmpty]&lt;/code&gt; &lt;/p&gt;
&lt;h2 id="45-decomposition"&gt;4.5 - Decomposition&lt;/h2&gt;
&lt;p&gt;ex: arithmetic expression interpreter: a tree of numbers and sums, both are subtype of &lt;code&gt;Expr&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;1st try: test and accessor methods &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image006.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image007.png"/&gt; &lt;/p&gt;
&lt;p&gt;→ tedious... And to add more operands need to add many more methods...  &lt;/p&gt;
&lt;p&gt;2nd try: (non-solution) 
type testing and type casting 
&lt;code&gt;isinstantceof&lt;/code&gt;, &lt;code&gt;asinstanceof&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image008.png"/&gt; &lt;/p&gt;
&lt;p&gt;discouraged in scala. &lt;/p&gt;
&lt;p&gt;1st solution: &lt;strong&gt;OO decomposition&lt;/strong&gt; 
add &lt;code&gt;eval&lt;/code&gt; method to class Expr. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image009.png"/&gt; &lt;/p&gt;
&lt;p&gt;limitation: if we want to simplify an expression,  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image010.png"/&gt; &lt;/p&gt;
&lt;p&gt;⇒ there is no local simplification ! &lt;/p&gt;
&lt;p&gt;⇒ &lt;strong&gt;pattern matching&lt;/strong&gt; &lt;/p&gt;
&lt;h2 id="46-pattern-matching"&gt;4.6 - Pattern Matching&lt;/h2&gt;
&lt;p&gt;goal: &lt;em&gt;reverse&lt;/em&gt; the construction process.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;which subclass it is? &lt;/li&gt;
&lt;li&gt;what were the arguments? &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="case-classes"&gt;case classes&lt;/h3&gt;
&lt;p&gt;add &lt;code&gt;case&lt;/code&gt; in class definition. 
ex. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;case class Number(n: Int) extends Expr &lt;/span&gt;
&lt;span class="code-line"&gt;case class Sum(e1: Expr, e2: Expr) extends Expr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;adding &lt;code&gt;case&lt;/code&gt; adds &lt;em&gt;companion objects&lt;/em&gt; with &lt;code&gt;apply&lt;/code&gt; methods:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image011.png"/&gt; &lt;/p&gt;
&lt;p&gt;according to the expansion, &lt;code&gt;Number(2)&lt;/code&gt; is equal to &lt;code&gt;Number.apply(2)&lt;/code&gt; which is actaully &lt;code&gt;new Numver(2)&lt;/code&gt; &lt;/p&gt;
&lt;h3 id="pattern-matching"&gt;pattern matching&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;match&lt;/code&gt;: extension of &lt;code&gt;switch&lt;/code&gt; in java, ex:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def eval(e: Expr): Int = e match{ &lt;/span&gt;
&lt;span class="code-line"&gt;    case Number(n) =&amp;gt; n &lt;/span&gt;
&lt;span class="code-line"&gt;    case Sum(e1, e2) =&amp;gt; e1 + e2 &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image012.png"/&gt; &lt;/p&gt;
&lt;p&gt;patterns include:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;constructor, ex. &lt;code&gt;Number(n)&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;variable, ex. &lt;code&gt;n, e1, e2&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;wildcard patters, ex. &lt;code&gt;_&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;constant, ex. &lt;code&gt;1, true&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;or their combination, ex &lt;code&gt;Sum(Number(1),  Var(x))&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The whole match expression is replaced with the expression to the rhs of the first match pattern.  &lt;/p&gt;
&lt;p&gt;exercice: implement a &lt;code&gt;show&lt;/code&gt; function. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def show(e: Expr): String = e match { &lt;/span&gt;
&lt;span class="code-line"&gt;    case Number(n) =&amp;gt; n.toString &lt;/span&gt;
&lt;span class="code-line"&gt;    case Sum(l, r) =&amp;gt; show(l) + "+" + show(r) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="47-lists"&gt;4.7 - Lists&lt;/h2&gt;
&lt;p&gt;example:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image013.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image014.png"/&gt; &lt;/p&gt;
&lt;p&gt;difference between List and Array:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lists are immutable, elements cannot change &lt;/li&gt;
&lt;li&gt;Lists are recursive, arrays are flat &lt;/li&gt;
&lt;li&gt;both are homogeneous, all elements of the same type &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All &lt;code&gt;List&lt;/code&gt;s in scala are constructed with:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Empty list &lt;code&gt;Nil&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;construction op &lt;code&gt;::&lt;/code&gt;(pronunced: cons), &lt;code&gt;x::xs&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image015.png"/&gt; &lt;/p&gt;
&lt;p&gt;convention in scala: operators ending with &lt;code&gt;:&lt;/code&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;are &lt;em&gt;right-associative&lt;/em&gt;. &lt;code&gt;a::b::c&lt;/code&gt; is equal to &lt;code&gt;a::(b::c)&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;seen as method calls from the right-hand operand. &lt;code&gt;1::2::Nil&lt;/code&gt; equal to &lt;code&gt;Nil.::(2).::(1)&lt;/code&gt; ( &lt;code&gt;::&lt;/code&gt; is prepend operation) &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;operations on lists:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;head &lt;/li&gt;
&lt;li&gt;tail &lt;/li&gt;
&lt;li&gt;isEmpty &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;list in pattern matching: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image016.png"/&gt; &lt;/p&gt;
&lt;p&gt;ex. insertion sort of lists &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec4_pattern_matching/pasted_image017.png"/&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def isort(xs: List[Int]): List[Int] = xs match{ &lt;/span&gt;
&lt;span class="code-line"&gt;    case List() =&amp;gt; List() &lt;/span&gt;
&lt;span class="code-line"&gt;    case y::ys =&amp;gt; insert(y, isort(ys)) &lt;/span&gt;
&lt;span class="code-line"&gt;} &lt;/span&gt;
&lt;span class="code-line"&gt;def insert(x:Int, xs:List[Int]): List[Int] = xs match{ &lt;/span&gt;
&lt;span class="code-line"&gt;    case List() =&amp;gt; List(x) &lt;/span&gt;
&lt;span class="code-line"&gt;    case y::ys =&amp;gt; if(x&amp;lt;=y) x::xs else y::insert(y, ys) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="scala"></category></entry><entry><title>[Scala MOOC I] Lec3: Data and Abstraction</title><link href="http://x-wei.github.io/progfun1_lec3_data_abstraction.html" rel="alternate"></link><published>2016-06-28T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-06-28:progfun1_lec3_data_abstraction.html</id><summary type="html">
&lt;p&gt;This week, we'll cover traits, and we'll learn how to organize classes into hierarchies. We'll cover the hierarchy of standard Scala types, and see how to organize classes and traits into packages. Finally, we'll touch upon the different sorts of polymorphism in Scala. &lt;/p&gt;
&lt;h2 id="31-class-hierarchies"&gt;3.1 - Class Hierarchies&lt;/h2&gt;
&lt;h3 id="abstract-class"&gt;abstract class&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;abstract class IntSet { &lt;/span&gt;
&lt;span class="code-line"&gt;  def incl(x: Int): IntSet &lt;/span&gt;
&lt;span class="code-line"&gt;  def contains(x: Int): Boolean &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;abstract class:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;contains members without implementation &lt;/li&gt;
&lt;li&gt;cannot be created with &lt;code&gt;new&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="class-extensions"&gt;class Extensions&lt;/h3&gt;
&lt;p&gt;implement the integer set abstract class with BST 
2 types of trees: &lt;code&gt;Empty&lt;/code&gt; and &lt;code&gt;NonEmpty&lt;/code&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Empty&lt;/span&gt; &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;IntSet&lt;/span&gt; { &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;override&lt;/span&gt; &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;incl&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;: &lt;span class="nb"&gt;Int&lt;/span&gt;): &lt;span class="n"&gt;IntSet&lt;/span&gt; = &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NonEmpty&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;, &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Empty&lt;/span&gt;, &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Empty&lt;/span&gt;)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;override&lt;/span&gt; &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="nb"&gt;contains&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;: &lt;span class="nb"&gt;Int&lt;/span&gt;): &lt;span class="n"&gt;Boolean&lt;/span&gt; = &lt;span class="n"&gt;false&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;NonEmpty&lt;/span&gt;(&lt;span class="n"&gt;elem:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;, &lt;span class="n"&gt;left:&lt;/span&gt; &lt;span class="n"&gt;IntSet&lt;/span&gt;, &lt;span class="n"&gt;right:&lt;/span&gt; &lt;span class="n"&gt;IntSet&lt;/span&gt;) &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;IntSet&lt;/span&gt; { &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;override&lt;/span&gt; &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;incl&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;: &lt;span class="nb"&gt;Int&lt;/span&gt;): &lt;span class="n"&gt;IntSet&lt;/span&gt; = &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="o"&gt;x&lt;/span&gt; == &lt;span class="n"&gt;elem&lt;/span&gt;) &lt;span class="n"&gt;this&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;elem&lt;/span&gt; &amp;gt; &lt;span class="o"&gt;x&lt;/span&gt;) &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NonEmpty&lt;/span&gt;(&lt;span class="n"&gt;elem&lt;/span&gt;, &lt;span class="n"&gt;left&lt;/span&gt;.&lt;span class="n"&gt;incl&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;), &lt;span class="n"&gt;right&lt;/span&gt;)// &lt;span class="n"&gt;immutable&lt;/span&gt;! &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NonEmpty&lt;/span&gt;(&lt;span class="n"&gt;elem&lt;/span&gt;, &lt;span class="n"&gt;left&lt;/span&gt;, &lt;span class="n"&gt;right&lt;/span&gt;.&lt;span class="n"&gt;incl&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;))&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;override&lt;/span&gt; &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="nb"&gt;contains&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;: &lt;span class="nb"&gt;Int&lt;/span&gt;): &lt;span class="n"&gt;Boolean&lt;/span&gt; = &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;elem&lt;/span&gt; == &lt;span class="o"&gt;x&lt;/span&gt;) &lt;span class="nb"&gt;true&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;elem&lt;/span&gt; &amp;gt; &lt;span class="o"&gt;x&lt;/span&gt;) &lt;span class="n"&gt;left&lt;/span&gt;.&lt;span class="nb"&gt;contains&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;) &lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;.&lt;span class="nb"&gt;contains&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;root class of all classes: &lt;code&gt;Object&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;replace concrete defintion of super class: &lt;code&gt;override&lt;/code&gt; is mandantory. &lt;/p&gt;
&lt;h3 id="object"&gt;Object&lt;/h3&gt;
&lt;p&gt;in the previous example, seems only one single &lt;code&gt;Empty&lt;/code&gt; set is needed.&lt;br/&gt;
⇒ define &lt;code&gt;Empty&lt;/code&gt; as &lt;strong&gt;singleton object&lt;/strong&gt; 
no other &lt;code&gt;Empty&lt;/code&gt; instances can be created, object is a &lt;em&gt;value.&lt;/em&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;object Empty extends IntSet { &lt;/span&gt;
&lt;span class="code-line"&gt;  override def incl(x: Int): IntSet = new NonEmpty(x, Empty, Empty)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  override def contains(x: Int): Boolean = false&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  override def toString = "." &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="program"&gt;Program&lt;/h3&gt;
&lt;p&gt;create standalone scala applicatoins.&lt;br/&gt;
Each such applications contains an &lt;code&gt;object&lt;/code&gt; with a &lt;code&gt;main(args:Array[String])&lt;/code&gt; method &lt;/p&gt;
&lt;h3 id="exercice-implement-union"&gt;exercice: implement union&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;union(other:IntSet): IntSet&lt;/code&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;override def union(other: IntSet): IntSet = &lt;/span&gt;
&lt;span class="code-line"&gt;  left union (right union (other incl elem))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;why this recursive call terminates ?&lt;br/&gt;
every call to &lt;code&gt;union&lt;/code&gt; is on a &lt;em&gt;smaller&lt;/em&gt; IntSet ! &lt;/p&gt;
&lt;p&gt;写成这样就会stackoverflow: &lt;code&gt;other.incl(elem).union(left).union(right)&lt;/code&gt;&lt;br/&gt;
讨论见: &lt;a href="https://www.coursera.org/learn/progfun1/discussions/weeks/3/threads/AzJ-4CLYEeag6wpD-92Rcw"&gt;https://www.coursera.org/learn/progfun1/discussions/weeks/3/threads/AzJ-4CLYEeag6wpD-92Rcw&lt;/a&gt; 
(需要点"view earlier replies"才有) 
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec3_data_abstraction/pasted_image012.png"/&gt; &lt;/p&gt;
&lt;h3 id="dynamic-binding"&gt;Dynamic Binding&lt;/h3&gt;
&lt;p&gt;behavior depends on the runtime type of the object.  &lt;/p&gt;
&lt;p&gt;~ higher-order functions &lt;/p&gt;
&lt;h2 id="lecture-32-how-classes-are-organized"&gt;Lecture 3.2 - How Classes Are Organized&lt;/h2&gt;
&lt;h3 id="package"&gt;package&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;named&lt;/span&gt; &lt;span class="n"&gt;imports&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;week3.Rational&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;week3.&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Hello&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;wildcard&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt;  &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;week3._&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;can import either from a package or from an object &lt;/p&gt;
&lt;p&gt;automatically imported in scala:&lt;br/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec3_data_abstraction/pasted_image001.png"/&gt; 
ex: 
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec3_data_abstraction/pasted_image002.png"/&gt; &lt;/p&gt;
&lt;p&gt;scaladoc: &lt;a href="http://www.scala-lang.org/files/archive/api/current/#package"&gt;http://www.scala-lang.org/files/archive/api/current/#package&lt;/a&gt; &lt;/p&gt;
&lt;h3 id="traits"&gt;Traits&lt;/h3&gt;
&lt;p&gt;in scala/java, a class has only one super class (single inheritance).&lt;br/&gt;
have several supertypes? ⇒ trait! &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one class can extend many traits (concated by &lt;code&gt;with&lt;/code&gt;)  — like java &lt;code&gt;interface&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec3_data_abstraction/pasted_image003.png"/&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;traits can contain fileds and concrete methods &lt;/li&gt;
&lt;li&gt;on the other hand, traits cannot have (value) parameters, but classes can &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="scala-class-hierchy"&gt;scala class hierchy&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec3_data_abstraction/pasted_image004.png"/&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Any&lt;/code&gt;: base class of all &lt;/li&gt;
&lt;li&gt;&lt;code&gt;AnyVal&lt;/code&gt;: primitive types (&lt;code&gt;Int, Unit, Boolean,...&lt;/code&gt;) &lt;/li&gt;
&lt;li&gt;&lt;code&gt;AnyRef&lt;/code&gt;: (=alias of &lt;code&gt;java.lang.Object&lt;/code&gt;) all reference types (&lt;code&gt;String, List, Seq, Iterable,...&lt;/code&gt;) &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Nothing&lt;/code&gt;: bottom of the hierchy, &lt;em&gt;is subtype of every type&lt;/em&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Null&lt;/code&gt;: &lt;em&gt;subtype of every reference type, &lt;/em&gt;&lt;code&gt;null&lt;/code&gt;'s type is &lt;code&gt;Null&lt;/code&gt;, not compatible with &lt;code&gt;AnyVal&lt;/code&gt; types.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;exception: &lt;code&gt;throw Exc&lt;/code&gt;, the typeof &lt;code&gt;Exc&lt;/code&gt; is &lt;code&gt;Nothing&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;exercice:&lt;br/&gt;
&lt;code&gt;if (true) 1 else false&lt;/code&gt; ⇒ type = &lt;code&gt;AnyVal&lt;/code&gt; &lt;/p&gt;
&lt;h2 id="lecture-33-polymorphism"&gt;Lecture 3.3 - Polymorphism&lt;/h2&gt;
&lt;h3 id="cons-list"&gt;cons-list&lt;/h3&gt;
&lt;p&gt;immutable linked list 
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec3_data_abstraction/pasted_image005.png"/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec3_data_abstraction/pasted_image006.png"/&gt; 
implement this in scala: 
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec3_data_abstraction/pasted_image007.png"/&gt; &lt;/p&gt;
&lt;p&gt;the &lt;code&gt;val&lt;/code&gt; in the class definition: &lt;strong&gt;defines at the same time parameter and field of a class&lt;/strong&gt;, equivalent to:&lt;br/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec3_data_abstraction/pasted_image008.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;type parameters&lt;/strong&gt; (generic) 
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec3_data_abstraction/pasted_image009.png"/&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;trait List[T]{ &lt;/span&gt;
&lt;span class="code-line"&gt;  def isEmpty : Boolean &lt;/span&gt;
&lt;span class="code-line"&gt;  def head: T &lt;/span&gt;
&lt;span class="code-line"&gt;  def tail: List[T] &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;class Cons[T](val head:T, val tail: List[T]) extends List[T] { &lt;/span&gt;
&lt;span class="code-line"&gt;  def isEmpty(): Boolean = false &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;head and tail are implemented in the parameters(fields), difference between &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;def&lt;/code&gt; only consist in the initialization (CBN, CBV). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Nil&lt;/span&gt;[&lt;span class="n"&gt;T&lt;/span&gt;] &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="nb"&gt;List&lt;/span&gt;[&lt;span class="n"&gt;T&lt;/span&gt;]{ &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isEmpty&lt;/span&gt; = &lt;span class="n"&gt;false&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;head:&lt;/span&gt; &lt;span class="n"&gt;Nothing&lt;/span&gt; = &lt;span class="n"&gt;throw&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NoSuchElementException&lt;/span&gt;(&lt;span class="s"&gt;"Nil.head"&lt;/span&gt;) &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;tail:&lt;/span&gt; &lt;span class="n"&gt;Nothing&lt;/span&gt; = &lt;span class="n"&gt;throw&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NoSuchElementException&lt;/span&gt;(&lt;span class="s"&gt;"Nil.tail"&lt;/span&gt;) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;use nothing as return type, and throw an exception.  &lt;/p&gt;
&lt;h3 id="generic-functions"&gt;generic functions&lt;/h3&gt;
&lt;p&gt;type parameters can be applied to functions.&lt;br/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec3_data_abstraction/pasted_image011.png"/&gt; 
sometime the type parameter can be deduced by scala compiler.&lt;br/&gt;
ex. &lt;code&gt;singleton(2); singleton(true)&lt;/code&gt; &lt;/p&gt;
&lt;h3 id="types-and-evaulation"&gt;Types and Evaulation&lt;/h3&gt;
&lt;p&gt;type parameters don't affect evaluation.&lt;br/&gt;
can assume type parameters are removed before the evaluation (&lt;em&gt;type erasure&lt;/em&gt;).  &lt;/p&gt;
&lt;h3 id="polymorphism"&gt;Polymorphism&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;subtyping: instances of subclass can be passed to a base class &lt;/li&gt;
&lt;li&gt;generics: function/class with type parameters &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;exercice: write a function &lt;code&gt;nth(n: Int, list: List)&lt;/code&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def nth[T](n: Int, list:List[T]): T =  &lt;/span&gt;
&lt;span class="code-line"&gt;  if(list.isEmpty) throw new IndexOutOfBoundsException() &lt;/span&gt;
&lt;span class="code-line"&gt;  else if (n==0) list.head &lt;/span&gt;
&lt;span class="code-line"&gt;  else nth(n-1, list.tail)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="programming-assignment-object-oriented-sets"&gt;Programming Assignment: Object-Oriented Sets&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;TweetSet&lt;/code&gt;: an abstract class &lt;code&gt;TweetSet&lt;/code&gt; with two concrete subclasses,&lt;code&gt;Empty&lt;/code&gt; which represents an empty set, and &lt;code&gt;NonEmpty(elem: Tweet, left: TweetSet, right: TweetSet&lt;/code&gt;), which represents a non-empty set as a binary tree rooted at elem. The tweets are indexed by their text bodies: the bodies of all tweets on the left are lexicographically smaller than elem and all bodies of elements on the right are lexicographically greater. &lt;/p&gt;</summary><category term="scala"></category></entry><entry><title>[Scala MOOC I] Lec2: Higher Order Functions</title><link href="http://x-wei.github.io/progfun1_lec2_highorder_func.html" rel="alternate"></link><published>2016-06-23T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-06-23:progfun1_lec2_highorder_func.html</id><summary type="html">
&lt;blockquote&gt;
&lt;p&gt;This week, we'll learn about functions as first-class values, and higher order functions. We'll also learn about Scala's syntax and how it's formally defined. Finally, we'll learn about methods, classes, and data abstraction through the design of a data structure for rational numbers. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="21-higher-order-functions"&gt;2.1 - Higher-Order Functions&lt;/h2&gt;
&lt;p&gt;higher order functions: functions that takes functions as parameter or returns functions.  &lt;/p&gt;
&lt;p&gt;example:&lt;br/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image.png"/&gt; 
⇒ put the &lt;code&gt;f&lt;/code&gt; as a parameter &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum(f:Int =&amp;gt; Int, a: Int, b: Int):Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;  if(a&amp;gt;b) 0 &lt;/span&gt;
&lt;span class="code-line"&gt;  else f(a) + sum(f, a+1, b) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="function-types"&gt;function types&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;A =&amp;gt; B&lt;/code&gt; is a function that takes &lt;code&gt;A&lt;/code&gt; as parameter and returns &lt;code&gt;B&lt;/code&gt;. &lt;/p&gt;
&lt;h3 id="anonymous-functions"&gt;Anonymous functions&lt;/h3&gt;
&lt;p&gt;"literals" for functions, syntactic sugar. 
ex.   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;(x: Int, y: Int) =&amp;gt; x+y&lt;/code&gt;
&lt;code&gt;(x: Int) =&amp;gt; x*x&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;use anon functions in previous &lt;code&gt;sum()&lt;/code&gt; function:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;sum(x=&amp;gt;x, 1, 10) &lt;/span&gt;
&lt;span class="code-line"&gt;sum(x=&amp;gt;x*x, 1, 10)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;exercice: turn &lt;code&gt;sum()&lt;/code&gt; into tailrec fashion. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum2(f:Int =&amp;gt; Int, a: Int, b: Int):Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;  @tailrec &lt;/span&gt;
&lt;span class="code-line"&gt;  def sumTR(a: Int, acc: Int): Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;    if (a &amp;gt; b) acc &lt;/span&gt;
&lt;span class="code-line"&gt;    else sumTR(a + 1, acc + f(a)) &lt;/span&gt;
&lt;span class="code-line"&gt;  } &lt;/span&gt;
&lt;span class="code-line"&gt;  sumTR(a, 0) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(note: using namescoping to eliminate parameters in inner functions) &lt;/p&gt;
&lt;h2 id="22-currying"&gt;2.2 - Currying&lt;/h2&gt;
&lt;p&gt;define a function that &lt;em&gt;returns  a funtion&lt;/em&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum3(f:Int =&amp;gt; Int): (Int, Int)=&amp;gt;Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;  def sumF(a:Int, b:Int):Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;    if(a&amp;gt;b) 0 &lt;/span&gt;
&lt;span class="code-line"&gt;    else f(a) + sum3(f, a+1, b) &lt;/span&gt;
&lt;span class="code-line"&gt;  } &lt;/span&gt;
&lt;span class="code-line"&gt;  sumF &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;when calling this function:&lt;br/&gt;
&lt;code&gt;sum3(cube)(1,10)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;syntactic sugar: shorter version of functions that return functions: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum3(f:Int =&amp;gt; Int)(a:Int, b:Int):Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;    if(a&amp;gt;b) 0 &lt;/span&gt;
&lt;span class="code-line"&gt;    else f(a) + sum3(f)(a+1, b) &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;question: what is type of &lt;code&gt;sum3&lt;/code&gt;? 
→ &lt;code&gt;Int =&amp;gt; Int =&amp;gt; (Int, Int) =&amp;gt; Int&lt;/code&gt; 
note: functional types are &lt;em&gt;associated to the right&lt;/em&gt;,&lt;br/&gt;
&lt;code&gt;Int =&amp;gt; Int =&amp;gt; Int&lt;/code&gt; is equivalent to &lt;code&gt;Int =&amp;gt; (Int =&amp;gt; Int)&lt;/code&gt; &lt;/p&gt;
&lt;h3 id="currying"&gt;"currying"&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image002.png"/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image003.png"/&gt; &lt;/p&gt;
&lt;p&gt;exercice:&lt;br/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image005.png"/&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def product(f: Int =&amp;gt; Int)(a: Int, b: Int): Int = { &lt;/span&gt;
&lt;span class="code-line"&gt;  if (a &amp;gt; b) 1 &lt;/span&gt;
&lt;span class="code-line"&gt;  else a * product(f)(a + 1, b) &lt;/span&gt;
&lt;span class="code-line"&gt;} &lt;/span&gt;
&lt;span class="code-line"&gt;product(x=&amp;gt;x)(1,10)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image006.png"/&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def fact(n:Int) = product(x=&amp;gt;x)(1,n) &lt;/span&gt;
&lt;span class="code-line"&gt;fact(10)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image007.png"/&gt; 
    def more_general(op: (Int,Int) =&amp;gt; Int, default: Int) 
                    (f: Int=&amp;gt; Int)(a:Int, b:Int):Int = { 
      if(a&amp;gt;b) default 
      else op(a, more_general(op, default)(f)(a + 1, b)) 
    } 
    more_general((x,y)=&amp;gt;x+y, 0)(x=&amp;gt;x)(1,10) &lt;/p&gt;
&lt;p&gt;老师的解法:&lt;br/&gt;
    def map_reduce(f:Int=&amp;gt; Int, op:(Int, Int)=&amp;gt;Int, default:Int) 
                  (a:Int, b:Int):Int = { 
      if(a&amp;gt;b) default 
      else op(f(a), map_reduce(f, op, default)(a+1,b)) 
    } 
    def factorial2(n:Int):Int = map_reduce(x=&amp;gt;x, (a,b)=&amp;gt; a*b, 1)(1,n) 
    factorial2(10) &lt;/p&gt;
&lt;h2 id="23-example-finding-fixed-points"&gt;2.3 - Example: Finding Fixed Points&lt;/h2&gt;
&lt;p&gt;find the fix point of a function: x = f(x) 
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image008.png"/&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val tol = 0.001 &lt;/span&gt;
&lt;span class="code-line"&gt;def isCloseEnough(x:Double, y:Double):Boolean = &lt;/span&gt;
&lt;span class="code-line"&gt;  math.abs((x-y)/x)&amp;lt;tol &lt;/span&gt;
&lt;span class="code-line"&gt;def fixedPoint(f: Double=&amp;gt;Double)(firstGuess:Double):Double = { &lt;/span&gt;
&lt;span class="code-line"&gt;  def iterate(guess:Double):Double = { &lt;/span&gt;
&lt;span class="code-line"&gt;    if(isCloseEnough(guess, f(guess))) guess &lt;/span&gt;
&lt;span class="code-line"&gt;    else iterate(f(guess)) &lt;/span&gt;
&lt;span class="code-line"&gt;  } &lt;/span&gt;
&lt;span class="code-line"&gt;  iterate(firstGuess) &lt;/span&gt;
&lt;span class="code-line"&gt;} &lt;/span&gt;
&lt;span class="code-line"&gt;fixedPoint(x=&amp;gt;1+x/2)(1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;using the fixepoint function for &lt;code&gt;sqrt&lt;/code&gt;: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sqrt(x) = y such that: x=y*y &lt;/li&gt;
&lt;li&gt;=y such that y = x/y &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;=&lt;em&gt;fixed point for the function f(y)=x/y&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;def sqrt(x:Double):Double = fixedPoint(y=&amp;gt;x/y)(1) 
sqrt(2) &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⇒ doesn't converge! ⇒ guess oscillates between 1 and 2... 
average damping: prevent the estimate from varying to much. 
⇒  &lt;em&gt;by taking the average of successive values&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;def sqrt2(x: Double): Double = fixedPoint(y =&amp;gt; (y + x / y) / 2)(1)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;abstract this damping technique: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def avgDamping(f:Double=&amp;gt; Double)(x:Double):Double = &lt;/span&gt;
&lt;span class="code-line"&gt;  (f(x)+x)/2 &lt;/span&gt;
&lt;span class="code-line"&gt;def sqrt2(x: Double): Double = fixedPoint(avgDamping(y=&amp;gt;x/y))(1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;summary: The highest level of abstraction is not always the best, but it is important to know the techniques of abstraction, so as to use them when appropriate. &lt;/p&gt;
&lt;h2 id="24-scala-syntax-summary"&gt;2.4 - Scala Syntax Summary&lt;/h2&gt;
&lt;p&gt;notations(EBNF): &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt; denotes an alternative &lt;/li&gt;
&lt;li&gt;&lt;code&gt;[...]&lt;/code&gt; an option (0 or 1) &lt;/li&gt;
&lt;li&gt;&lt;code&gt;{...}&lt;/code&gt; a repetition (0 or more) &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Types&lt;/strong&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image009.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Expressions&lt;/strong&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image010.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Definitions&lt;/strong&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image011.png"/&gt; &lt;/p&gt;
&lt;h2 id="25-functions-and-data"&gt;2.5 - Functions and Data&lt;/h2&gt;
&lt;p&gt;example. &lt;em&gt;rational numbers&lt;/em&gt; (x/y) 
define a class:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;:&lt;span class="n"&gt;Int&lt;/span&gt;, &lt;span class="n"&gt;y:Int&lt;/span&gt;){ &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;numer&lt;/span&gt; = &lt;span class="o"&gt;x&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;denom&lt;/span&gt; = &lt;span class="n"&gt;y&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;} &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;x&lt;/span&gt; = &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;(&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="mi"&gt;2&lt;/span&gt;) &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;x&lt;/span&gt;.&lt;span class="n"&gt;numer&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;x&lt;/span&gt;.&lt;span class="n"&gt;denom&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;this definition creates both a class and the constructor.&lt;br/&gt;
now implement arithmetic: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def add(that: Rational) = &lt;/span&gt;
&lt;span class="code-line"&gt;  new Rational(numer * that.denom + denom * that.numer, that.denom * denom)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def neg = new Rational(-numer, denom)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def sub(that: Rational) = &lt;/span&gt;
&lt;span class="code-line"&gt;  add(that.neg)&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;override def toString = numer + "/" + denom&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="26-more-fun-with-rationals"&gt;2.6 - More Fun With Rationals&lt;/h2&gt;
&lt;p&gt;simplify the rationals &lt;em&gt;at construction&lt;/em&gt;:  add private members:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) &lt;/span&gt;
&lt;span class="code-line"&gt;private val g = gcd(x, y) &lt;/span&gt;
&lt;span class="code-line"&gt;def numer = x/g &lt;/span&gt;
&lt;span class="code-line"&gt;def denom = y/g&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;other options:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;replace &lt;code&gt;g&lt;/code&gt; with &lt;code&gt;gcd(x,y)&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;turn &lt;code&gt;numer&lt;/code&gt; and &lt;code&gt;denom&lt;/code&gt; into &lt;code&gt;val&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;add less and max function:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def less(that:Rational) = &lt;/span&gt;
&lt;span class="code-line"&gt;  this.numer*that.denom &amp;lt; this.denom*that.numer&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def max(that:Rational) = if(this.less(that)) that else this&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="preconditions"&gt;preconditions&lt;/h3&gt;
&lt;p&gt;ex: avoid divide by 0.  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;require(y!=0, "denominator must be non zero")&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;→ &lt;em&gt;java.lang.IllegalArgumentException: requirement failed: denominator must be non zero&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;require&lt;/code&gt;is a test to perform when the class is initialized.&lt;br/&gt;
similar: &lt;code&gt;assert()&lt;/code&gt; &lt;/p&gt;
&lt;h3 id="constructor"&gt;constructor&lt;/h3&gt;
&lt;p&gt;in scala a class implicitly introduces a &lt;strong&gt;primary constructor:&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;takes parameters of the class&lt;/em&gt; &lt;/li&gt;
&lt;li&gt;&lt;em&gt;executes all statements in the class body&lt;/em&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;to add another constructor: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;def this(x:Int) = this(x,1)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;exercice:&lt;br/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image012.png"/&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;override def toString = { &lt;/span&gt;
&lt;span class="code-line"&gt;  val g = gcd(numer, denom) &lt;/span&gt;
&lt;span class="code-line"&gt;  numer/g + "/" + denom/g &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="27-evaluation-and-operators"&gt;2.7 - Evaluation and Operators&lt;/h2&gt;
&lt;h2 id="evaluation-for-classobject"&gt;evaluation for class/object&lt;/h2&gt;
&lt;p&gt;extend the substitution model to classes and objects 
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image014.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image015.png"/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image016.png"/&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image017.png"/&gt; &lt;/p&gt;
&lt;p&gt;examples:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image019.png"/&gt; &lt;/p&gt;
&lt;h2 id="operator-overloading"&gt;operator overloading&lt;/h2&gt;
&lt;h3 id="infix-ops"&gt;infix ops&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;any method with one parameter can be used as an infix operator.&lt;/strong&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image020.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;em&gt;scala identifiers can bu symbolic:&lt;/em&gt;
&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image021.png"/&gt; &lt;/p&gt;
&lt;p&gt;⇒ change names to &lt;code&gt;+, &amp;lt;, -,&lt;/code&gt; use in this way: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;x + y &lt;/span&gt;
&lt;span class="code-line"&gt;x &amp;lt; y &lt;/span&gt;
&lt;span class="code-line"&gt;x max y &lt;/span&gt;
&lt;span class="code-line"&gt;x - y - z&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="unitary-ops"&gt;unitary ops&lt;/h3&gt;
&lt;p&gt;now change the &lt;code&gt;neg&lt;/code&gt; method: prefix operator, and might be confused with the sub(&lt;code&gt;-&lt;/code&gt;) 
⇒ it's name is special: &lt;code&gt;unary_-&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;def unary_- = new Rational(-numer, denom)&lt;/code&gt; &lt;/p&gt;
&lt;h3 id="precedence-of-ops"&gt;precedence of ops&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;the precedence of an op is defined by its first letter&lt;/strong&gt; 
order (by increasing precedence): &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec2_highorder_func/pasted_image022.png"/&gt; 
quite the same as in java &lt;/p&gt;
&lt;h2 id="programming-assignment-functional-sets"&gt;Programming Assignment: Functional Sets&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Mathematically, we call the function which takes an integer as argument and which returns a boolean indicating whether the given integer belongs to a set, the characteristic function of the set. For example, we can characterize the set of negative integers by the characteristic function (x: Int) =&amp;gt; x &amp;lt; 0. &lt;/p&gt;
&lt;p&gt;Therefore, we choose to represent a set by its characterisitc function and define a type alias for this representation: &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;type Set = Int =&amp;gt; Boolean &lt;/span&gt;
&lt;span class="code-line"&gt;def contains(s: Set, elem: Int): Boolean = s(elem)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="scala"></category></entry><entry><title>[Scala MOOC I] Lec1: Functions &amp; Evaluation</title><link href="http://x-wei.github.io/progfun1_lec1_fun_and_eval.html" rel="alternate"></link><published>2016-06-21T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-06-21:progfun1_lec1_fun_and_eval.html</id><summary type="html">
&lt;blockquote&gt;
&lt;p&gt;In this week, we'll learn the difference between functional imperative programming. We step through the basics of Scala; covering expressions, evaluation, conditionals, functions, and recursion  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="11-programming-paradigms"&gt;1.1 - Programming Paradigms&lt;/h2&gt;
&lt;p&gt;imperative programming:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;modify mutable variables  &lt;/li&gt;
&lt;li&gt;using assignments  &lt;/li&gt;
&lt;li&gt;control structures: if-else, loops, break, continue, return, etc.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;~~~&amp;gt; Von Neumann computer:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;em&gt;conceptualize data structures word-by-word. ⇒ need higher level abstractions (theories).&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image001.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;theory doesn't describe mutations!&lt;/strong&gt;&lt;br/&gt;
ex. theories of polynomials  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image002.png"/&gt; &lt;/p&gt;
&lt;p&gt;To implement high-level concepts following their math theories, &lt;strong&gt;there's no place for mutation&lt;/strong&gt;.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image003.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Functional programming&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image004.png"/&gt;&lt;br/&gt;
functions in FP language are 1st-class citizens.  &lt;/p&gt;
&lt;h2 id="12-elements-of-programming"&gt;1.2 - Elements of Programming&lt;/h2&gt;
&lt;p&gt;in a language:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;primitive expressions  &lt;/li&gt;
&lt;li&gt;operators to combin expressions  &lt;/li&gt;
&lt;li&gt;abstract expressions: introduce a name for an expression  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;primitive types in scala are written capatilized:   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image005.png"/&gt; &lt;/p&gt;
&lt;h3 id="repl"&gt;REPL&lt;/h3&gt;
&lt;p&gt;interactive shell: write expressions and respond its value  &lt;/p&gt;
&lt;h3 id="evaluation"&gt;Evaluation&lt;/h3&gt;
&lt;p&gt;evaluation: &lt;strong&gt;expression → value&lt;/strong&gt;&lt;br/&gt;
evaluation stops onces it results in a &lt;em&gt;value.&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;evaluate non-primitive expressions:&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;take the left-most operator  &lt;/li&gt;
&lt;li&gt;take (left and right) operands   &lt;/li&gt;
&lt;li&gt;apply the operator to operands  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;evaluate names:&lt;/strong&gt;&lt;br/&gt;
replace the name with the rhs of its &lt;em&gt;definition.&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;definitions can have parameters.&lt;br/&gt;
ex. variable/return types are &lt;em&gt;after&lt;/em&gt; their names, seperated by a &lt;code&gt;:&lt;/code&gt;&lt;br/&gt;
&lt;code&gt;def power(x: Double, y: Int): Double = ...&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;evaluate a parameterized function:&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image006.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image007.png"/&gt; &lt;/p&gt;
&lt;p&gt;This scheme is called "&lt;strong&gt;substition model&lt;/strong&gt;" — formalized in the lambda calculus. This can be applied as long as there is no &lt;em&gt;side effects&lt;/em&gt;(ex. modify variable &lt;code&gt;c++&lt;/code&gt;)&lt;em&gt;.&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Termination&lt;/strong&gt;&lt;br/&gt;
Q: does every expression evaluates to a value? &lt;br/&gt;
NO, ex. &lt;br/&gt;
&lt;code&gt;def loop: Int = loop&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;change evaluation strategy&lt;/strong&gt;&lt;br/&gt;
do &lt;em&gt;not&lt;/em&gt; reduce argument values before rewrite function application.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image008.png"/&gt; &lt;/p&gt;
&lt;h2 id="call-by-name-and-call-by-value"&gt;call-by-name and call-by-value&lt;/h2&gt;
&lt;p&gt;the above evaluation schemes.   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;call-by-value: reduce argument values before rewrite function application.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;advantage: it evaluates every function argument only once.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;call-by-name: do not reduce arg values  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;advantage: a function argument is not evaluated if the corresponding parameter is unused in the evaluation&lt;br/&gt;
of the function body.  &lt;/p&gt;
&lt;p&gt;ex.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image009.png"/&gt; &lt;/p&gt;
&lt;h2 id="13-evaluation-strategies-and-termination"&gt;1.3 - Evaluation Strategies and Termination&lt;/h2&gt;
&lt;p&gt;CBV and CBN:  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image010.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image011.png"/&gt; &lt;/p&gt;
&lt;p&gt;ex.   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def first(x: Int, y: Int) = x  &lt;/span&gt;
&lt;span class="code-line"&gt;first(1, loop)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;in scala:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;normally use call-by-value (more efficient than call-by-name because it avoid repeated computation of CBN).  &lt;/li&gt;
&lt;li&gt;but: &lt;strong&gt;if a  &lt;/strong&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;strong&gt; before a parameter type&lt;/strong&gt;, that parameter is called &lt;em&gt;by-name&lt;/em&gt;.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex.   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def constOne(x: Int, y: =&amp;gt; Int) = 1  &lt;/span&gt;
&lt;span class="code-line"&gt;constOne(1+2, loop)  &lt;/span&gt;
&lt;span class="code-line"&gt;constOne(loop, 1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="14-conditionals-and-value-definitions"&gt;1.4 - Conditionals and Value Definitions&lt;/h2&gt;
&lt;h3 id="conditional-expressions"&gt;conditional expressions&lt;/h3&gt;
&lt;p&gt;the &lt;code&gt;if-else&lt;/code&gt; expression&lt;br/&gt;
the &lt;code&gt;if-else&lt;/code&gt; is an expression, not statement.&lt;br/&gt;
ex. &lt;code&gt;def abs(x: Int): Int = if (x&amp;gt;=0) x else -x&lt;/code&gt;&lt;br/&gt;
the &lt;code&gt;x&amp;gt;=0&lt;/code&gt; is a boolean expression, sometimes called &lt;strong&gt;predicates&lt;/strong&gt;.  &lt;/p&gt;
&lt;h3 id="cbn-and-cbv-for-definition"&gt;CBN and CBV for definition&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;def&lt;/code&gt; form is by name, its rhs is evaluated at each use  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;val&lt;/code&gt; is by value, evaluted at the definiton  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;scala&amp;gt; def loop:Boolean = loop  &lt;/span&gt;
&lt;span class="code-line"&gt;loop: Boolean&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; def x = loop  &lt;/span&gt;
&lt;span class="code-line"&gt;x: Boolean&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; val x = loop  &lt;/span&gt;
&lt;span class="code-line"&gt;Execution interrupted by signal.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;exercice: implement &lt;code&gt;and(x,y)&lt;/code&gt; &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;scala&amp;gt; def and(x:Boolean, y: =&amp;gt; Boolean) = if(x) y else false  &lt;/span&gt;
&lt;span class="code-line"&gt;and: (x: Boolean, y: =&amp;gt; Boolean)Boolean&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;scala&amp;gt; and(false, loop)  &lt;/span&gt;
&lt;span class="code-line"&gt;res3: Boolean = false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="15-example-square-roots-with-newtons-method"&gt;1.5 - Example: square roots with Newton's method&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image012.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;def sqrt(x: Double): Double = ...&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;need helper (recursive) functions.   &lt;/p&gt;
&lt;p&gt;note: in scala the &lt;em&gt;return type of recursive functions&lt;/em&gt; must be given.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def improve(guess: Double, x: Double): Double =  &lt;/span&gt;
&lt;span class="code-line"&gt;  (x / guess + guess) / 2.0&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def isGoodGuess(guess: Double, x: Double): Boolean =  &lt;/span&gt;
&lt;span class="code-line"&gt;  math.abs((guess * guess - x)/x)&amp;lt;0.001&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def sqrtItr(guess: Double, x: Double): Double = {  &lt;/span&gt;
&lt;span class="code-line"&gt;  if (isGoodGuess(guess, x)) guess  &lt;/span&gt;
&lt;span class="code-line"&gt;  else sqrtItr(improve(guess, x), x)  &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def sqrt(x:Double): Double = sqrtItr(1, x)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="16-blocks-and-lexical-scope"&gt;1.6 - Blocks and Lexical Scope&lt;/h2&gt;
&lt;h3 id="nested-functions"&gt;nested functions&lt;/h3&gt;
&lt;p&gt;put aux functions inside a function.   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sqrt(x:Double): Double = {  &lt;/span&gt;
&lt;span class="code-line"&gt;  def improve(guess: Double, x: Double): Double =  &lt;/span&gt;
&lt;span class="code-line"&gt;    (x / guess + guess) / 2.0&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  def isGoodGuess(guess: Double, x: Double): Boolean =  &lt;/span&gt;
&lt;span class="code-line"&gt;    math.abs((guess * guess - x)/x)&amp;lt;0.001&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  def sqrtItr(guess: Double, x: Double): Double = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    if (isGoodGuess(guess, x)) guess  &lt;/span&gt;
&lt;span class="code-line"&gt;    else sqrtItr(improve(guess, x), x)  &lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  sqrtItr(1, x)  &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="blocks-and-visibility"&gt;blocks and visibility&lt;/h3&gt;
&lt;p&gt;blocks: delimited by braces &lt;code&gt;{...}&lt;/code&gt;&lt;br/&gt;
The last element of a block is an expression that defines its value.&lt;br/&gt;
Blocks are themselves expressions; &lt;em&gt;a block may appear everywhere an expression can&lt;/em&gt;.  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image013.png"/&gt; &lt;/p&gt;
&lt;p&gt;ex.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;val x = 0  &lt;/span&gt;
&lt;span class="code-line"&gt;def f(y: Int) = y +1  &lt;/span&gt;
&lt;span class="code-line"&gt;val result = {  &lt;/span&gt;
&lt;span class="code-line"&gt;  val x = f(3);  &lt;/span&gt;
&lt;span class="code-line"&gt;  x * x  &lt;/span&gt;
&lt;span class="code-line"&gt;} + x // result = 16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ex. eliminate the parameter &lt;code&gt;x&lt;/code&gt; of helper functions inside the &lt;code&gt;sqrt&lt;/code&gt; function  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sqrt(x:Double): Double = {  &lt;/span&gt;
&lt;span class="code-line"&gt;  def improve(guess: Double): Double =  &lt;/span&gt;
&lt;span class="code-line"&gt;    (x / guess + guess) / 2.0&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  def isGoodGuess(guess: Double): Boolean =  &lt;/span&gt;
&lt;span class="code-line"&gt;    math.abs((guess * guess - x)/x)&amp;lt;0.001&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  def sqrtItr(guess: Double): Double = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    if (isGoodGuess(guess)) guess  &lt;/span&gt;
&lt;span class="code-line"&gt;    else sqrtItr(improve(guess))  &lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  sqrtItr(1)  &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;about multiline expressions: put the operator in the first line to avoid ambguity.   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image014.png"/&gt; &lt;/p&gt;
&lt;h2 id="17-tail-recursion"&gt;1.7 - Tail Recursion&lt;/h2&gt;
&lt;p&gt;review: evaluation of function application.   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image015.png"/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image016.png"/&gt; &lt;/p&gt;
&lt;p&gt;ex1. gcd  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def gcd(a:Int, b:Int): Int=  &lt;/span&gt;
&lt;span class="code-line"&gt;  if(b==0) a else gcd(b, a%b)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image017.png"/&gt; &lt;/p&gt;
&lt;p&gt;ex2. factorial  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def factorial(n:Int): Int =  &lt;/span&gt;
&lt;span class="code-line"&gt;  if(n==0) 1 else n*factorial(n-1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" class="img-responsive" src="../images/progfun1_lec1_fun_and_eval/pasted_image018.png"/&gt; &lt;/p&gt;
&lt;p&gt;difference from the &lt;code&gt;gcd&lt;/code&gt; case:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;in &lt;code&gt;gcd&lt;/code&gt;, the expression is reduced to a &lt;code&gt;gcd()&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;in &lt;code&gt;factorial&lt;/code&gt;, &lt;em&gt;add one more element to the expression in each step&lt;/em&gt;!  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="tail-recursion"&gt;tail recursion&lt;/h3&gt;
&lt;p&gt;if &lt;strong&gt;a function calls itself  as its last action&lt;/strong&gt;, then the function's stack can be reused. &lt;br/&gt;
⇒ tail recursion functions are iterative process.   &lt;/p&gt;
&lt;p&gt;In general, if &lt;strong&gt;the last action of a function consists of calling a function (which may be the same)&lt;/strong&gt;, one stack frame would be sufficient for both functions. Such calls are called &lt;em&gt;tail-calls&lt;/em&gt;.  &lt;/p&gt;
&lt;p&gt;tail-recursive function:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;more efficient  &lt;/li&gt;
&lt;li&gt;can avoid stackoverflow  &lt;/li&gt;
&lt;li&gt;might not be as clear as a non-tailrec version   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;add &lt;code&gt;@tailrec&lt;/code&gt;annotation to the function, if its not tailrec, an error will be shown.    &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;@tailrec  &lt;/span&gt;
&lt;span class="code-line"&gt;def gcd(a: Int, b: Int): Int = ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;exercice: turn factorial into tailrec fashion. &lt;br/&gt;
→ idea: use an &lt;strong&gt;accumulator &lt;/strong&gt;(partial result) &lt;code&gt;acc&lt;/code&gt; .  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def factorialTR(n:Int):Int = {  &lt;/span&gt;
&lt;span class="code-line"&gt;  @tailrec  &lt;/span&gt;
&lt;span class="code-line"&gt;  def fact(n:Int, acc:Int):Int = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    if(n==0) acc  &lt;/span&gt;
&lt;span class="code-line"&gt;    else fact(n-1, n*acc)  &lt;/span&gt;
&lt;span class="code-line"&gt;  }  &lt;/span&gt;
&lt;span class="code-line"&gt;  fact(n, 1)  &lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="programming-assignment-recursion"&gt;Programming Assignment: Recursion&lt;/h2&gt;
&lt;p&gt;三道递归的练习题...  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;  /**  &lt;/span&gt;
&lt;span class="code-line"&gt;    * Exercise 1  &lt;/span&gt;
&lt;span class="code-line"&gt;    */  &lt;/span&gt;
&lt;span class="code-line"&gt;  def pascal(c: Int, r: Int): Int = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    if (c == 0 || c == r) 1  &lt;/span&gt;
&lt;span class="code-line"&gt;    else pascal(c, r - 1) + pascal(c - 1, r - 1)  &lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  /**  &lt;/span&gt;
&lt;span class="code-line"&gt;    * Exercise 2  &lt;/span&gt;
&lt;span class="code-line"&gt;    */  &lt;/span&gt;
&lt;span class="code-line"&gt;  def balance(chars: List[Char]): Boolean = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    def balance_rec(chars: List[Char], acc: Int): Boolean = {  &lt;/span&gt;
&lt;span class="code-line"&gt;      if (acc&amp;lt;0) false  &lt;/span&gt;
&lt;span class="code-line"&gt;      else if (chars.isEmpty) acc == 0  &lt;/span&gt;
&lt;span class="code-line"&gt;      else if (chars.head == '(') balance_rec(chars.tail, acc+1)  &lt;/span&gt;
&lt;span class="code-line"&gt;      else if (chars.head == ')') balance_rec(chars.tail, acc-1)  &lt;/span&gt;
&lt;span class="code-line"&gt;      else balance_rec(chars.tail, acc)  &lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    balance_rec(chars, 0)  &lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  /**  &lt;/span&gt;
&lt;span class="code-line"&gt;    * Exercise 3  &lt;/span&gt;
&lt;span class="code-line"&gt;    */  &lt;/span&gt;
&lt;span class="code-line"&gt;  def countChange(money: Int, coins: List[Int]): Int = {  &lt;/span&gt;
&lt;span class="code-line"&gt;    if(money==0 ) 1  &lt;/span&gt;
&lt;span class="code-line"&gt;    else if(coins.isEmpty || money&amp;lt;0) 0  &lt;/span&gt;
&lt;span class="code-line"&gt;    else countChange(money, coins.tail) + countChange(money-coins.head, coins)  &lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="scala"></category></entry><entry><title>[Scala MOOC I] Lec0: Getting Started</title><link href="http://x-wei.github.io/progfun1_lec0_setup.html" rel="alternate"></link><published>2016-06-20T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-06-20:progfun1_lec0_setup.html</id><summary type="html">
&lt;blockquote&gt;
&lt;p&gt;Get up and running with Scala on your computer. Complete an example assignment to familiarize yourself with our unique way of submitting assignments.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="tool-setup"&gt;Tool setup&lt;/h1&gt;
&lt;h3 id="intellij"&gt;IntelliJ&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;use worksheet as a better REPL&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="sbt"&gt;SBT&lt;/h3&gt;
&lt;p&gt;navigate to the directory of the assignment you are working on, then start &lt;code&gt;sbt&lt;/code&gt;. 
(when first running &lt;code&gt;sbt&lt;/code&gt;, will take 5~10 minutes to download files...)&lt;/p&gt;
&lt;h4 id="repl"&gt;REPL&lt;/h4&gt;
&lt;p&gt;type &lt;code&gt;console&lt;/code&gt; to enter scala REPL, hit &lt;code&gt;ctrl-d&lt;/code&gt; to exit REPL. &lt;/p&gt;
&lt;h4 id="compile-run-test"&gt;Compile / run / test&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;compile&lt;/code&gt;: The compile task will compile the source code of the assignment which is located in the directory &lt;code&gt;src/main/scala&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test&lt;/code&gt;: The directory &lt;code&gt;src/test/scala&lt;/code&gt; contains unit tests for the project. In order to run these tests in sbt, you can use the test command.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;run&lt;/code&gt;: If your project has an object with a main method (or an object extending the trait App), then you can run the code in sbt easily by typing run. In case sbt finds multiple main methods, it will ask you which one you'd like to execute.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="submit"&gt;submit&lt;/h4&gt;
&lt;p&gt;submitting assignments in sbt: 
&lt;code&gt;submit your@email.com YourSubmissionPassWord&lt;/code&gt;&lt;/p&gt;
&lt;h1 id="scala-tutorial"&gt;Scala tutorial&lt;/h1&gt;
&lt;h3 id="classes-traits-objects-and-packages"&gt;Classes, Traits, Objects and Packages&lt;/h3&gt;
&lt;h4 id="classes"&gt;Classes&lt;/h4&gt;
&lt;p&gt;Classes in Scala are very similar to classes in Java. They are templates containing fields and methods. Like in Java, classes can be instantiated using the new construct, there can be many “instances” (or “objects”) of the same class.&lt;/p&gt;
&lt;p&gt;In Scala there exists &lt;strong&gt;a special kind of class named case classes&lt;/strong&gt;. You will learn about case classes during the course.&lt;/p&gt;
&lt;p&gt;Classes in Scala &lt;strong&gt;cannot have static members&lt;/strong&gt;. You can use &lt;em&gt;objects&lt;/em&gt; (see below) to achieve similar functionality as with static members in Java.&lt;/p&gt;
&lt;h4 id="traits"&gt;Traits&lt;/h4&gt;
&lt;p&gt;Traits are like &lt;strong&gt;interfaces&lt;/strong&gt; in Java, but they &lt;em&gt;can also contain concrete members&lt;/em&gt;, i.e. method implementations or field definitions.&lt;/p&gt;
&lt;h4 id="objects"&gt;Objects&lt;/h4&gt;
&lt;p&gt;Object in Scala are like classes, but for every object definition there is only one single instance. &lt;em&gt;It is not possible to create instances of objects using new&lt;/em&gt;, instead you can just access the members (methods or fields) of an object using its name.&lt;/p&gt;
&lt;h4 id="packages"&gt;Packages&lt;/h4&gt;
&lt;p&gt;Adding a statement such as package foo.bar at the top of a file makes the code in a file part of the package foo.bar. You can then do import foo.bar._ to make everything from package foo.bar available in your code. The content of a package can be scattered across many files. If you define a class MyClass in package foo.bar, you can import that specific class (and not anything else from that package) with import foo.bar.MyClass.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;In Scala, everything can be imported, not only class names&lt;/em&gt;. So for instance if you have an object baz in package foo.bar, then import foo.bar.baz._ would import all the members of that object.&lt;/p&gt;
&lt;h3 id="hello-world-in-scala"&gt;Hello, World! in Scala&lt;/h3&gt;
&lt;p&gt;In Scala, the main or &lt;em&gt;entry point method is defined in an object&lt;/em&gt;. An object can be made executable by either adding extending the type &lt;code&gt;App&lt;/code&gt; or by adding a method &lt;code&gt;def main(args: Array[String])&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here are two ways to define a program which outputs “Hello, World!” in Scala:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;object HelloWorld extends App {&lt;/span&gt;
&lt;span class="code-line"&gt;  println("Hello, World!")&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;object HelloWorld {&lt;/span&gt;
&lt;span class="code-line"&gt;  def main(args: Array[String]) {&lt;/span&gt;
&lt;span class="code-line"&gt;    println("Hello, World!")&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="source-files-classfiles-and-the-jvm"&gt;Source Files, Classfiles and the JVM&lt;/h3&gt;
&lt;p&gt;Scala source code is stored in text files with the extension &lt;code&gt;.scala&lt;/code&gt;. Typically Scala programmers create one source file for each class, or one source file for a class hierarchy: In fact, Scala &lt;em&gt;allows multiple classes and objects to be defined in the same source file&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The name of a Scala source file can be chosen &lt;em&gt;freely&lt;/em&gt;, but it is recommended to use the name of a class which is defined in that file.&lt;/li&gt;
&lt;li&gt;Package hierarchies should be reflected in directory structure: a source file defining class C in package foo.bar should be stored in a subdirectory as foo/bar/C.scala. Scala does not really enforce this convention, but some tools such as the Scala IDE for eclipse might have problems otherwise.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The scala compiler compiles &lt;code&gt;.scala&lt;/code&gt; source files to &lt;code&gt;.class&lt;/code&gt; files, like the Java compiler. Classfiles are binary files containing machine code for the Java Virtual Machine. In order to run a Scala program, the JVM has to know the directory where classfiles are stored. This parameter is called the “classpath”.&lt;/p&gt;
&lt;p&gt;If you are using eclipse or sbt to compile and run your Scala code, you don’t need to do any of the above manually - these tools take care of invoking the Scala compiler and the JVM with the correct arguments.&lt;/p&gt;
&lt;h1 id="scala-style-guide"&gt;Scala Style Guide&lt;/h1&gt;
&lt;p&gt;style checker: &lt;a href="http://www.scalastyle.org/"&gt;http://www.scalastyle.org/&lt;/a&gt;
(in IntelliJ: You can enable scalastyle in Intellij by selecting Settings-&amp;gt;Editor-&amp;gt;Inspections, then searching for Scala style inspections.)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Avoid Casts and Type Tests&lt;/em&gt;: Never use isInstanceOf or asInstanceOf - there’s always a better solution.&lt;/li&gt;
&lt;li&gt;Indentation &lt;/li&gt;
&lt;li&gt;&lt;em&gt;Line Length and Whitespace&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Use local Values to simplify complex Expressions&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Choose meaningful Names for Methods and Values&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Common Subexpressions&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;*Don’t Copy-Paste Code!: factor out common parts into separate methods instead of copying code around. *&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Scala doesn’t require Semicolons&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Don’t submit Code with “print” Statements: the final code should be free of debugging statements.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Avoid using Return&lt;/em&gt;: often don’t need to use explicit returns. &lt;/li&gt;
&lt;li&gt;&lt;em&gt;Avoid mutable local Variables&lt;/em&gt;: You can often rewrite code that uses mutable local variables to code with helper functions that take accumulators.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Eliminate redundant “If” Expressions&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="cheatsheet"&gt;Cheatsheet&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/lampepfl/progfun-wiki/blob/gh-pages/CheatSheet.md"&gt;https://github.com/lampepfl/progfun-wiki/blob/gh-pages/CheatSheet.md&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="example-assignment"&gt;Example Assignment&lt;/h1&gt;
&lt;h3 id="implementation"&gt;implementation&lt;/h3&gt;
&lt;p&gt;implement &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;sum&lt;/code&gt; method for &lt;code&gt;List[Int]&lt;/code&gt;. 
trick: use recursion. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def sum(xs: List[Int]): Int = {&lt;/span&gt;
&lt;span class="code-line"&gt;    if (xs.isEmpty) 0&lt;/span&gt;
&lt;span class="code-line"&gt;    else xs.head + sum(xs.tail)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;def max(xs: List[Int]): Int = {&lt;/span&gt;
&lt;span class="code-line"&gt;    if (xs.isEmpty) throw new java.util.NoSuchElementException()&lt;/span&gt;
&lt;span class="code-line"&gt;    max(xs, Int.MinValue)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;def max(xs: List[Int], m: Int): Int = {&lt;/span&gt;
&lt;span class="code-line"&gt;    if (xs.isEmpty) m&lt;/span&gt;
&lt;span class="code-line"&gt;    else if (xs.head &amp;gt; m) max(xs.tail, xs.head)&lt;/span&gt;
&lt;span class="code-line"&gt;    else max(xs.tail, m)&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="scalatest"&gt;ScalaTest&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A test suite is simply a collection of individual tests for some specific component of a program. A test suite is created by defining a class which extends the type &lt;code&gt;org.scalatest.FunSuite&lt;/code&gt;. When running ScalaTest, it will automatically find this class and execute all of its tests.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You have two options for running this test suite:
- Start the sbt console and run the "&lt;code&gt;test&lt;/code&gt;" command
- Right-click this file in eclipse and chose "Run As" - "JUnit Test"&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Tests are written using the &lt;code&gt;test&lt;/code&gt; operator which takes two arguments:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A description of the test. This description has to be unique, no two tests can have the same description. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;The test body, a piece of Scala code that implements the test 
The most common way to implement a test body is using the method &lt;code&gt;assert&lt;/code&gt; which tests that its argument evaluates to &lt;code&gt;true&lt;/code&gt;. So one of the simplest successful tests is the following:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;test("one plus one is two")(assert(1 + 1 == 2))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;In Scala, it is allowed to pass an argument to a method using the block  syntax, i.e. &lt;code&gt;{ argument }&lt;/code&gt; instead of parentheses&lt;code&gt;(argument)&lt;/code&gt;.
This allows tests to be written in a more readable manner:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;test("one plus one is three?") {&lt;/span&gt;
&lt;span class="code-line"&gt;    assert(1 + 1 == 3) // This assertion fails! Go ahead and fix it.&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One problem with the previous (failing) test is that ScalaTest will      &lt;br/&gt;
only tell you that a test failed, but it will not tell you what was      &lt;br/&gt;
the reason for the failure. The output looks like this:                    &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;{{{                                                                        &lt;/span&gt;
&lt;span class="code-line"&gt;   [info] - one plus one is three? *** FAILED ***                          &lt;/span&gt;
&lt;span class="code-line"&gt;}}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This situation can be improved by &lt;strong&gt;using a special equality operator &lt;/strong&gt;&lt;code&gt;===&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; (this is only possible in ScalaTest). So if you  run the next test, ScalaTest will show the following output:               &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;{{{                                                                        &lt;/span&gt;
&lt;span class="code-line"&gt;   [info] - details why one plus one is not three *** FAILED ***           &lt;/span&gt;
&lt;span class="code-line"&gt;   [info]   2 did not equal 3 (ListsSuite.scala:67)                        &lt;/span&gt;
&lt;span class="code-line"&gt;}}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;We recommend to always use the &lt;/strong&gt;&lt;code&gt;===&lt;/code&gt;&lt;strong&gt; equality operator when writing tests.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;In order to test the exceptional behavior of a methods, ScalaTest offers the &lt;code&gt;intercept&lt;/code&gt;operation.                                              &lt;/p&gt;
&lt;p&gt;In the following example, we test the fact that the method &lt;code&gt;intNotZero&lt;/code&gt; throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if its argument is &lt;code&gt;0&lt;/code&gt;.     &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;def intNotZero(x: Int): Int = {&lt;/span&gt;
&lt;span class="code-line"&gt;    if (x == 0) throw new IllegalArgumentException("zero is not allowed")&lt;/span&gt;
&lt;span class="code-line"&gt;    else x&lt;/span&gt;
&lt;span class="code-line"&gt;  }     &lt;/span&gt;
&lt;span class="code-line"&gt;test("intNotZero throws an exception if its argument is 0") {&lt;/span&gt;
&lt;span class="code-line"&gt;    intercept[IllegalArgumentException] {&lt;/span&gt;
&lt;span class="code-line"&gt;      intNotZero(0)&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It is allowed to have multiple &lt;code&gt;assert&lt;/code&gt; statements inside one test, however it is recommended to write an individual &lt;code&gt;test&lt;/code&gt; statement for every tested aspect of a method.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;  test("sum of a few numbers") {&lt;/span&gt;
&lt;span class="code-line"&gt;    assert(sum(List(1,2,0)) === 3)&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;  test("sum of empty list"){&lt;/span&gt;
&lt;span class="code-line"&gt;    assert(sum(List())===0)&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;  test("sum of negative numbers"){&lt;/span&gt;
&lt;span class="code-line"&gt;    assert(sum(List(-1,-1,-1)) === -3)&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  test("max of a few numbers") {&lt;/span&gt;
&lt;span class="code-line"&gt;    assert(max(List(3, 7, 2)) === 7)&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;span class="code-line"&gt;  test("max of empty list throws NoSuchElementException"){&lt;/span&gt;
&lt;span class="code-line"&gt;    intercept[NoSuchElementException]{&lt;/span&gt;
&lt;span class="code-line"&gt;      max(List())&lt;/span&gt;
&lt;span class="code-line"&gt;    }&lt;/span&gt;
&lt;span class="code-line"&gt;  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="scala"></category></entry></feed>