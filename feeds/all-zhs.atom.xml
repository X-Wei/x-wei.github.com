<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>mx's Blog</title><link href="http://x-wei.github.io" rel="alternate"></link><link href="http://x-wei.github.io/feeds/all-zhs.atom.xml" rel="self"></link><id>http://x-wei.github.io</id><updated>2015-11-22T00:00:00+01:00</updated><entry><title>学术文章写作利器: TeXmacs介绍</title><link href="http://x-wei.github.io/TeXmacs_intro.html" rel="alternate"></link><updated>2015-11-22T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/TeXmacs_intro.html</id><summary type="html">&lt;p&gt;今天介绍一个论文写作的神器: TeXmacs !   &lt;/p&gt;
&lt;h1&gt;0. Why TeXmacs?&lt;/h1&gt;
&lt;p&gt;一说到"论文写作神器"一般大家首先想到的就是LaTeX, 确实LaTeX写出来的数学公式和文章的排版非常漂亮. 但是作为一个几年来用过LaTeX写过几次报告的小白用户, 说句实话我从来都没有喜欢上过LaTeX. 根本的原因大概是: LaTeX的语法是一种标记语言(markup language), 本质上是给机器看而不是给人看的—就像html源代码是为了给浏览器看而不是直接给人看的.   &lt;/p&gt;
&lt;h2&gt;0.0 LaTeX强迫症自测&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;矩阵A的转置, 你用tex会怎么写?  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;⇒ 如果你不能容忍直接写成&lt;code&gt;$A^T$&lt;/code&gt;, 而一定要写成类似&lt;code&gt;$\textbf{A}^\intercal$&lt;/code&gt;的话... 请直接忽略本文 &amp;amp; 继续用LaTe, 好走不送...... &lt;br /&gt;
(另: 强迫症可以去这里看到底怎么打转置: &lt;a href="http://tex.stackexchange.com/questions/30619/what-is-the-best-symbol-for-vector-matrix-transpose"&gt;http://tex.stackexchange.com/questions/30619/what-is-the-best-symbol-for-vector-matrix-transpose&lt;/a&gt;)  &lt;/p&gt;
&lt;p&gt;如果你认为这样的细节不重要, 好好描述数学问题本身才最重要的话, 请继续阅读.  &lt;/p&gt;
&lt;h2&gt;0.1 TeXmacs是什么&lt;/h2&gt;
&lt;p&gt;简言之, TeXmacs是一个所见即所得的编辑器. 你也许想到了LyX, TeXworks之类的工具, 但是TeXmacs和它们不一样—它并不依赖LaTeX. 他吸收了LaTeX的优点, 即文章的排版非常美观. 同时它又不同于LaTeX, 比如, 在TeXmacs里是&lt;em&gt;没有&lt;/em&gt;"源文件"这个概念的. 另外它还有一些非常实用的特性(尤其是对于数学公式的支持), 可以极大的提高编辑效率.   &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;作者: Joris van der Hoeven (&lt;a href="http://www.TeXmacs.org/joris/main/joris.html"&gt;http://www.TeXmacs.org/joris/main/joris.html&lt;/a&gt; , &lt;strong&gt;prof@X&lt;/strong&gt;)   &lt;/li&gt;
&lt;li&gt;官网: &lt;a href="http://TeXmacs.org/tmweb/home/welcome.en.html"&gt;http://TeXmacs.org/tmweb/home/welcome.en.html&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;在官网上有两个短视频, 介绍了TeXmacs的简单用法: &lt;a href="http://TeXmacs.org/tmweb/home/videos.en.html"&gt;http://TeXmacs.org/tmweb/home/videos.en.html&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;我自己感觉写同样的内容, 比如写同样一页纸的数学推导, 用TeXmacs大概比LaTeX快10倍... 另外如果你发现这一页纸的推导中间有一步有错误要修改的话...那么TeXmacs大概要快100倍吧...   &lt;/p&gt;
&lt;p&gt;最早听到TeXmacs的名字是看到过王垠的一篇&lt;a href="http://www.yinwang.org/blog-cn/2012/09/18/texmacs/"&gt;博客&lt;/a&gt;, 后来我惊奇地发现TeXmacs的作者居然是X的一位老师!! 所以更要高举安利TeXmacs的大旗了. btw, 在X三年时间, 除了我自己和被我安利的Manu同学, 并没有见有别人用TeXmacs...唉.  &lt;/p&gt;
&lt;h2&gt;0.2 LaTeX吐槽&lt;/h2&gt;
&lt;p&gt;正式安利TeXmacs之前, 先这里举一些我不认为LaTeX可以让人高效编辑文章的原因, 如果你认同大部分下面的吐槽, 欢迎继续阅读本文.   &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;重申一遍, &lt;em&gt;markup的语法不是让人看的&lt;/em&gt;: 要是忘记一个大括号或者少了个反斜杠就编译出错找半天  &lt;/li&gt;
&lt;li&gt;请问每个tex文件开头那十来行usepackage什么的谁能记住?... 我每次要么上网搜要么从以前的tex文件里抄过来...  &lt;/li&gt;
&lt;li&gt;公式是最痛苦的: 好几行的数学推导, 然后每行的内容又差不多的话, 编辑起来眼快瞎了  &lt;/li&gt;
&lt;li&gt;想要插入个截图还得先保存为图片文件(&amp;amp;还得费时间起个文件名): 就不能像word那样直接粘贴进去么? 另外图片的大小和位置也要试好几次才知道怎么合适  &lt;/li&gt;
&lt;li&gt;一编译生成一些乱七八糟的东西: xx.aux什么的, 写篇小文章也得专门建立个文件夹放这些乱七八糟的东西  &lt;/li&gt;
&lt;li&gt;LaTeX号称可以让人专心文章内容不关心排版, 可实际情况却是我每写一小段就会重新编译生成pdf看看, 因为我生怕少写一个花括号导致又编译不成了  &lt;/li&gt;
&lt;li&gt;有时为了用一个包只好安装整个texlive-full, 电脑空间瞬间少了1G...   &lt;/li&gt;
&lt;li&gt;还有什么欢迎补充...  &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;0.3 TeXmacs优点一览&lt;/h2&gt;
&lt;p&gt;TeXmacs的优点大概是以下几点:   &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;数学编辑功能非常强大, 用了再也不想用LaTeX源码写数学公式  &lt;/li&gt;
&lt;li&gt;所见即所得, 不必记忆LaTeX各种tag, 有了它完全可以不用学LaTeX  &lt;/li&gt;
&lt;li&gt;插入图片可以直接嵌入tm文件(其实是把图片序列化为一个很长的字符串), 不再需要为了插图专门建立文件夹  &lt;/li&gt;
&lt;li&gt;TeXmacs体积很小: 我用的版本解压后只有66MB  &lt;/li&gt;
&lt;li&gt;可以从tex文件导入或导出到tex文件  &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;0.4 TeXmacs适合什么样的任务?&lt;/h2&gt;
&lt;p&gt;目前为止我个人使用TeXmacs写过两篇比较正式的报告(其中一篇见&lt;a href="https://github.com/X-Wei/INF580_HashCode2014/blob/master/documentation_Orsini%26Wei.pdf"&gt;这里&lt;/a&gt;), 另外用它写过一些课程的简单报告和作业, 还用它进行过一些数学的推导或者记笔记. &lt;br /&gt;
个人感觉以下任务都可以用TeXmacs高效完成:   &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;各种正式的学术报告  &lt;/li&gt;
&lt;li&gt;常见的论文(TeXmacs里面内建了很多conf的文章style可以选择)  &lt;/li&gt;
&lt;li&gt;课堂记数学笔记(前提是打字速度快, 最好能盲打)  &lt;/li&gt;
&lt;li&gt;简单公式推导, 新建个tm文件就可以开始了, 不用兴师动众新建个文件夹...   &lt;/li&gt;
&lt;li&gt;好像也可以用来做ppt (beamer), 个人没有尝试过  &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;0.5 TeXmacs不适合什么样的任务?&lt;/h2&gt;
&lt;p&gt;我觉得TeXmacs不适合的就是LaTeX强迫症用户的任务...   &lt;/p&gt;
&lt;h1&gt;1. 基本操作&lt;/h1&gt;
&lt;h2&gt;1.1 界面&lt;/h2&gt;
&lt;p&gt;打开TeXmacs可以看到如下的用户界面: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image001.png" /&gt;&lt;br /&gt;
正文上方有四行菜单栏:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一行是常见的菜单, 提供了所有功能  &lt;/li&gt;
&lt;li&gt;第二行是一些常用操作: 打开/保存/复制粘贴/前进后退等  &lt;/li&gt;
&lt;li&gt;第三行是插入一些常见"&lt;strong&gt;环境&lt;/strong&gt;"的快捷按钮, 后面会看到.  &lt;/li&gt;
&lt;li&gt;第四行非常有用, 它叫做"&lt;strong&gt;上下文菜单&lt;/strong&gt;", 它的内容会随着光标所在"&lt;strong&gt;环境&lt;/strong&gt;"而变化. 由于现在光标处在最开始位置, 此时上下文菜单是各种文章显示的选项, 可以选择一个style模板, 调整字体, 页面设置以及文章语言等.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在正文下面, 窗口最底下还有一行:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;右下角指示当前光标所在处的"&lt;strong&gt;环境&lt;/strong&gt;", 可以理解为当前光标处在什么tex的tag里面, 例如公式环境/表格环境/斜体字环境等, 在编辑的时候可以注意一下右下角的显示. 另外一般处在某种环境下面的话, 该环境会由矩形边框标出.   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1.2 插入标题&lt;/h2&gt;
&lt;p&gt;点击&lt;em&gt;上下文菜单&lt;/em&gt;右边的"Title"按钮可以加入文章标题, 敲回车可以输入作者名: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image002.png" /&gt;&lt;br /&gt;
注意此时光标处于"标题"环境下, 所以&lt;em&gt;上下文菜单&lt;/em&gt;是关于标题的功能按钮, 点击"Title"右边的加号可以加入其他信息:&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image003.png" /&gt;&lt;br /&gt;
texmac也支持简单的tex标记, 比如要加入日期的话 除了用上面的菜单, 也可以输入&lt;code&gt;\date&lt;/code&gt;然后敲两次回车即可:&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image004.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;1.3 插入概述&lt;/h2&gt;
&lt;p&gt;从"标题"环境出来 又回到了整个文章的环境,&lt;em&gt;上下文菜单&lt;/em&gt;也改变了&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image006.png" /&gt;&lt;br /&gt;
此时&lt;em&gt;上下文菜单&lt;/em&gt;右边是一个abstract按钮, 因为TeXmacs猜测我们在输入标题以后会输入概述, 点击这个按钮即可进入概述环境(见右下角).&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image007.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;1.4 插入章节&lt;/h2&gt;
&lt;p&gt;从abstract环境出来, 插入一个章节(tex里的&lt;code&gt;\section&lt;/code&gt;标记)有三种办法:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;办法一: 使用第一行的菜单  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="TeXmacs_intro/pasted_image008.png" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;办法二: 使用第二行的"插入章节"图标  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="TeXmacs_intro/pasted_image009.png" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;办法三: 直接用tex标记, 输入&lt;code&gt;\section&lt;/code&gt;然后回车即可  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="TeXmacs_intro/pasted_image010.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;1.5 选择样式&lt;/h2&gt;
&lt;p&gt;在最外层环境下的上下文菜单里可以选择文章样式. &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image031.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;1.6 插入列表&lt;/h2&gt;
&lt;p&gt;在第二行有个按钮可以直接插入列表, 或者也可以输入&lt;code&gt;\itemize&lt;/code&gt;然后回车. &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image011.png" /&gt;&lt;br /&gt;
光标在列表环境时可以看到上下文菜单的内容也变化了:&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image012.png" /&gt;&lt;br /&gt;
这里再介绍一个非常实用的快捷键: &lt;code&gt;ctrl-tab&lt;/code&gt;, 作用是改变当前环境的显示样式, 比如在列表环境里按下&lt;code&gt;ctrl-tab&lt;/code&gt;以后可以变成其他样式(圆点变为了横线). 这个快捷键在公式或者表格环境里也很常用. 按下多次&lt;code&gt;ctrl-tab&lt;/code&gt;可以在各种样式中循环. &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image013.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;1.7 常见文字格式: 粗体/斜体/等宽/下划线/超链接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;粗体和斜体可以像word一样使用&lt;code&gt;ctrl-b/ctrl-i&lt;/code&gt;做到  &lt;/li&gt;
&lt;li&gt;等宽可以用第三行的工具栏按钮, 或者输入&lt;code&gt;\texttt&lt;/code&gt;加回车.   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下划线我没有找到按钮, 不过直接用&lt;code&gt;\underline&lt;/code&gt;加回车即可搞定.&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image014.png" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超链接使用第三行按钮即可  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="TeXmacs_intro/pasted_image016.png" /&gt;&lt;br /&gt;
在hyperlink环境下(注意上下文菜单又变化了)输入两个参数: 链接文本和链接地址, 然后回车即可&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image015.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;1.8 定理/算法等&lt;/h2&gt;
&lt;p&gt;插入一个定理或者算法, 可以直接用第三行的按钮, 看图: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image017.png" /&gt;&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image018.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;1.9 打开多个文件/退出TeXmacs&lt;/h2&gt;
&lt;p&gt;如果打开了多个tm文件, 使用主菜单的Go按钮在文件之间切换: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image045.png" /&gt;&lt;br /&gt;
当前改动没有保存的时候, 标题栏的文件名后面会有一个星号指示. 此时直接点击关闭的话, 会在最下方有个提示框: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image044.png" /&gt;  &lt;/p&gt;
&lt;h1&gt;2. 数学公式&lt;/h1&gt;
&lt;p&gt;这是TeXmacs最激动人心的功能, 用它编辑数学公式非常畅快~   &lt;/p&gt;
&lt;h2&gt;2.1 公式环境&lt;/h2&gt;
&lt;p&gt;首先为了进入数学公式环境, 可以直接输入&lt;code&gt;$&lt;/code&gt;或者&lt;code&gt;alt-$&lt;/code&gt;, &lt;code&gt;alt-&amp;amp;&lt;/code&gt;(对应行内公式/单行公式/多行公式). &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image019.png" /&gt;&lt;br /&gt;
这里说一下, 个人感觉英文界面的一些词汇比如formula/equation, table/tabular, 傻傻分不清楚, formula和equation的区别在于, equation是多行公式... 把tm换成中文界面的话这些名字好理解多了: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image020.png" /&gt;&lt;br /&gt;
另外, 切换行内/单行公式也可以用&lt;code&gt;ctrl-tab&lt;/code&gt;快捷键.   &lt;/p&gt;
&lt;p&gt;在进入公式环境以后, 注意不止第四行的上下文菜单变成了公式的按钮, 第三行的插入菜单也变为了插入符号的按钮:&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image021.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;2.2 输入数学符号&lt;/h2&gt;
&lt;p&gt;这是我觉得TeXmacs最爽的地方: 公式环境下(注意是&lt;em&gt;在公式环境下&lt;/em&gt;), &lt;strong&gt;形状相似的符号通过tab轮转&lt;/strong&gt;. &lt;br /&gt;
例子:   &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;字母α和字母a形状很像, 输入字母&lt;code&gt;a&lt;/code&gt;以后直接tab即可变为α.  &lt;/li&gt;
&lt;li&gt;⊗怎么输入呢? 它等于&lt;code&gt;@-x&lt;/code&gt;, 同理⊕等于&lt;code&gt;@-+&lt;/code&gt;, ∞等于&lt;code&gt;@@&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;∈像什么? 只要输入&lt;code&gt;&amp;lt;&lt;/code&gt;然后多tab几次就看到了  &lt;/li&gt;
&lt;li&gt;不等号≠怎么输入? 直接连续打&lt;code&gt;= /&lt;/code&gt;即可  &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;遇到别的不会打的字符, 可以用第三行的按钮, 鼠标悬停可以显示相应快捷键: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image022.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;2.3 其他数学符号: 上下标/根号/分数/积分/求和/...&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;输入上标直接打一个 &lt;code&gt;^&lt;/code&gt;即可, 下标是 &lt;code&gt;_&lt;/code&gt;, 和LaTeX里面一样 — 只不过不用看让人眼晕的源码.  &lt;/li&gt;
&lt;li&gt;符号上标下标(不是右上角而是正上正下): 用&lt;code&gt;alt-a/alt-b&lt;/code&gt;(above/below)  &lt;/li&gt;
&lt;li&gt;输入根号快捷键是&lt;code&gt;alt-s&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;输入分数快捷键是&lt;code&gt;alt-f&lt;/code&gt;(再&lt;code&gt;ctrl-tab&lt;/code&gt;可以切换分数线的大小)  &lt;/li&gt;
&lt;li&gt;积分号可以用按钮插入, 或者直接&lt;code&gt;\int&lt;/code&gt;回车  &lt;/li&gt;
&lt;li&gt;求和号同理, 可以直接输入&lt;code&gt;\sum&lt;/code&gt;回车  &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;...LaTeX和这比起来简直就是石器时代!  &lt;/p&gt;
&lt;p&gt;总结一下: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image026.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;2.4 公式编号/引用公式&lt;/h2&gt;
&lt;p&gt;公式加入编号非常简单, 用上下文菜单里的一个"IV"按钮. &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image023.png" /&gt;&lt;br /&gt;
如果对一个公式进行索引的话, 可以直接用tex里的&lt;code&gt;label/ref&lt;/code&gt;标签完成.&lt;br /&gt;
首先给这个公式加一个label, 只需要输入&lt;code&gt;\label&lt;/code&gt;, 回车后输入参数(label名字)再回车即可. &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image024.png" /&gt;&lt;br /&gt;
然后要引用这个公式时, 只需要输入&lt;code&gt;\ref&lt;/code&gt;加刚才指定的label即可: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image025.png" /&gt;&lt;br /&gt;
以后对于图片/表格的引用也是同样道理.   &lt;/p&gt;
&lt;p&gt;关于多行公式, 先要介绍表格的使用, 请看下节.   &lt;/p&gt;
&lt;h1&gt;3. 表格&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="TeXmacs_intro/pasted_image027.png" /&gt;&lt;br /&gt;
像上面这个公式的输入方法, 就是在大括号右边使用一个两行一列的表格.   &lt;/p&gt;
&lt;h2&gt;3.1 表格环境&lt;/h2&gt;
&lt;p&gt;插入表格只需点击第三行的表格按钮:&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image028.png" /&gt;&lt;br /&gt;
那些词汇也傻傻分不清楚, 倒是中文界面说的很清楚: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image029.png" /&gt;&lt;br /&gt;
不过这些表格样式也是可以通过&lt;code&gt;ctrl-tab&lt;/code&gt;快捷键轮转切换的. &lt;br /&gt;
点击以后进入表格环境, 注意上下文菜单的按钮又变了: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image030.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;3.2 增加/删除行和列&lt;/h2&gt;
&lt;p&gt;在表格环境的上下文菜单里, 那八个中间是加号或叉号的方向按钮就是向各个方向新建/删除一行/一列的. &lt;br /&gt;
或者使用快捷键: &lt;code&gt;win-方向键&lt;/code&gt;可以在当前格子的各个方向新建行/列, &lt;code&gt;win-backspace&lt;/code&gt;则是删除.   &lt;/p&gt;
&lt;h2&gt;3.3 对齐模式&lt;/h2&gt;
&lt;p&gt;改变表格的对齐模式只要选中相应的格子然后用上下文菜单的按钮点选即可: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image032.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;3.4 矩阵&lt;/h2&gt;
&lt;p&gt;输入矩阵的话, 可以&lt;em&gt;在公式环境下&lt;strong&gt;&lt;em&gt;嵌套&lt;/em&gt;&lt;/strong&gt;一个表格环境&lt;/em&gt;. &lt;br /&gt;
首先输入&lt;code&gt;alt-$&lt;/code&gt;进入公式环境, 此时再看表格按钮的时候出现了矩阵选项: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image033.png" /&gt;&lt;br /&gt;
然后只需要像之前表格一样操作即可了, 关于如何输入各个方向的省略号, 只要多tab几次就可以了: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image034.png" /&gt;  &lt;/p&gt;
&lt;p&gt;以上我觉得基本够用了, 关于表格的其他的功能可以参考tm的文档...   &lt;/p&gt;
&lt;h1&gt;4. 插图&lt;/h1&gt;
&lt;p&gt;关于插图我使用最多的只是截图然后直接从剪切板里粘贴而已, 这里只介绍这种最简单最常用操作. &lt;br /&gt;
TeXmacs实际上远比我这里介绍的强大, 见这里: &lt;a href="http://www.TeXmacs.org/tmweb/documents/tutorials/TeXmacs-graphical-plugins.pdf"&gt;http://www.TeXmacs.org/tmweb/documents/tutorials/TeXmacs-graphical-plugins.pdf&lt;/a&gt;  &lt;/p&gt;
&lt;h2&gt;4.1 图片环境&lt;/h2&gt;
&lt;p&gt;点击按钮插入图片&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image035.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;4.2 插入截图&lt;/h2&gt;
&lt;p&gt;截图在clipboard的时候, 只需要在TeXmacs里面粘贴就可以了: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image036.png" /&gt;  &lt;/p&gt;
&lt;p&gt;我想要强调的一点是, 用这种方法画图, 可以直接把图片嵌入tm文件里面, 而不用像LaTeX一样在文件夹里放一堆图片.   &lt;/p&gt;
&lt;h2&gt;4.3 画图&lt;/h2&gt;
&lt;p&gt;TeXmacs也提供了直接画图的功能, 不过我基本没试过, 下图是乱画的:&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image037.png" /&gt;  &lt;/p&gt;
&lt;p&gt;另外, 关于如何引用图片/表格, 只要用&lt;code&gt;\label&lt;/code&gt;和&lt;code&gt;\ref&lt;/code&gt;标签即可, 前面公式环境里已经介绍过了.   &lt;/p&gt;
&lt;h1&gt;5. 插入目录/参考文献&lt;/h1&gt;
&lt;h2&gt;5.1 插入目录&lt;/h2&gt;
&lt;p&gt;首先点击第三行的按钮插入目录: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image038.png" /&gt;&lt;br /&gt;
但是这是的目录是空的, 还需要更新目录, 方法是第一行的菜单: &lt;em&gt;document → update → table of content&lt;/em&gt;&lt;br /&gt;
然后就看到了目录: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image039.png" /&gt;  &lt;/p&gt;
&lt;h2&gt;5.2 参考文献&lt;/h2&gt;
&lt;h3&gt;bibtex文件&lt;/h3&gt;
&lt;p&gt;首先, 为了引入参考文献, 需要建立一个&lt;em&gt;demo.bib&lt;/em&gt;文件, 里面放的就是参考文献的bibtex代码, 比如:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;@ARTICLE{lda,  
    author = {David M. Blei and Andrew Y. Ng and Michael I. Jordan and John Lafferty},  
    title = {Latent Dirichlet Allocation},  
    journal = {The Journal of Machine Learning Research},  
    year = {2003}  
}  
@article{nmf,  
     author = &amp;quot;Yehuda Koren and Robert Bell and Chris Volinsky&amp;quot;,   
     title = &amp;quot;Matrix Faoctorization Techniques for Recommender Systems&amp;quot;,  
     journal = &amp;quot;IEEE Computer&amp;quot;,    
     pages = &amp;quot;42--49&amp;quot;,   
     year = &amp;quot;2009&amp;quot;,  
    }  
@book{pci,  
    title = &amp;quot;Programming Collective Intelligence: Building Smart Web 2.0 Applications&amp;quot;,  
    author = &amp;quot;Toby Segaran&amp;quot;,  
    year = &amp;quot;2007&amp;quot;,  
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意每一个entry的别名(&lt;em&gt;lda, nmfCF, pci&lt;/em&gt;)是我自己取的.   &lt;/p&gt;
&lt;h3&gt;插入参考文献&lt;/h3&gt;
&lt;p&gt;点击按钮插入参考文献:&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image041.png" /&gt;&lt;br /&gt;
然后在最下方的提示框输入样式名(一般就用默认tm-plain)以及bib文件名(和tm文件同一目录下): &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image042.png" /&gt;  &lt;/p&gt;
&lt;p&gt;在引用文献时可以用tex标签&lt;code&gt;\cite&lt;/code&gt;引用文献:&lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image040.png" /&gt;&lt;br /&gt;
TeXmacs不会在最后参考文献里显示没有被引用过的文献, 那些没有显式提到的文章可以用插入invisible citation的方式加入: &lt;br /&gt;
&lt;img alt="" src="TeXmacs_intro/pasted_image043.png" /&gt;&lt;br /&gt;
注意, 此时需要update&lt;strong&gt;两次&lt;/strong&gt;才可以看到效果.  &lt;/p&gt;
&lt;h1&gt;6. 更多&lt;/h1&gt;
&lt;p&gt;这里只是介绍了最基础最简单的使用, 关于更多的高级TeXmacs使用方法, 这里有几个链接:   &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;tm官方的tutorial: &lt;a href="http://TeXmacs.org/tmweb/help/manual.en.html"&gt;http://TeXmacs.org/tmweb/help/manual.en.html&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;一些其他人做的文章: &lt;a href="http://TeXmacs.org/tmweb/help/tutorial.en.html"&gt;http://TeXmacs.org/tmweb/help/tutorial.en.html&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;王垠大神做的思维导图: &lt;a href="https://www.mindomo.com/mindmap/b207992c90c046bdbe4053cbdf88b5d5"&gt;https://www.mindomo.com/mindmap/b207992c90c046bdbe4053cbdf88b5d5&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;tm官网有个workshop的视频 里面展示了texmac一些亮瞎眼的功能: &lt;a href="http://magix.lix.polytechnique.fr/magix/workshop/workshop-videos.en.html"&gt;http://magix.lix.polytechnique.fr/magix/workshop/workshop-videos.en.html&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外, 这篇文章所做的示例文件可以在这里下载: &lt;a href="https://github.com/X-Wei/texmacs-demo"&gt;https://github.com/X-Wei/texmacs-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎抛弃LaTeX &amp;amp; 拥抱TeXmacs!  &lt;/p&gt;</summary><category term="tex"></category><category term="TeXmacs"></category></entry><entry><title>[Algorithms II] Week 3-1 Maximum Flow</title><link href="http://x-wei.github.io/algoII_week3_1.html" rel="alternate"></link><updated>2015-11-17T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoII_week3_1.html</id><summary type="html">&lt;h1&gt;1. Introduction to Maxflow&lt;/h1&gt;
&lt;h3&gt;Min-cut pb&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;input: edge-weighted digraph G, each edge &lt;code&gt;e&lt;/code&gt; has weight(&lt;em&gt;"capacity"&lt;/em&gt;) &lt;code&gt;c[e]&lt;/code&gt;&amp;gt;=0, a &lt;em&gt;source vertex&lt;/em&gt; &lt;code&gt;s&lt;/code&gt;, a &lt;em&gt;target vertex&lt;/em&gt; &lt;code&gt;t&lt;/code&gt;.    &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;def&lt;/strong&gt;. an &lt;strong&gt;st-cut &lt;/strong&gt;&lt;code&gt;(A,B)&lt;/code&gt; is a partition of vertices into 2 disjoint sets A and B, with &lt;code&gt;s&lt;/code&gt; in set &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; in set &lt;code&gt;B&lt;/code&gt;.    &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;def&lt;/strong&gt;. the &lt;strong&gt;capacity&lt;/strong&gt; of a cut &lt;code&gt;(A,B)&lt;/code&gt; is sum of capacities of edges going &lt;em&gt;from A to B&lt;/em&gt; &lt;em&gt;(not considering B to A)&lt;/em&gt;.    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week3_1/pasted_image.png" /&gt; &lt;br /&gt;
⇒ min-cut pb: find the cut &lt;strong&gt;(A,B)&lt;/strong&gt; with min-capacity.    &lt;/p&gt;
&lt;h3&gt;Max-flow pb&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;same input: graph G, source s, target t   &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;def.&lt;/strong&gt; an &lt;strong&gt;st-flow&lt;/strong&gt; is an assignment of values to edges &lt;code&gt;f: e→f[e]&lt;/code&gt; such that:    &lt;ul&gt;
&lt;li&gt;capacity constraint: &lt;code&gt;0&amp;lt;=f[e]&amp;lt;=c[e]&lt;/code&gt; for any e;   &lt;/li&gt;
&lt;li&gt;local equilibrium: for any vertex v (other than s or t), &lt;em&gt;inflow=outflow&lt;/em&gt;;   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;def.&lt;/strong&gt; the &lt;strong&gt;value&lt;/strong&gt; of a flow &lt;code&gt;f&lt;/code&gt; is the inflow at &lt;code&gt;t&lt;/code&gt;. (assume no ingoing edge to s or outgoing edge to t)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week3_1/pasted_image001.png" /&gt; &lt;br /&gt;
⇒ max-flow pb: find &lt;code&gt;f&lt;/code&gt; with max value.    &lt;/p&gt;
&lt;p&gt;remark: max-flow and min-cut are dual problems.    &lt;/p&gt;
&lt;h1&gt;2. Ford-Fulkerson Algorithm&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;def.&lt;/strong&gt; given a flow &lt;code&gt;f&lt;/code&gt; for a graph, an &lt;strong&gt;"augment path"&lt;/strong&gt; is an &lt;strong&gt;undirected&lt;/strong&gt; path form &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;, if there exist &lt;code&gt;df&amp;gt;0&lt;/code&gt; (&lt;em&gt;"bottleneck capacity"&lt;/em&gt;) such that:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for forward edges e: can augment flow by &lt;code&gt;df&lt;/code&gt; (not full: &lt;code&gt;f[e]+df&amp;lt;=c[e]&lt;/code&gt;)   &lt;/li&gt;
&lt;li&gt;for backward edges: can decrease flow by &lt;code&gt;df&lt;/code&gt; (not empty: &lt;code&gt;f[e]-df&amp;gt;=0&lt;/code&gt;)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week3_1/pasted_image002.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;def. &lt;strong&gt;residual capacity&lt;/strong&gt;   &lt;ul&gt;
&lt;li&gt;for forward edge e, &lt;em&gt;residual-cap = c[e]-f[e]&lt;/em&gt;   &lt;/li&gt;
&lt;li&gt;for backward edge e, &lt;em&gt;residual-cap = f[e]&lt;/em&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⇒ an aug-path is a path where &lt;em&gt;each edge has residual capacity &amp;gt;0&lt;/em&gt;.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;blocking edges&lt;/strong&gt;: &lt;em&gt;full forward edge&lt;/em&gt; or &lt;em&gt;empty backward edge.&lt;/em&gt;   &lt;/p&gt;
&lt;p&gt;→ idea: increase flow along augment paths. &lt;br /&gt;
&lt;strong&gt;[algo]&lt;/strong&gt;   &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;start: 0 flow: &lt;code&gt;f[e]=0&lt;/code&gt; for all e.    &lt;/li&gt;
&lt;li&gt;find an augment path (and the corresponding &lt;code&gt;df&lt;/code&gt;) in graph, and change the flows along the path by &lt;code&gt;+/-df&lt;/code&gt;.   &lt;/li&gt;
&lt;li&gt;loop until no augment path exists. (ie. all path s→t are blocked either by a &lt;em&gt;full forward edge&lt;/em&gt; or an &lt;em&gt;empty backward edge, &lt;/em&gt;ie. by an edge with 0 residual capacity)   &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week3_1/pasted_image003.png" /&gt;   &lt;/p&gt;
&lt;p&gt;FF is a gernel algorithm:  &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image004.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;3. Maxflow-Mincut Theorem&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;def&lt;/strong&gt;. for a cut (A,B), the &lt;strong&gt;net flow&lt;/strong&gt; across the cut (&lt;em&gt;netflow(A,B)&lt;/em&gt;) is the sum of flows from A to B minus flows from B to A.    &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[flow-value Lemma]&lt;/strong&gt;  &lt;br /&gt;
For any flow &lt;code&gt;f&lt;/code&gt; and any cut &lt;code&gt;(A,B)&lt;/code&gt;⇒  &lt;em&gt;netflow(A,B) = value(f).&lt;/em&gt;  &lt;br /&gt;
&lt;em&gt;pf.&lt;/em&gt;  &lt;br /&gt;
induction on the size of set B. &lt;br /&gt;
&lt;em&gt; base case, when B={t}, by def we have &lt;/em&gt;netflow(A,B) = value(f)&lt;em&gt; &lt;br /&gt;
&lt;/em&gt; when moving any vertex v from A to B: &lt;br /&gt;
    * netflow(A, B) augment by &lt;em&gt;flow(A→v)+flow(B→v)=inflow(v)&lt;/em&gt;,  &lt;br /&gt;
    * netflow(A, B) decrease by &lt;em&gt;flow(v→A)+flow(v→B)=outflow(v)&lt;/em&gt;,  &lt;br /&gt;
    * by equilibrium of flow, &lt;em&gt;netflow(A',B')=netflow(A,B)=value(f)&lt;/em&gt;   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ex. (A: gray vertices, B: white vertices) &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;p&gt;[cor] &lt;em&gt;outflow(s)=inflow(t)=value(f)&lt;/em&gt;   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[weak duality]&lt;/strong&gt; &lt;br /&gt;
For &lt;em&gt;any&lt;/em&gt; flow &lt;code&gt;f&lt;/code&gt; and &lt;em&gt;any&lt;/em&gt; cut &lt;code&gt;(A,B)&lt;/code&gt;, ⇒ &lt;em&gt;value(f) &amp;lt;= capacity(A,B).&lt;/em&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[Augmenting path Th]&lt;/strong&gt;  &lt;br /&gt;
A flow &lt;code&gt;f&lt;/code&gt; is maxflow &lt;em&gt;iff&lt;/em&gt; there is no augment path.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[maxflow-mincut Th]&lt;/strong&gt; &lt;br /&gt;
&lt;strong&gt;value(maxflow) = capacity(mincut).&lt;/strong&gt;   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;pf.&lt;/em&gt; &lt;br /&gt;
for any flow &lt;code&gt;f&lt;/code&gt;, prove the equivalence of the 3 following statements: &lt;br /&gt;
i. there exists a cut st: &lt;em&gt;capacity(cut) = value(f).&lt;/em&gt; &lt;br /&gt;
ii. &lt;code&gt;f&lt;/code&gt; is a maxflow. &lt;br /&gt;
iii. there is no augmenting path wrt &lt;code&gt;f&lt;/code&gt;.   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[i⇒ii]   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;suppose cut(A,B) st: &lt;em&gt;capacity(A,B)=value(f)&lt;/em&gt; &lt;br /&gt;
⇒ by weak duality, for any other flow f', &lt;em&gt;vlaue(f')&amp;lt;=capacity(A,B)=value(f)&lt;/em&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[ii⇒iii] (eqv to prove ~iii⇒~ii)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;suppose there is an aug-path from s to t, of bottleneck capacity=df, &lt;br /&gt;
⇒ by improving f with df, we get a f' &amp;gt; f   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[iii⇒i]   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;suppose there is no aug-path, ie, &lt;em&gt;all path from s to t are blocked by some full-forward edge or empty backward edge.&lt;/em&gt; &lt;br /&gt;
⇒ let A:=vertices connected with s by a path with no blocking edges, and B := the rest &lt;br /&gt;
(&lt;em&gt;so&lt;/em&gt; &lt;em&gt;once we get a maxflow, we can &lt;strong&gt;&lt;em&gt;compute the mincut&lt;/em&gt;&lt;/strong&gt; in this way&lt;/em&gt;) &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image006.png" /&gt; &lt;br /&gt;
→ for all edges across A and B, all forward edges are full, all backward edges are empty &lt;br /&gt;
⇒ capacity(A,B) = netflow(A,B) = value(f) by flow-value lemma &lt;br /&gt;
CQFD... 过瘾...   &lt;/p&gt;
&lt;h1&gt;4. Running Time Analysis&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week3_1/pasted_image007.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;getting a mincut form maxflow? → easy (as discussed in the pf above)   &lt;/li&gt;
&lt;li&gt;computing an aug-path? → &lt;strong&gt;BFS&lt;/strong&gt;   &lt;/li&gt;
&lt;li&gt;does FF algo always terminate? how many augmentations? → ...   &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;integer capacity graphs&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;special case of FF algo&lt;/em&gt;: edge capacities are &lt;em&gt;integers&lt;/em&gt; between 1 and U.    &lt;/p&gt;
&lt;p&gt;invariant: flow is always integer all along FF algo.   &lt;/p&gt;
&lt;p&gt;[prop] nb of augmentations &amp;lt;= value of maxflow. &lt;br /&gt;
pf. each augmentation will add flow by &amp;gt;=1.    &lt;/p&gt;
&lt;p&gt;[integrality Th] There exist an integer-valued maxflow.    &lt;/p&gt;
&lt;h3&gt;Bad case for FF&lt;/h3&gt;
&lt;p&gt;nb of augmentation == value of maxflow &lt;br /&gt;
(each time, the path through the middle edge is chosen as aug-path) &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image008.png" /&gt; &lt;br /&gt;
&lt;strong&gt;can be easily avoided&lt;/strong&gt;⇒  by using shortest(nb of edges)/fastest(biggest df) path  &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image010.png" /&gt;   &lt;/p&gt;
&lt;p&gt;Performance of FF depends on the algo for choosing aug-path: &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image009.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;5. Java Implementation&lt;/h1&gt;
&lt;h3&gt;representation of flow graph&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;flow edge:   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;each e= v→w, have flow f[e] and capacity c[e].   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flow graph:   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;put e in both v and w's adj-list.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flow augmentation (by delta)   &lt;ul&gt;
&lt;li&gt;for forward edge e, f[e] += delta   &lt;/li&gt;
&lt;li&gt;for backward edge e, f[e] -= delta   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Residual graph Gr&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;def&lt;/strong&gt;. For a flow &lt;code&gt;f&lt;/code&gt; and a graph &lt;code&gt;G&lt;/code&gt;,  the &lt;strong&gt;residual graph&lt;/strong&gt; &lt;code&gt;Gr&lt;/code&gt; is obtained by:   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;for each edge &lt;code&gt;e=v→w&lt;/code&gt;, (with &lt;code&gt;c[e]&lt;/code&gt; and &lt;code&gt;f[e]&lt;/code&gt;) in &lt;code&gt;G&lt;/code&gt;, put in &lt;code&gt;Gr&lt;/code&gt;: &lt;br /&gt;
&lt;em&gt; &lt;code&gt;e1=v→w&lt;/code&gt;, with weight=&lt;code&gt;c[e]-f[e]&lt;/code&gt; &lt;br /&gt;
&lt;/em&gt; &lt;code&gt;e2=w→v&lt;/code&gt;, with weight=&lt;code&gt;f[e]&lt;/code&gt; (即两个方向上的weight都为residual capacity)   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(rmq: &lt;code&gt;Gr&lt;/code&gt; is just a weighted digraph, not a flow graph)   &lt;/p&gt;
&lt;p&gt;[prop] &lt;strong&gt;Augment path in &lt;/strong&gt;&lt;code&gt;G&lt;/code&gt;&lt;strong&gt; is equivalent to a path in &lt;/strong&gt;&lt;code&gt;Gr&lt;/code&gt; (&lt;code&gt;df&lt;/code&gt; of aug-path in &lt;code&gt;G&lt;/code&gt; = min edge weight in &lt;code&gt;Gr&lt;/code&gt;)&lt;strong&gt;.&lt;/strong&gt; &lt;br /&gt;
(但是实现的时候其实不用显式构造Gr, 只需BFS的时候修改一下即可) &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image011.png" /&gt;   &lt;/p&gt;
&lt;h3&gt;APIs&lt;/h3&gt;
&lt;p&gt;这里的API设计的非常合理... 导致每一部分的代码量都不大... NB   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;flow-edge:  &lt;br /&gt;
rmq. both calculate residual-cap and augmentation need to specify a &lt;em&gt;direction&lt;/em&gt;, so we need a index v as parameter for these 2 functions.    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class FlowEdge{   
    private final int v, w;   
    private final double capacity;   
    private double flow=0.0;   
    FlowEdge(int v, int w, double cap);   
    int from();   
    int to();   
    int other(int v);   
    double capacity();   
    double flow();   
    double residualCapTo(int v);// residual capacity   
    void addFlowTo(int v, double delta);// augment residual flow   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flow graph:  &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class FlowNetwork{   
    private Bag&amp;lt;FlowEdge&amp;gt;[] adj;//use adj-list representation for flow graph   
    FlowNetwork(int V);   
    void addEdge(FlowEdge e);   
    Iterable&amp;lt;FlowEdge&amp;gt; adj(int v);// both incoming and outgoing edges   
    ...   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FF algo:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use a function &lt;code&gt;hasAugPath()&lt;/code&gt; to test termination   &lt;/li&gt;
&lt;li&gt;use a function &lt;code&gt;bottleNeck()&lt;/code&gt; to get delta   &lt;/li&gt;
&lt;li&gt;if a augpath is found, use two arrays &lt;code&gt;reached[]&lt;/code&gt; and &lt;code&gt;edgeTo[]&lt;/code&gt; to get the augpath (find the path &lt;em&gt;backwards&lt;/em&gt;).    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;code:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class FordFulkerson{   
private boolean[] reached; //reached[v] indicates if a path s--&amp;gt;v exists in Gr, used in DFS   
private FlowEdge[] edgeTo;// edgeTo[v] = last edge on the path s--&amp;gt;v   
private double value=0.0;// value of flow   
public FordFulkerson(FlowNetwork G, int s, int t){   
    while(this.hasAugPath(G,s,t)){   
        double delta = this.bottleNeck();   
        for(int v=t; v!=s; v=edgeTo[v].other(v))   
            edgeTo[v].addFlowTo(v, delta);   
        this.value += delta;// each time the flow value augments by delta   
    }   
}   
private double bottleNeck(){//bottleneck-cap = min residual flow on the aut-path   
    double bottleneck = 9999999;   
    assert(reached[t]);// the aug-path should exsit   
    for(int v=t; v!=s; v = edgeTo[v].other(v))   
        bottleneck = Math.min(bottleneck, edgeTo[v].);   
    return bottleneck;   
}   
private boolean hasAugPath(FlowNetwork G, int s, int t){   
    // perform a BFS    
    Queue&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;Integer&amp;gt;();   
    this.reached = new boolean[G.V()];   
    this.edgeTo = new FlowEdge[G.V()];   
    q.add(s);   
    while(!q.isEmpty()){   
        int v = q.deque();   
        for(FlowEdge e:G.adj(v)){   
            int w = e.other(v);   
            if(!reached[w] &amp;amp;&amp;amp; e.residualCapTo(w)&amp;gt;0){// modified BFS: valid edges are those with  residualCap&amp;gt;0   
                edgeTo[w] = e;   
                reached[w] = true;   
                if(w==t) return true;// t is reached by BFS  
                q.enqueue(w);   
            }   
        }   
    }// BFS while loop    
    return false;   
}   
}//class FF
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;6. Maxflow Applications&lt;/h1&gt;
&lt;p&gt;关键是建模很巧妙... &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image012.png" /&gt;   &lt;/p&gt;
&lt;h3&gt;ex1. bipartite matching pb&lt;/h3&gt;
&lt;p&gt;二分图的最大匹配问题. (有点像marriage stable问题...但是不一样 因为没有preference order) &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image013.png" /&gt; &lt;br /&gt;
⇒ is there a way to match all students to a job? &lt;br /&gt;
ie. &lt;em&gt;given a bipartite graph, find a perfect matching.&lt;/em&gt;  &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image014.png" /&gt; &lt;br /&gt;
&lt;strong&gt;modeling&lt;/strong&gt;   &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;add source &lt;code&gt;s&lt;/code&gt; and target &lt;code&gt;t&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;all edges from &lt;code&gt;s&lt;/code&gt; to students: capacity=1   &lt;/li&gt;
&lt;li&gt;all edges from companies to &lt;code&gt;t&lt;/code&gt;: capacity=1   &lt;/li&gt;
&lt;li&gt;all edges from student to company: capacity=INF   &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;⇒ find maxflow in the graph &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image015.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;when no perfect matching: mincut can explain why&lt;/strong&gt;  &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image016.png" /&gt; &lt;br /&gt;
in the above case, student 2,4,5 can only be matched to 7,10 &lt;br /&gt;
⇒ mincut can help us find such cases!   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;recall: how to get mincut from maxflow&lt;/em&gt;   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mincut = (A,B), where: &lt;br /&gt;
A:=vertices connected with s by a path with non blocking edges,  &lt;br /&gt;
B := the rest &lt;br /&gt;
(&lt;em&gt;blocking edges: full forward edge or empty backward edge on path&lt;/em&gt;)   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ex. &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image017.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;let S=students on s side of mincut (in above case, &lt;em&gt;S={2,4,5}&lt;/em&gt;)   &lt;/li&gt;
&lt;li&gt;let T=companies on s side of mincut (in above case, T&lt;em&gt;={7,10}&lt;/em&gt;)   &lt;/li&gt;
&lt;li&gt;|S|&amp;gt;|T|, that's why no perfect matching!   &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ex2. baseball elimination&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week3_1/pasted_image018.png" /&gt; &lt;br /&gt;
(前三列是目前成绩, 后面四列是接下来赛程矩阵) &lt;br /&gt;
Montreal is mathematically eliminated → easy to see &lt;br /&gt;
→ Philly is mathematically eliminated also !   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;another case:   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week3_1/pasted_image019.png" /&gt; &lt;br /&gt;
Detroit is mathematically eliminated ! &lt;br /&gt;
&lt;img alt="" src="algoII_week3_1/pasted_image020.png" /&gt; &lt;br /&gt;
whether team-4 still has a chance to win? &lt;br /&gt;
&lt;strong&gt;modelling&lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;remaining games flow from s to t.    &lt;/li&gt;
&lt;li&gt;use team-pairs ans teams as vertices   &lt;/li&gt;
&lt;li&gt;&lt;em&gt;carefully chosen capacities&lt;/em&gt;(see below)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week3_1/pasted_image021.png" /&gt; &lt;br /&gt;
⇒ team 4 could win iff all flow from s are full (ie. all match points can be repartitioned over other teams &lt;em&gt;without depassing team 4's maximum wins&lt;/em&gt;). &lt;br /&gt;
总之很巧妙....   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms II] Week 2-2 Shortest Paths</title><link href="http://x-wei.github.io/algoII_week2_2.html" rel="alternate"></link><updated>2015-11-15T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoII_week2_2.html</id><summary type="html">&lt;h1&gt;1. Shortest Paths APIs&lt;/h1&gt;
&lt;p&gt;context: &lt;em&gt;directe, weighted graphs&lt;/em&gt;.     &lt;/p&gt;
&lt;h3&gt;shortest path variants&lt;/h3&gt;
&lt;p&gt;in terms of vertices:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;source-sink: form one vertex to another   &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;single source&lt;/strong&gt;: from one vertex to all others (considered in this lecture)   &lt;/li&gt;
&lt;li&gt;all pairs   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;constraints on edge weights:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nonnegative weights    &lt;/li&gt;
&lt;li&gt;arbitary weights   &lt;/li&gt;
&lt;li&gt;eculidean    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cycles:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no directed cycles   &lt;/li&gt;
&lt;li&gt;no negative cycles   &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;APIs&lt;/h3&gt;
&lt;p&gt;for weighted directed edge:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class DirectedEdge{   
    DirectedEdge(int v, int w, double weight);   
    int from();   
    int to();   
    double weight();   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;for edge-weighted digraph:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class EdgeWeightedDigraph{   
    private final Bag&amp;lt;DirectedEdge&amp;gt;[] adj;    
    EdgeWeightedDigraph(int V);   
    void addEdge(DirectedEdge e);   
    Iterable&amp;lt;DirectedEdge&amp;gt; adj(int v);   
    int V();   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;for single source shortest-path:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class SP{   
    SP(EdgeWeightedDigraph G, int s);//s is the source node   
    double distTo(int v);//dist from s to v   
    Iterable&amp;lt;DirectedEdge&amp;gt; pathTo(int v);// shortest path from s to v   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;2. Shortest path properties&lt;/h1&gt;
&lt;p&gt;goal: single-source shortest path &lt;br /&gt;
&lt;strong&gt;prop&lt;/strong&gt;. a &lt;strong&gt;shortest-path-tree&lt;/strong&gt; (SPT) exists.  &lt;br /&gt;
这个结论以前没见过... 不太evident吧... 没有太想明白 &lt;br /&gt;
&lt;img alt="" src="algoII_week2_2/pasted_image.png" /&gt; &lt;br /&gt;
⇒ consequence: can represent this SPT by 2 vertex-indexted arrays:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;double distTo[v]&lt;/code&gt; = shortest path length s → v   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;DirectedEdge edgeTo[v]&lt;/code&gt; = last edge to v in shortest path, &lt;code&gt;edgeTo[s] = null&lt;/code&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week2_2/pasted_image001.png" /&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private int distTo[] = new int[V];   
private DirectedEdge edgeTo[] = new DirectedEdge[V];   
public double distTo(int v){   
    return this.distTo[v];   
}   
public Iterable&amp;lt;DirectedEdge&amp;gt; pathTo(int v){   
    Stack&amp;lt;DirectedEdge&amp;gt; path = new Stack&amp;lt;DirectedEdge&amp;gt;();   
    for(DirectedEdge e = this.edgeTo[v]; e!=null; e = edgeTo[e.from])   
        path.push(e);   
    return path;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Edge relaxation&lt;/h3&gt;
&lt;p&gt;dynamic prog:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;distTo[v] = length of &lt;strong&gt;known&lt;/strong&gt; shortest path from s to v   &lt;/li&gt;
&lt;li&gt;distTo[w] = length of &lt;strong&gt;known&lt;/strong&gt; shortest path from s to w   &lt;/li&gt;
&lt;li&gt;edgeTo[w] = last edge in the &lt;strong&gt;known&lt;/strong&gt; shortest path form s to w   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(consider edges one by one) &lt;br /&gt;
&lt;strong&gt;def&lt;/strong&gt;. edge e = v--&amp;gt;w &lt;strong&gt;relaxes&lt;/strong&gt; if e.weight+distTo[v] &amp;lt; distTo[w]. → update distTo[w] and edgeTo[w]. &lt;br /&gt;
&lt;img alt="" src="algoII_week2_2/pasted_image003.png" /&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private void relax(DirectedEdge e){   
    int v = e.from(), w = e.to();   
    if(distTo[w]&amp;gt;distTo[v]+e.weight()){   
        distTo[w] = distTo[v]+e.weight();   
        edgeTo[w] = e;   
    }   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;optimality conditions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;prop&lt;/strong&gt;. optimality conditions &lt;br /&gt;
distTo[] is the solution &lt;em&gt;iff&lt;/em&gt;:   &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;distTo[s] = 0   &lt;/li&gt;
&lt;li&gt;distTo[v] is the weight of some path from  s to v   &lt;/li&gt;
&lt;li&gt;for any edge e = v → w, distTo[w] &amp;lt;= distTo[v]+e.weight()   &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Generic algo&lt;/h3&gt;
&lt;p&gt;just relax all edges... &lt;br /&gt;
&lt;img alt="" src="algoII_week2_2/pasted_image004.png" /&gt; &lt;br /&gt;
&lt;strong&gt;prop&lt;/strong&gt;. the above generic algo gives the SPT from s.    &lt;/p&gt;
&lt;p&gt;implementations of the algo:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dijkstra (nonnegative edge)   &lt;/li&gt;
&lt;li&gt;Topological sort (!) (no directed cycles)   &lt;/li&gt;
&lt;li&gt;Bellman-Ford (no negative directed cycles)   &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;3. Dijkstra's Algorithm&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;(non-negative edges)&lt;/em&gt;   &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;consider vertices in increasing distance from s.*    &lt;/li&gt;
&lt;li&gt;add vertex to the SPT, relax all edges from that vertex.    &lt;/li&gt;
&lt;li&gt;each time: take the closest vertex to s that is not in the SPT (ie. whose dist is not determined yet), add the vertex, and relax all its outgoing edges.    &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;prop&lt;/strong&gt;. Dijkstra works. &lt;br /&gt;
pf.  &lt;br /&gt;
&lt;em&gt; each edge e = v → w is considered exactly once (when vertex v is added to SPT). distTo[w] &amp;lt;= distTo[v]+e.weight() after relaxing e &lt;br /&gt;
&lt;/em&gt; ineq holds until algo terminates &lt;br /&gt;
    * distTo[w] decrease monotonely, &lt;br /&gt;
    * distTo[v] will not change because each time we choose distTo[v] smallest, and all edges non-negative.  &lt;br /&gt;
* CQFD by optimality condition.   &lt;/p&gt;
&lt;h3&gt;implementation&lt;/h3&gt;
&lt;p&gt;Use an &lt;code&gt;IndexMinPQ&lt;/code&gt; to store vertices.   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class DijkstraSP{   
    private int dist[];   
    private DirectedEdge edgeTo[];   
    private IndexMinPQ&amp;lt;Integer,Double&amp;gt; pq;   
    DijkstraSP(EdgeWeightedDigraph G, int s){   
        this.dist[] = new int[G.V()];   
        this.edgeTo[] = new DirectedEdge[G.V()];   
        this.pq = new IndexMinPQ&amp;lt;Integer,Double&amp;gt;(G.V());   
        for(int v = 0; v&amp;lt;G.V(); v++)  dist[v] = 999999;   
        dist[s] = 0;           
        pq.insert(s, 0.0);   
        while(!pq.isEmpty()){   
            int v = pq.delMin();   
            for(DirectedEdge e:G.adj(v))    
                relax(e);// decrease key or insert vertices to pq   
        }   
    }//constructor()

    private relax(DirectedEdge e){   
        int v = e.from(), w = e.to();   
        if(dist[w]&amp;lt;dist[v]+e.weight()){   
            dist[w] = dist[v]+e.weight();   
            edgeTo[w] = e;   
            if(pq.contains(w)) pq.decreaseKey(w, dist[w]);   
            else pq.insert(w, dist[w]);   
        }   
    }//relax()   
}//class
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Dijkstra is in fact a Prim algorithm ! &lt;/strong&gt;&lt;em&gt;Both are algos that compute a spanning tree.&lt;/em&gt;     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;in Prim: each time takes the vertex &lt;em&gt;closest to the tree &lt;/em&gt;(and is for undirected graph).   &lt;/li&gt;
&lt;li&gt;in Dijkstra: each time takes the vertex &lt;em&gt;closest to source s &lt;/em&gt;(and is for directed graph).   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week2_2/pasted_image005.png" /&gt; &lt;br /&gt;
DFS BFS are also computing spanning tree!  &lt;br /&gt;
...NB!!   &lt;/p&gt;
&lt;h3&gt;complexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;V insertions to PQ (each vertex is added to the SPT)   &lt;/li&gt;
&lt;li&gt;V delMin from PQ    &lt;/li&gt;
&lt;li&gt;E decrease key   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ depends on the PQ implementation.  &lt;br /&gt;
in our implementation, &lt;strong&gt;O(ElogV)&lt;/strong&gt; &lt;br /&gt;
&lt;img alt="" src="algoII_week2_2/pasted_image006.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;4. Edge-Weighted DAGs&lt;/h1&gt;
&lt;p&gt;in a DAG, it's easier to find the shortest path ? &lt;br /&gt;
⇒ yes!  &lt;br /&gt;
simple algo:    &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;consider vertices in topological order   &lt;/li&gt;
&lt;li&gt;relax outgoing edges form this vertex.    &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;correctness&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;prop&lt;/strong&gt;.   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;topo-sort algo computes SPT in any DAG (&lt;em&gt;even with negative weights&lt;/em&gt;) in time &lt;strong&gt;O(E+V) &lt;/strong&gt;&lt;em&gt;(linear time!)&lt;/em&gt;.    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;pf.&lt;/em&gt; &lt;br /&gt;
&lt;em&gt; each edge is relaxed exactely once. distTo[w] &amp;lt;= distTo[v]+e.weight() after relaxing e &lt;br /&gt;
&lt;/em&gt; ineq holds until the algo terminates because:  &lt;br /&gt;
    * distTo[w] decrease monotonely, &lt;br /&gt;
    * distTo[v] will not change because of topo-order, no edge pointing to v after v is relaxed.  &lt;br /&gt;
* CQFD   &lt;/p&gt;
&lt;h3&gt;implementation&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class AsyclicSP{   
    AsyclicSP(EdgeWeightedDigraph G, int s){   
        // init dist[] and edgeTo[]...   
        Topological topo = new Topological(G);   
        for(int v: topo.order())   
            for(DirectedEdge e:G.adj(v))   
                relax(e);   
    }   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;application&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;seam-carving&lt;/em&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Resizing images &lt;em&gt;non-uniformly&lt;/em&gt; without distortion.  &lt;br /&gt;
&lt;img alt="" src="algoII_week2_2/pasted_image008.png" /&gt; &lt;br /&gt;
好神奇! &lt;br /&gt;
Grid DAG of pixels, edges are pointed to 3 downward neighbors. &lt;br /&gt;
横向缩小: 删掉一个"seam" &lt;br /&gt;
&lt;img alt="" src="algoII_week2_2/pasted_image009.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;longest path in DAG → &lt;em&gt;just negate all edge weights&lt;/em&gt;, as this algo is OK for negative edges.    &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;parallel job scheduling &lt;br /&gt;
&lt;img alt="" src="algoII_week2_2/pasted_image010.png" /&gt; &lt;br /&gt;
感觉有点运筹的意思, 关键是建立一个DAG, 比较有技巧性:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add source and sink    &lt;/li&gt;
&lt;li&gt;split each job to 2 vertices (begin and end)   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week2_2/pasted_image011.png" /&gt; &lt;br /&gt;
⇒ use longest path to schedule jobs   &lt;/p&gt;
&lt;h1&gt;5. Negative Weights&lt;/h1&gt;
&lt;p&gt;只是给所有边增加weight并&lt;strong&gt;不能&lt;/strong&gt;解决负权边问题.  &lt;br /&gt;
&lt;img alt="" src="algoII_week2_2/pasted_image013.png" /&gt; &lt;br /&gt;
⇒ need a different algo.   &lt;/p&gt;
&lt;p&gt;prop. SPT exists &lt;em&gt;iff&lt;/em&gt; there is no &lt;em&gt;negative cycles.&lt;/em&gt;   &lt;/p&gt;
&lt;h3&gt;Bellman-Ford&lt;/h3&gt;
&lt;p&gt;一句话总结Bellman算法: 每次relax所有的边, 进行V次. &lt;br /&gt;
&lt;img alt="" src="algoII_week2_2/pasted_image014.png" /&gt; &lt;br /&gt;
(&lt;em&gt;因为relax k次以后, s到v的最短路径的长度小于等于k.&lt;/em&gt;)   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;prop&lt;/strong&gt;. Bellman-Ford works, complexity is &lt;strong&gt;O(EV)&lt;/strong&gt;.  &lt;br /&gt;
pf.  &lt;br /&gt;
after i passes, found shortest path contain at most i edges.    &lt;/p&gt;
&lt;p&gt;code:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class BellmanFordSP{   
    BellmanFordSP(EdgeWeightedDigraph G, int s){   
        // init dist[] and edgeTo[]...   
        for(int i=0;i&amp;lt;G.V();i++)   
            for(DirectedEdge e:G.edges())   
                relax(e);   
    }

}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;improvement&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;if dist[v] is not changed during one pasee → no need to relax incoming edges any more.&lt;/em&gt;  &lt;br /&gt;
    → much faster in practice.    &lt;/p&gt;
&lt;p&gt;FIFO implementation: maintain a queue of vertices whoses dist is changed.    &lt;/p&gt;
&lt;h3&gt;Finding negative cycle&lt;/h3&gt;
&lt;p&gt;add two method to SP:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;boolean hasNegCycle();   
Iterable&amp;lt;DirectedEdge&amp;gt; negCycle();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="" src="algoII_week2_2/pasted_image016.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;prop&lt;/strong&gt;.   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;if a vertex u is updated in phase V, there exists a negative cycle, and can track edgeTo[u] to find the cycle.    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原因是最短路径的长度小于V, 如果大于V则说明存在negative cycle.  &lt;/p&gt;
&lt;h3&gt;negative cycle application&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;arbitrage detection&lt;/em&gt; &lt;br /&gt;
&lt;img alt="" src="algoII_week2_2/pasted_image018.png" /&gt; &lt;br /&gt;
建模: 
graph of currencies, edge weight = exchange weight (complete graph). &lt;br /&gt;
    ⇒ &lt;em&gt;find a cycle whose product of edge is &amp;gt;1.&lt;/em&gt;  &lt;br /&gt;
        ⇒ &lt;strong&gt;take logs&lt;/strong&gt; to make a shortest-path pb. &lt;br /&gt;
            ⇒ take minus log, then try to find a negative cycle.  &lt;br /&gt;
&lt;img alt="" src="algoII_week2_2/pasted_image020.png" /&gt; &lt;br /&gt;
NB!!   &lt;/p&gt;
&lt;h1&gt;Summery&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week2_2/pasted_image015.png" /&gt; &lt;br /&gt;
&lt;img alt="" src="algoII_week2_2/pasted_image021.png" /&gt;   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms II] Week 2-1 Minimum Spanning Trees</title><link href="http://x-wei.github.io/algoII_week2_1.html" rel="alternate"></link><updated>2015-11-11T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoII_week2_1.html</id><summary type="html">&lt;h1&gt;1. Introduction to MSTs&lt;/h1&gt;
&lt;p&gt;Given: undirected connecte graph &lt;code&gt;G&lt;/code&gt; with positive edge weights.  &lt;br /&gt;
def. &lt;strong&gt;Spanning tree &lt;/strong&gt;&lt;code&gt;T&lt;/code&gt; &lt;br /&gt;
is a subgraph of &lt;code&gt;G&lt;/code&gt;, that is both tree (&lt;em&gt;connected, acyclic&lt;/em&gt;) and spanning(&lt;em&gt;all vertices are included&lt;/em&gt;).  &lt;br /&gt;
&lt;img alt="" src="algoII_week2_1/pasted_image-0.png" /&gt; &lt;br /&gt;
⇒ Goal: find a spanning tree with minimum weight sum.   &lt;/p&gt;
&lt;h1&gt;2. Greedy Algorithm&lt;/h1&gt;
&lt;p&gt;assumptions for simplification:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;edge weights are distinct   &lt;/li&gt;
&lt;li&gt;graph is connected   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ MST uniquely exists.   &lt;/p&gt;
&lt;h2&gt;cut property&lt;/h2&gt;
&lt;p&gt;def. a &lt;strong&gt;cut&lt;/strong&gt; of a graph is a partition of its vertices into 2 non-empty sets. &lt;br /&gt;
def. a &lt;strong&gt;crossing-edge&lt;/strong&gt; (wrt a cut) is an edge connecting vertex from one set to another. &lt;br /&gt;
&lt;img alt="" src="algoII_week2_1/pasted_image001-0.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;prop. &lt;/strong&gt;Given any cut, the crossing edges with minimum weight &lt;em&gt;is in the MST&lt;/em&gt;.  &lt;br /&gt;
&lt;img alt="" src="algoII_week2_1/pasted_image002-0.png" /&gt; &lt;br /&gt;
&lt;em&gt;proof.&lt;/em&gt; &lt;br /&gt;
Given a cut. {S1,S2} are the two set of vertices,  let &lt;code&gt;e&lt;/code&gt; be the min-weighted edge among all crossing-edges.   &lt;/p&gt;
&lt;p&gt;If &lt;code&gt;e&lt;/code&gt; is not in the MST &lt;br /&gt;
   → exist another crossing-edge, &lt;code&gt;f&lt;/code&gt;, in the MST (otherwise not connected) &lt;br /&gt;
    → adding &lt;code&gt;e&lt;/code&gt; to the MST will create a cycle (tree property) &lt;br /&gt;
        → the edge &lt;code&gt;f&lt;/code&gt; will be in this cycle &lt;br /&gt;
        → removing &lt;code&gt;f&lt;/code&gt; and adding &lt;code&gt;e&lt;/code&gt; will give us another spanning tree (!) &lt;br /&gt;
                → this new spanning tree has smaller weight sum ⇒ contradiction, CQFD.   &lt;/p&gt;
&lt;h2&gt;Greedy MST algo&lt;/h2&gt;
&lt;p&gt;[&lt;strong&gt;algo&lt;/strong&gt; ] Greedy MST  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;initialize: all edges not selected (colored gray)   &lt;/li&gt;
&lt;li&gt;find any cut with &lt;em&gt;all crossing-edge gray&lt;/em&gt;   &lt;/li&gt;
&lt;li&gt;use this cut and select the min-weighted crossing edge (color the edge as black)   &lt;/li&gt;
&lt;li&gt;repeat V-1 times.    &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;prop.&lt;/strong&gt; the greedy algorithm gets the MST.  &lt;br /&gt;
&lt;em&gt;pf.&lt;/em&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;any selected (black) edges are in the MST (according to the cut property)   &lt;/li&gt;
&lt;li&gt;If we haven't selected V-1 edges → there is always a cut with all crossing-edges gray. (证明algo不会卡死)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(&lt;em&gt;if edge weight not distinct, the proof fails, but can be fixed)&lt;/em&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;efficient implementations&lt;/strong&gt;:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;how to choose the cut each time?   &lt;/li&gt;
&lt;li&gt;how to find min-weighted crossing-edge?    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⇒ Kruskal &amp;amp; Prim   &lt;/p&gt;
&lt;h1&gt;3. Edge-Weighted Graph API&lt;/h1&gt;
&lt;h2&gt;Edge API&lt;/h2&gt;
&lt;p&gt;→ &lt;em&gt;Edge abstraction&lt;/em&gt;: make Edge comparable.   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class Edge implements Comparable&amp;lt;Edge&amp;gt;{   
    Edge(int v, int w, double weight);   
    int either();// get one of the endpoint of edge (as we are in undirected graph contex here)   
    int other(int v);// get the other endpoint    
    int compareTo(Edge that);// compare by edge weight   
    double weight();   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="" src="algoII_week2_1/pasted_image.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Edge-weighted Graph API&lt;/h2&gt;
&lt;p&gt;adj-list implementation: &lt;code&gt;Bag&amp;lt;Edge&amp;gt;[] adj;&lt;/code&gt;(for undirected graph, each edge appears twice in adj)   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class EdgeWeightedGraph{   
    private final int V;   
    private final Bag&amp;lt;Edge&amp;gt;[] adj;   
    EdgeWeightedGraph(int V){   
        this.V = V;   
        this.adj = (Bag&amp;lt;Edge&amp;gt;)new Bag[V];   
        for(int v=0;v&amp;lt;V;v++) adj[v] = new Bag&amp;lt;Edge&amp;gt;();   
    }   
    void addEdge(Edge e){// use the Edge class instead of directly v and w   
        int v = e.either(), w = e.other();   
        adj[v].add(e);   
        adj[w].add(e);   
    }   
    Iterable&amp;lt;Edge&amp;gt; adj(int v){//get Edges incident to v   
        return adj[v];   
    }   
    Iterable&amp;lt;Edge&amp;gt; edges();// get all Edges   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(allow self-loops and parallel edges)   &lt;/p&gt;
&lt;h2&gt;MST API&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class MST{   
    MST(EdgeWeightedGraph G);//compute the MST   
    Iterable&amp;lt;Edge&amp;gt; edges();// selected edges in the MST   
    double weight();// sum of all edge weights in MST   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;4.  Kruskal's Algorithm&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;[algo]&lt;/strong&gt;    &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;consider edges in ascending order of weight,   &lt;/li&gt;
&lt;li&gt;add the edge to MST &lt;em&gt;unless it creates a cycle&lt;/em&gt;.    &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the running of Kruskal: we have several small connect components and they merge with each other until we get MST.    &lt;/p&gt;
&lt;h2&gt;correctness&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;prop. &lt;/strong&gt;Kruskal's algo works. &lt;br /&gt;
&lt;em&gt;pf&lt;/em&gt; &lt;br /&gt;
(idea: proove that Kruskal is a special case of the greedy algorithm, ie. how to select the specific cut) &lt;br /&gt;
suppose Kruskal's algo selects(colored black) an edge &lt;code&gt;e=v-w&lt;/code&gt; &lt;br /&gt;
→ select a cut = vertices connected to v in the (constructing) MST; and the rest vertices.  &lt;br /&gt;
    → for this cut, there is no black crossing edges &lt;br /&gt;
        → moreover among all crossing edges of the cut the edge e has the smallest weight!! (by def of Kruskal) CQFD   &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;how to test if adding an edge will create a cycle ?    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DFS from v to w? → O(V) &lt;br /&gt;
⇒ &lt;strong&gt;Union-Find&lt;/strong&gt; !  O(lg*V) ☺ (almost constant time)   &lt;/p&gt;
&lt;p&gt;if &lt;code&gt;find(v)==find(w)&lt;/code&gt;, then we know adding e will create a cycle.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;considering edges in order? → use a prority queue.    &lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;public&lt;/span&gt; &lt;span class="nt"&gt;class&lt;/span&gt; &lt;span class="nt"&gt;KruskalMST&lt;/span&gt; &lt;span class="nt"&gt;extends&lt;/span&gt; &lt;span class="nt"&gt;MST&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Bag&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Edge&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;mst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Bag&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Edge&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;KruskalMST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EdgeWeightedGraph&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;   
        &lt;span class="n"&gt;MinPQ&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Edge&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pq&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MinPQ&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Edge&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
        &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt; &lt;span class="n"&gt;pq&lt;/span&gt; &lt;span class="o"&gt;--&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;optimized&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;O&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;if&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt; &lt;span class="k"&gt;bottom&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;up&lt;/span&gt;   
        &lt;span class="n"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Edge&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;edges&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="n"&gt;pq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
        &lt;span class="n"&gt;UF&lt;/span&gt; &lt;span class="n"&gt;uf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;UF&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;UF&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt; &lt;span class="n"&gt;elements&lt;/span&gt;   
        &lt;span class="n"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;pq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isEmpty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;mst&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="k"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="m"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;   
            &lt;span class="n"&gt;Edge&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pq&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delMin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
            &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;either&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
            &lt;span class="n"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;uf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connecte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
            &lt;span class="n"&gt;uf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;union&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
            &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mst&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;           
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="err"&gt;}&lt;/span&gt;   
    &lt;span class="nt"&gt;public&lt;/span&gt; &lt;span class="nt"&gt;Iterable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;Edge&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;edges&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
        &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;complexity&lt;/h2&gt;
&lt;p&gt;running time: O(ElogE) &lt;br /&gt;
&lt;img alt="" src="algoII_week2_1/pasted_image001.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;5. Prim's Algorithm&lt;/h1&gt;
&lt;p&gt;since 1930...  &lt;br /&gt;
Idea: start from a vertex and &lt;em&gt;grows the tree &lt;/em&gt;&lt;code&gt;T&lt;/code&gt;&lt;em&gt; to MST.&lt;/em&gt;    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[algo]&lt;/strong&gt;         &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Add to the tree T the edge &lt;em&gt;that have exactely one endpoint in T&lt;/em&gt; and with minimum weight,  &lt;/li&gt;
&lt;li&gt;repeat V-1 times.    &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the running of Prim: there is always ONE connnected component .    &lt;/p&gt;
&lt;h2&gt;Correctness&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;prop&lt;/strong&gt;. Prim's algo works. &lt;br /&gt;
&lt;em&gt;pf.&lt;/em&gt; &lt;br /&gt;
suppose edge e is the min-weighted edge connect a vertex in T with a vertex out of T.  &lt;br /&gt;
→ select the cut = vertices in the tree T; vertices out of T &lt;br /&gt;
→ by def, there is no black crossing edge &lt;br /&gt;
→ e is the min-weighed edge by def of Prim. CQFD   &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;p&gt;challenge: how to find such an edge (connect T and other vertex, with min weight) ? &lt;br /&gt;
⇒ priority queue    &lt;/p&gt;
&lt;h3&gt;"lazy" implementation&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;[algo]&lt;/strong&gt;    &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Maintain a PQ of edges that connect T and the rest vertices.    &lt;/li&gt;
&lt;li&gt;&lt;code&gt;e = pq.delMin(), e = v-w&lt;/code&gt;,  if &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; are both in T (as edges in pq might become obsolete as T grows) ⇒ &lt;em&gt;just disregard it&lt;/em&gt;    &lt;/li&gt;
&lt;li&gt;to maintain the pq: add all incident edges(with other endpoint not in T) of the newly added vertex to pq   &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class LazyPrimMST{   
    private Bag&amp;lt;Edge&amp;gt; mst;   
    LazyPrimMST(EdgeWeightedGraph G){   
        boolean[] marked = new boolean[G.V()]; // vertices in T   
        MinPQ&amp;lt;Edge&amp;gt; pq = new MinPQ&amp;lt;Edge&amp;gt;();    
        this.mst = new Bag&amp;lt;Edge&amp;gt;();   
        marked[0] = 0; // add vertex 0 to T   
        for(Edge e:G.adj(0))    
            pq.insert(e);// add edges to pq   
        while(!pq.isEmpty() &amp;amp;&amp;amp; this.mst.size()&amp;lt;G.V()-1){   
            e = pq.delMin();   
            int v = e.either(), w = e.other(v);   
            if(marked[v] &amp;amp;&amp;amp; marked[w]) continue;//ignore obsolete edges   
            v = marked[v] ? w : v;// v is the newly added vertex   
            marked[v] = true;   
            for(Edge e:G.adj(v)){   
                if(!marked[e.other(v)])   
                    pq.insert(e);   
            }   
        }   
    }   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Running time: &lt;strong&gt;O(ElgE)&lt;/strong&gt; &lt;br /&gt;
&lt;img alt="" src="algoII_week2_1/pasted_image002.png" /&gt; &lt;br /&gt;
space: &lt;strong&gt;O(E)&lt;/strong&gt; in worst time.   &lt;/p&gt;
&lt;h3&gt;"eager" implementation&lt;/h3&gt;
&lt;p&gt;Idea:    &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;use a &lt;strong&gt;PQ of vertices&lt;/strong&gt;&lt;em&gt;, priority of vertex v := min-weight of edge that connects v to T.&lt;/em&gt;    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;[algo]&lt;/strong&gt;   &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Get from pq the vertex &lt;code&gt;v&lt;/code&gt; that is closest to T, add it to T. &lt;br /&gt;
Update pq -- consider &lt;code&gt;v&lt;/code&gt;'s incident edge &lt;code&gt;e=v-w:&lt;/code&gt;   &lt;ul&gt;
&lt;li&gt;if w in T → ignore   &lt;/li&gt;
&lt;li&gt;else:   &lt;ul&gt;
&lt;li&gt;if w in pq → add w to pq   &lt;/li&gt;
&lt;li&gt;else → if &lt;code&gt;v-w&lt;/code&gt; has smaller weight than the current priority, update &lt;code&gt;w&lt;/code&gt;'s priority.      &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;repeat till get V-1 edges.    &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week2_1/pasted_image003.png" /&gt;   &lt;/p&gt;
&lt;p&gt;key implementation component: a &lt;a href="file:///home/wx/Dropbox/ZIM_NOTES/0._TmpNotes/Algorithms%2C_part_II/MinPQ.txt"&gt;MinPQ&lt;/a&gt; that supports priority(key) update.    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;IndexMinPQ&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;Key extends Comparable&amp;lt;Key&amp;gt;&lt;/span&gt;&amp;gt;{   
    &lt;span class="n"&gt;IndexMinPQ&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;);// &lt;span class="n"&gt;indices&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;elements:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;...&lt;span class="n"&gt;N-1&lt;/span&gt;   
    &lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;, &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="nb"&gt;key&lt;/span&gt;);   
    &lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="n"&gt;decreaseKey&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;, &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="nb"&gt;key&lt;/span&gt;);// &lt;span class="n"&gt;update&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="nb"&gt;key&lt;/span&gt;(&lt;span class="n"&gt;priority&lt;/span&gt;) &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;element-i&lt;/span&gt;   
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;delMin&lt;/span&gt;();   
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;();   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;implementation of such a PQ:   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Use same code as standart PQ (maintain a heap[] array). &lt;br /&gt;
Elements are always accessed by "index", in range 0...N-1.
maintain 3 parallel arrays: &lt;code&gt;keys[], pq[], qp[]&lt;/code&gt;:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;keys[i]&lt;/code&gt;: is the priority of element i (the element with index=i)   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;pq[i]&lt;/code&gt;: is the index of the element in the heap position i (ie. in heap[i] is pq[i]th element  )   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;qp[i]&lt;/code&gt;: is heap position of element i  ( ⇔ the ith element is in heap[qp[i]] )   &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;to &lt;code&gt;decreaseKey(i,key)&lt;/code&gt;: change &lt;code&gt;keys[i]&lt;/code&gt;, then call &lt;code&gt;siftup(qp[i])&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week2_1/pasted_image004.png" /&gt; &lt;br /&gt;
summery of pq implementations:  &lt;br /&gt;
&lt;img alt="" src="algoII_week2_1/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;6. MST Context&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;unsolved pb: does a linear MST algo exists?   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(recap: for UF, tarjan has &lt;em&gt;prooved&lt;/em&gt; that linear algo doesn't exist — although Nlg*N is fast enough...) &lt;br /&gt;
@_@... &lt;br /&gt;
&lt;img alt="" src="algoII_week2_1/pasted_image007.png" /&gt; &lt;br /&gt;
(这个Yao是清华那个Yao吧?)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Euclidean MST   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given N points in plane, edge weight := Euclidean distance. (&lt;em&gt;dense graph, E = V2&lt;/em&gt;) &lt;br /&gt;
→ exploit geomerty, O(NlgN)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clustering   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;k-clustering (~ dist-fcn) &lt;br /&gt;
single-link clustering (def. dist of clusters = dist of 2 closest elements in each cluster) &lt;br /&gt;
→ Kruskal...   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms II] Week 1-2 Directed Graphs</title><link href="http://x-wei.github.io/algoII_week1_2.html" rel="alternate"></link><updated>2015-11-09T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoII_week1_2.html</id><summary type="html">&lt;h1&gt;1. Intro to digraphs&lt;/h1&gt;
&lt;p&gt;Has profound differences wrt undirected graphs.    &lt;/p&gt;
&lt;p&gt;def: digraph &lt;br /&gt;
&lt;em&gt; edges: have directions &lt;br /&gt;
&lt;/em&gt; vertex: distinguish indeg and outdeg   &lt;/p&gt;
&lt;p&gt;digraph pbs:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;path/shortest path   &lt;/li&gt;
&lt;li&gt;topological sort: Can you draw a digraph so that all edges point upwards?   &lt;/li&gt;
&lt;li&gt;strong connectivity: Is there a directed path between all pairs of vertices?   &lt;/li&gt;
&lt;li&gt;transit closure   &lt;/li&gt;
&lt;li&gt;PageRank   &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;2. Digraph API&lt;/h1&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class Digraph{   
    Digraph(int V);   
    void addEdge(int v, int w);// edge is directed   
    Iterable&amp;lt;Interger&amp;gt; adj(int v);// vertices reached by outgoing edges   
    int V();   
    Digraph reverse();// &amp;lt;--new methode wrt undirected graph   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;representation: adj-list, ie. an array of bags.  &lt;br /&gt;
&lt;code&gt;Bag&amp;lt;Integer&amp;gt;[] adj;// prec vertices&lt;/code&gt;   &lt;/p&gt;
&lt;h1&gt;3. Digraph Search&lt;/h1&gt;
&lt;p&gt;BFS and DFS can be applied to digraphs.   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;reachability   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;find all vertices reachable from vertex-s.  &lt;br /&gt;
use the same DFS as for undirected graphs.  &lt;br /&gt;
→ application: programme control-flow analyse, garbage collection.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;DFS is the basis for a lot of digraph pbs&lt;/em&gt;: 2-satisfiability, Euler path, strongly connected component.    &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;multiple source shortest path:    &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week1_2/pasted_image.png" /&gt; &lt;br /&gt;
⇒ use DFS but &lt;em&gt;enque all vertices in the set&lt;/em&gt;.  &lt;br /&gt;
→ application: web crawler(DFS not suitable for crawling)   &lt;/p&gt;
&lt;h1&gt;4. Topological Sort&lt;/h1&gt;
&lt;p&gt;application. precedence schedule, java compiler (cycled inheritance), ...   &lt;/p&gt;
&lt;p&gt;def. &lt;strong&gt;topo-order&lt;/strong&gt; &lt;br /&gt;
is a permutation of vertices, where for each vertice v→w, w is behind v in the permutation.    &lt;/p&gt;
&lt;p&gt;def. &lt;strong&gt;DAG&lt;/strong&gt; &lt;br /&gt;
directed acyclic graph. &lt;br /&gt;
&lt;strong&gt;prop. &lt;/strong&gt;for a digraph, topological order exists &lt;em&gt;iff&lt;/em&gt; graph is a DAG.    &lt;/p&gt;
&lt;p&gt;algo: ⇒ use DFS~  &lt;br /&gt;
&lt;em&gt;reverse DFS postorder&lt;/em&gt;   &lt;/p&gt;
&lt;p&gt;def.    &lt;strong&gt;postorder&lt;/strong&gt; &lt;br /&gt;
is the order of the vertices that we have &lt;em&gt;finished&lt;/em&gt; (ie. we have visited all reachable vertices from this vertex).   &lt;/p&gt;
&lt;h3&gt;implementation&lt;/h3&gt;
&lt;p&gt;这个以前的blog写过...    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private boolean[] visited;   
private Stack&amp;lt;Integer&amp;gt; revPostorder;// stores the vertices in reverse post order   
private void dfs(Digraph G, int v){   
    visited[v] = true;   
    for(int w: G.adj(v))   
        if(!visited[w])   
            dfs(G, w);   
    //** now we know the vertex v is &amp;quot;finished&amp;quot; **   
    revPostorder.push(v);   
}   
public Iterable&amp;lt;Integer&amp;gt; topoOrder(Digraph G){   
    for(int v=0;v&amp;lt;G.V();v++)   
        if(!visited(v)) dfs(G,v);// visit all cc   
    return revPostorder;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;proof&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;prop. &lt;/strong&gt;reverse post-order of a DAG is in topological order.  &lt;br /&gt;
(这个证明蛮精彩) &lt;br /&gt;
&lt;strong&gt;pf.&lt;/strong&gt; &lt;br /&gt;
for any edge &lt;strong&gt;v→w&lt;/strong&gt;, when &lt;code&gt;dfs(v)&lt;/code&gt; is called:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;case 1: &lt;code&gt;dfs(w)&lt;/code&gt; is called and returned, so w is done before v in post-order;   &lt;/li&gt;
&lt;li&gt;case 2: &lt;code&gt;dfs(w)&lt;/code&gt; is not called, it will be (in)directly get called by &lt;code&gt;dfs(v)&lt;/code&gt;, so &lt;code&gt;dfs(w)&lt;/code&gt; finishes before &lt;code&gt;dfs(v)&lt;/code&gt;;   &lt;/li&gt;
&lt;li&gt;case 3: &lt;code&gt;dfs(w)&lt;/code&gt; is called but NOT returned (ie, w not &lt;em&gt;finished&lt;/em&gt;) → exist path from w to v ⇒ graph is not a DAG! (cycle detection)   &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;5. Strong Components&lt;/h1&gt;
&lt;p&gt;For undirected graphs: connected components can be solved with dfs or UF.    &lt;/p&gt;
&lt;p&gt;def. &lt;strong&gt;Strongly-connected&lt;/strong&gt; &lt;br /&gt;
v and w are strongly-connected if exist path from v to w and w to v.  &lt;br /&gt;
→ is an equivalent relation.    &lt;/p&gt;
&lt;p&gt;def. &lt;strong&gt;Strong Component&lt;/strong&gt; &lt;br /&gt;
subset of  V where each pair are strongly-connected.    &lt;/p&gt;
&lt;p&gt;Goal: compute all strong components(&lt;em&gt;scc&lt;/em&gt;) in a digraph.    &lt;/p&gt;
&lt;h2&gt;linear time DFS solution: Tarjan (1972)&lt;/h2&gt;
&lt;p&gt;(developed version: a two-pass linear-time algorithm)   &lt;/p&gt;
&lt;p&gt;Intuition: &lt;em&gt;scc for G is the same for G.reverse().&lt;/em&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kernel DAG&lt;/strong&gt;: contract each scc into a single vertex.  &lt;br /&gt;
&lt;img alt="" src="algoII_week1_2/pasted_image001.png" /&gt;   &lt;/p&gt;
&lt;p&gt;Idea:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;compute topological-order in the kernel DAG.   &lt;/li&gt;
&lt;li&gt;run DFS, consider vertices in reverse-topo-order    &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;[Algo]&lt;/strong&gt; &lt;br /&gt;
1. compute topo-order in &lt;code&gt;G.reverse&lt;/code&gt; (just a DFS in the reversed graph) &lt;br /&gt;
2. run DFS in original  &lt;code&gt;G&lt;/code&gt;, &lt;em&gt;visit unmarked vertices in topo-order of G.reverse&lt;/em&gt;. (instead of visiting vertices by their index)   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;⇒ &lt;strong&gt;each time we finish a dfs from a vertex, we get a scc!&lt;/strong&gt;   &lt;br /&gt;
太精彩了!!! &lt;br /&gt;
&lt;img alt="" src="algoII_week1_2/pasted_image002.png" /&gt;   &lt;/p&gt;
&lt;p&gt;proof: tricky, cf book...(貌似Werner课上讲过..)   &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private int[] scc = new int[V]; // scc[v] is the index of the SCC that v belongs to   
private int sccCount = 0;   
private boolean[] visited = new boolean[V];   
public getSCC(Digraph G){   
    // 1. get topo-order in reverse graph   
    Iterable&amp;lt;Integer&amp;gt; topoOrderGR = topoOrder(G.reverse());   
    // 2. run dfs in original graph, run on vertices using the above topo-order    
    for(int v:topoOrderGR)// &amp;lt;-- only difference from the standard topo-order algo   
        if(!visited[v])   
            dfs(G, v, sccCount++);//increment sccCount everytime we done a component   
}   
private dfs(Digraph G, int v){   
    // run dfs from v, and all touched vertices are marked in sccId&amp;#39;s SCC   
    visited[v] = true;   
    scc[v] = sccCount;   
    for(int w:G.adj(v))   
        if(!visited[w]){   
            scc[w] = sccCount;   
            dfs(G,w);   
        }   
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms II] Week 1-1 Undirected Graphs</title><link href="http://x-wei.github.io/algoII_week1_1.html" rel="alternate"></link><updated>2015-11-08T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoII_week1_1.html</id><summary type="html">&lt;h1&gt;1. Intro to graphs&lt;/h1&gt;
&lt;p&gt;Graph: vertices connected by edges.    &lt;/p&gt;
&lt;p&gt;terminology:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;path&lt;/strong&gt;:  sequence of vertices connected by edges   &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cycle&lt;/strong&gt;: path with same starting and ending vertex   &lt;/li&gt;
&lt;li&gt;two vertices are &lt;strong&gt;connected&lt;/strong&gt;: if there is a path between     &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex of graph problems:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;path: or connectivity   &lt;/li&gt;
&lt;li&gt;shortest path   &lt;/li&gt;
&lt;li&gt;cycle   &lt;/li&gt;
&lt;li&gt;Euler tour (ouii..)   &lt;/li&gt;
&lt;li&gt;Hamilton tour   &lt;/li&gt;
&lt;li&gt;MST   &lt;/li&gt;
&lt;li&gt;bi-connectivity: is there a vertex whose removal disconnects the graph?   &lt;/li&gt;
&lt;li&gt;planarity   &lt;/li&gt;
&lt;li&gt;isomorphism   &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;2. Graph API&lt;/h1&gt;
&lt;h2&gt;graph representation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;vertex representation:  use integers &lt;em&gt;between 0 and V-1&lt;/em&gt;   &lt;/li&gt;
&lt;li&gt;anormalies: self-loop and multiple edges are &lt;em&gt;possible&lt;/em&gt;    &lt;div class="codehilite"&gt;&lt;pre&gt;public class Graph{   
    Graph(int V);   
    void addEdge(int v, int w);   
    Iterable&amp;lt;Integer&amp;gt; adj(int v);   
    int V();// nb of vertices   
    int E();// nb of edges   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;print all edges:  &lt;br /&gt;
&lt;img alt="" src="algoII_week1_1/pasted_image.png" /&gt;   &lt;/p&gt;
&lt;p&gt;basic functions:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;static&lt;/span&gt; &lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;degree&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;Graph&lt;/span&gt; &lt;span class="nt"&gt;g&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;v&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;deg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;adj&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;deg&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="n"&gt;deg&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="nt"&gt;static&lt;/span&gt; &lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;nbOfSelfloops&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;Graph&lt;/span&gt; &lt;span class="nt"&gt;g&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
        &lt;span class="n"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;adj&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;    
            &lt;span class="n"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;edge representation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;set-of-edge implementation: a list of all edges ⇒ can lead to inefficient implementation   &lt;/li&gt;
&lt;li&gt;adj-matrix implementation: maintain a 2d (V*V) boolean array ⇒ space complexity too heavy   &lt;/li&gt;
&lt;li&gt;adj-list implementation: vertex-indexed array, each array entry is a &lt;code&gt;Bag&lt;/code&gt; (类似桶bucket) ⇒ sutable for sparse graphs   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week1_1/pasted_image001.png" /&gt; &lt;br /&gt;
adj-list implementation:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private final int V;   
private Bag&amp;lt;Integer&amp;gt;[] adj;   
public Graph(int V){   
    this.V = V;   
    this.adj = (Bag&amp;lt;Integer&amp;gt;[]) new Bag[V];// java cannot create generic array   
    for(int v = 0; v&amp;lt;V; v++) adj[v] = new Bag&amp;lt;Integer&amp;gt;();   
}   
public addEdge(int v, int w){   
    adj[v].add(w);   
    adj[w].add(v);// if undirected graph   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="" src="algoII_week1_1/pasted_image002.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;3. Depth-First Search&lt;/h1&gt;
&lt;p&gt;Tremaux maze exploration: trace back when no unvisited vertices availiable.  &lt;br /&gt;
动画好看... &lt;br /&gt;
DFS goal: systematically search through a graph.  &lt;br /&gt;
&lt;strong&gt;design pattern&lt;/strong&gt;: &lt;em&gt;decouple&lt;/em&gt; graph data and graph processing.    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class Paths{   
    Path(Graph G, int s);// graph G and source s   
    boolean hasPathTo(int v);   
    Iterable&amp;lt;Integer&amp;gt; pathTo(int v);   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;algo:  &lt;br /&gt;
&lt;img alt="" src="algoII_week1_1/pasted_image003.png" /&gt; &lt;br /&gt;
注意每次访问节点以前就将其mark.    &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用一个boolean数组&lt;code&gt;visited[]&lt;/code&gt;作为标记   &lt;/li&gt;
&lt;li&gt;为了找到一条具体的路径(ie, 一系列节点), 维护一个&lt;code&gt;prev[]&lt;/code&gt;数组, 存放当前节点是从哪个节点走过来的.    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoII_week1_1/pasted_image004.png" /&gt;  &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;//public class DFSpaths extends Paths...   
boolean[] visited = new boolean[V];   
int[] prev = new int[V];   
public void dfs(int v){   
    visited[v] = true;   
    for(int w: G.adj())   
        if(!visited[w]) {   
            prev[w]=v;   
            dfs(w);   
        }   
}   
public Iterable&amp;lt;Integer&amp;gt; pathTo(int v){   
    Stack&amp;lt;Integer&amp;gt; s = new Stack&amp;lt;Integer&amp;gt;();   
    for(int x = v; x!=s; x = prev[x])    
        s.push(x);   
    return s;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;properties&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;prop&lt;/strong&gt;. &lt;br /&gt;
DFS visite all edges in time propotional to the sum of their degrees(ie. nb of edges).    &lt;/p&gt;
&lt;h1&gt;4. Breadth-First Search&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;not&lt;/strong&gt; recursive algo. &lt;br /&gt;
&lt;em&gt;maintain a queue, add to queue for all vertices not-marked.&lt;/em&gt;    &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;use &lt;code&gt;visited[]&lt;/code&gt; to mark vertices   &lt;/li&gt;
&lt;li&gt;use a &lt;code&gt;prev[]&lt;/code&gt; array to get explicit path   &lt;/li&gt;
&lt;li&gt;use a &lt;code&gt;dist[]&lt;/code&gt; array to record the shortest dist from v to source (can use &lt;code&gt;dist&lt;/code&gt; to replace &lt;code&gt;visited&lt;/code&gt;)   &lt;div class="codehilite"&gt;&lt;pre&gt;public void bfs(Graph G, int s){   
    boolean visited[] = new boolean[G.V()];   
    int prev[] = new int[G.V()];   
    int dist[] = new int[G.V()];   
    Queue&amp;lt;Integer&amp;gt; q = new Queue&amp;lt;Integer&amp;gt;();   
    visited[s] = true;   
    q.push(s);   
    while(!q.isEmpty()){   
        int v = q.dequeue();   
        for(int w:G.adj(v))   
            if(!visited[w]) {   
                prev[w] = v;   
                visited[w] = true;   
                q.enqueue(w);   
            }      
    }   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;property&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;prop.&lt;/strong&gt; &lt;br /&gt;
BFS computes the shortest path from s to all vertices using time propotional to E+V.    &lt;/p&gt;
&lt;p&gt;intuition: BFS examines nodes by increasing distance    &lt;/p&gt;
&lt;h1&gt;5. Connected Components&lt;/h1&gt;
&lt;p&gt;dealing with connectivity(equivalence) queries ⇒ answer in constant time (with &lt;em&gt;preprocessing&lt;/em&gt;).    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class CC{   
    boolean connected(int v, int w);   
    int count();// nb of CCs   
    int id(int v);//id for a CC   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;⇒ Union-Find ? ⇒ &lt;em&gt;Use DFS!!&lt;/em&gt;   &lt;/p&gt;
&lt;p&gt;def. &lt;em&gt;connected component&lt;/em&gt; is a maximal set of connected vertices.    &lt;/p&gt;
&lt;p&gt;algo: for each unmarked vertex, run dfs(with increasing cc id)... &lt;br /&gt;
after the preprocessing, we can get the array &lt;code&gt;id[]&lt;/code&gt; and cc count &lt;code&gt;cnt&lt;/code&gt;...   &lt;/p&gt;
&lt;h1&gt;6. Graph Challenges&lt;/h1&gt;
&lt;p&gt;some typical pbs &lt;br /&gt;
&lt;strong&gt;pb1. bipartite graph&lt;/strong&gt;   &lt;/p&gt;
&lt;p&gt;Can we  divide vertices into 2 subsets, where all edge go from one subset to other.  &lt;br /&gt;
⇒ can be done with dfs. &lt;em&gt;cf. booksite&lt;/em&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pb2. cycle detection&lt;/strong&gt; &lt;br /&gt;
⇒ simple using dfs.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pb3. Euler cycle&lt;/strong&gt; &lt;br /&gt;
Find a cycle that uses all edges exactely once.  &lt;br /&gt;
[Euler] a graph is Eulerian &lt;strong&gt;iff&lt;/strong&gt; all vertices have even degree.  &lt;br /&gt;
⇒ typical diligent algo students can do. &lt;em&gt;cf. booksite&lt;/em&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pb4. Hamilton cycle&lt;/strong&gt; &lt;br /&gt;
Find cycle that visits each vertex exactly once.  &lt;br /&gt;
⇒ intractable (typical NP-complete pb)   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pb5. isomorphism of graphs&lt;/strong&gt; &lt;br /&gt;
Are two graphs identical except for vertex names? &lt;br /&gt;
⇒ no one knows...    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pb6. planary graph&lt;/strong&gt; &lt;br /&gt;
Lay out a graph in the plane without crossing edges? &lt;br /&gt;
⇒ expert level. exists linear time algo based on DFS by Tarjan, but too complicated.    &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>最短路径三剑客: Floyd, Dijkstra, Bellman</title><link href="http://x-wei.github.io/shortest-path-summary.html" rel="alternate"></link><updated>2015-10-18T17:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/shortest-path-summary.html</id><summary type="html">&lt;p&gt;weighted graph的最短路径问题有三个非常有名的算法, 分别以三个大牛的名字命名, 今天用尽量简洁的篇幅一一介绍.    &lt;/p&gt;
&lt;p&gt;简单起见(这回只写伪代码好了), 对于图的定义如下:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node index = &lt;code&gt;{1,2,...,n}&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;e[u,v]&lt;/code&gt; = distance of edge(u,v); if (u,v) is not an edge, &lt;code&gt;e[u,v]=INF&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;令N=点的数量, M=边的数量   &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;任意两点最短路径: Floyd-Warshall&lt;/h1&gt;
&lt;p&gt;Floyd算法解决的问题是: 对于&lt;strong&gt;任意&lt;/strong&gt;两个节点&lt;code&gt;s&lt;/code&gt;(source)和&lt;code&gt;t&lt;/code&gt;(target), 求s到达t的最短路径.    &lt;/p&gt;
&lt;p&gt;Floyd算法的思想是动态规划:    &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;定义&lt;code&gt;d(i,j,k)&lt;/code&gt;为点i到点j之间, &lt;strong&gt;只允许借道节点1...k的最短路径&lt;/strong&gt;   &lt;/li&gt;
&lt;li&gt;初始化: &lt;code&gt;d(i,j,0)=e[i,j]&lt;/code&gt;(即i到j之间不经由其他任何中转节点的最短路径)   &lt;/li&gt;
&lt;li&gt;更新dij的公式就是: &lt;code&gt;d(i,j,k)=min( d(i,j,k-1), d(i,k-1,k-1)+e[k,j])&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;更新n次   &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;每次更新dij的意思就是: 现在从i到j可以经过节点k了, 那么看一下ij之间从k这个点经过的话(i → k → j 这条路)能不能缩短dij.    &lt;/p&gt;
&lt;p&gt;i到j最短路径最终就是: &lt;code&gt;d(i,j,n)&lt;/code&gt; 即i到j的路程可以经过1~n中的任何中转节点.    &lt;/p&gt;
&lt;p&gt;伪代码特别短(其实真代码也一样短....):    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;for all [i,j]: // initialize   
    d[i,j] = e[i,j]    
for k = 1 ~ n: // relax for k times:    
    for all [i,j]:   
        d[i,j] = min(d[i,j], d[i,k] + e[k,j])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;核心代码只有最后三行... 运行结束后&lt;code&gt;d[i,j]&lt;/code&gt;就保存着任意i和j之间的最短路径长度.  &lt;br /&gt;
程序主循环n次, 每次要处理遍历所有的ij组合, 所以复杂度是&lt;strong&gt;O(N^3)&lt;/strong&gt;.    &lt;/p&gt;
&lt;h1&gt;单源最短路径: Dijkstra&lt;/h1&gt;
&lt;p&gt;Dijkstra算法解决的问题是: 没有负权边的情况下, 从&lt;strong&gt;源节点&lt;/strong&gt;&lt;code&gt;s&lt;/code&gt;到其他任意节点&lt;code&gt;t&lt;/code&gt;的路径长度.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护一个dist数组, dist[i]就表示(目前为止)s到i的最短距离.    &lt;/li&gt;
&lt;li&gt;对于每个元素, &lt;strong&gt;标记&lt;/strong&gt;是否其dist是否已经确定不再更改(或者说维护两个集合: 一个集合的dist确定, 另一个未确定).    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dijkstra算法是一种贪心策略: 每次在未确定最短路径的节点里挑选距离s最近的那个点, 把这个点标记为已经确定dist, 然后对从这个点出发的边进行松弛.    &lt;/p&gt;
&lt;p&gt;为了标记每个点, 这里用一个bool数组表示: &lt;code&gt;determined[i]&lt;/code&gt;为true表示i的dist已经是最短路程, 为false表示还不确定.    &lt;/p&gt;
&lt;p&gt;算法如下:    &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;初始化&lt;code&gt;dist[i] = e[s,i]&lt;/code&gt;, &lt;code&gt;determined[i]&lt;/code&gt;全为false   &lt;/li&gt;
&lt;li&gt;在dist未确定的元素里(&lt;code&gt;determined[i]==false&lt;/code&gt;)寻找一个dist最小的节点&lt;code&gt;u:&lt;/code&gt;   &lt;ul&gt;
&lt;li&gt;标记&lt;code&gt;u&lt;/code&gt;的dist已经确定&lt;code&gt;determined[i]=true&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;用u的所有出边进行松弛: s到i如果经过(u,i)这条边会不会变近? &lt;code&gt;dist[i] = min(dist[i], dist[u]+e[u,i])&lt;/code&gt;    &lt;/li&gt;
&lt;li&gt;重复循环直到所有的点都确定dist(or 重复N遍即可: &lt;em&gt;每次只会确定一个新的节点的距离&lt;/em&gt;)   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;伪代码:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;for i in 1~n:   
    dist[i] = e[s,i]   
    determined[i] = false   
loop N times:    
    u = argmin(dist[i]) among all i that determined[i]==false   
    determined[u] = true // determine one node at each loop     
    for v such that e[u,v]&amp;lt;INF:   
        dist[v] = min( dist[v], dist[u]+e[u,v] )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上代码的复杂度为O(N^2), 不过如果用堆来优化寻找最近的u的距离, 复杂度可以变得更低.    &lt;/p&gt;
&lt;h1&gt;有负权边的单源最短路径: Bellman-Ford&lt;/h1&gt;
&lt;p&gt;Dijkstra算法的缺点在于不能处理边长为负数的情况, 而这就是Bellman-Ford算法解决的.    &lt;/p&gt;
&lt;p&gt;Bellman算法也是一种动态规划(动态规划这个东西就是Bellman提出来的):    &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;定义&lt;code&gt;d(i,k)&lt;/code&gt;为源点s到i&lt;strong&gt;最多经过k条边的&lt;/strong&gt;最短距离   &lt;/li&gt;
&lt;li&gt;初始化: &lt;code&gt;d(i,1)=e[s,i]&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;每次更新di的公式: &lt;code&gt;for all (u,v): d(v,k)=min( d(v,k-1), d(u,k-1)+e[u,v] )&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;更新n-1次   &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么是更新n-1次? 因为s到i的最短路径至多只有n-1条边(即s到i的路径经过了所有n个点).  &lt;br /&gt;
注意每次更新, 需要把&lt;strong&gt;所有的边&lt;/strong&gt;试一遍: 看看用每条边(u,v)能不能松弛dv.    &lt;/p&gt;
&lt;p&gt;伪代码:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;for i in 1~n:   
    dist[i] = e[s,i]   
loop n-1 times:    
    for all (u,v) such that e[u,v]&amp;lt;INF:   
        dist[v] = min( dist[v], dist[u]+e[u,v] )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;核心代码也是最后三行... 太tm精妙了!!    &lt;/p&gt;
&lt;p&gt;外层循环N-1次, 内层循环M次, 所以代码的复杂度是O(NM).   &lt;/p&gt;
&lt;h1&gt;More&lt;/h1&gt;
&lt;p&gt;以下问题有空再写...   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;negative cycle   &lt;/li&gt;
&lt;li&gt;A*   &lt;/li&gt;
&lt;/ul&gt;</summary><category term="algorithm"></category></entry><entry><title>深度优先搜索(DFS)小结</title><link href="http://x-wei.github.io/dfs-summary.html" rel="alternate"></link><updated>2015-10-18T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/dfs-summary.html</id><summary type="html">&lt;p&gt;今天总结一下也许是搜索问题里最重要的算法: DFS !    &lt;/p&gt;
&lt;p&gt;由于树可以看成是一个graph, 这里还是只写对于graph的DFS算法. Graph类的定义还是用每一个节点保存邻居信息:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class GraphNode{      
    int val;      
    List&amp;lt;GraphNode&amp;gt; neighbors;      
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了防止重复, 仍然用一个HaseSet记录走过的节点:    &lt;/p&gt;
&lt;p&gt;&lt;code&gt;HasheSet&amp;lt;GraphNode&amp;gt; visited = new HasheSet&amp;lt;GraphNode&amp;gt;();&lt;/code&gt;    &lt;/p&gt;
&lt;h2&gt;Recursive DFS&lt;/h2&gt;
&lt;p&gt;首先写递归版本的DFS, DFS就是一条路走到底, 不撞南墙不回头, 所以递归写起来很自然: 每到一个节点, 标记其已经访问过了, 然后对于邻居里面没有访问的节点继续递归进行DFS.    &lt;/p&gt;
&lt;p&gt;递归的DFS代码非常简洁:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public void DFS(GraphNode nd){      
    System.out.println(nd.val);    
    visited.add(nd);   
    for(GraphNode next: nd.neighbors){   
        if( !visited.contains(next) )   
            DFS(next);   
    }   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;虽然这个算法很短, 但是它非常重要, 回溯算法(backtracking)其实就相当于在问题的求解域做一个dfs. 另外拓扑排序也是基于递归dfs进行一点点修改.    &lt;/p&gt;
&lt;h2&gt;Non-recursive DFS&lt;/h2&gt;
&lt;p&gt;非递归版本的dfs同样很重要, 因为毕竟非递归的版本效率高一些, 另外这个算法和bfs非常相似, 只不过把队列queue换成了栈stack而已:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public void DFS(GraphNode start){      
    Stack&amp;lt;GraphNode&amp;gt; s = new Stack&amp;lt;GraphNode&amp;gt;();   
    q.push(start);      
    visited.add(start);      
    while(!s.empty()){      
        GraphNode cur = s.pop();      
        System.out.println(cur.val);      
        for(GraphNode next: cur.children){       
            if(!visited.contains(next)){      
                s.push(next);      
                visited.add(next); // mark node as visited when adding to stack!       
            }      
        }      
    }//while      
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样要注意的一点就是在把一个节点入栈的时刻就将其标记为已访问.    &lt;/p&gt;
&lt;h2&gt;(for Trees) DFS with depth&lt;/h2&gt;
&lt;p&gt;和上次&lt;a href="http://x-wei.github.io/bfs-summary.html"&gt;bfs&lt;/a&gt;一样, &lt;strong&gt;对于树而言&lt;/strong&gt;, 在dfs搜索的过程中也可以记录该节点所在的depth.    &lt;/p&gt;
&lt;p&gt;非递归版本的程序就是用一个和上面&lt;code&gt;s&lt;/code&gt;平行的栈记录深度, 程序和"BFS with distance"很像. 递归版本只要在函数签名里加上一个depth的参数即可. 这两个实现都很简单, 就不写了.    &lt;/p&gt;
&lt;p&gt;注意这个只对于树有意义, 对一个图而言没有depth一说...    &lt;/p&gt;
&lt;h2&gt;DFS for binary tree: Preorder traversal&lt;/h2&gt;
&lt;p&gt;dfs另一个有用的性质是: 对于&lt;strong&gt;二叉树&lt;/strong&gt;而言, dfs得到的节点顺序正是其前序遍历(preorder traversal)的顺序.    &lt;/p&gt;
&lt;p&gt;其实前序遍历的定义就相当于是一个递归版本的dfs了:  &lt;br /&gt;
&lt;code&gt;[preorder(node)] = node.val + [preorder(node.left)] + [preorder(node.right)]&lt;/code&gt;   &lt;/p&gt;
&lt;h2&gt;DFS with path&lt;/h2&gt;
&lt;p&gt;如果在访问到某一个节点的时候想同时获得到该点的路径, 其实也不麻烦.    &lt;/p&gt;
&lt;p&gt;对于递归版本的dfs而言, 可以在参数里面用一个List记录到当前节点的路径.    &lt;/p&gt;
&lt;p&gt;非递归的版本的话... 貌似不是很trival, 需要对stack做好维护, 可能需要一个hashmap什么的... 以后有空了再写写.    &lt;/p&gt;
&lt;h2&gt;Cycle Detection&lt;/h2&gt;
&lt;p&gt;判断一个有向图是否存在回路是一个非常重要的问题, 简单修改dfs就可以做到了.    &lt;/p&gt;
&lt;p&gt;在递归版本的dfs里, 我们对每一个点改为&lt;strong&gt;三种标记&lt;/strong&gt;:  &lt;br /&gt;
&lt;em&gt;未访问过(0), 正在访问其邻居节点(1), 已经访问完该节点以及所有该节点可以到达的节点(2)&lt;/em&gt;.    &lt;/p&gt;
&lt;p&gt;什么时候会出现回路呢? &lt;em&gt;就是当前节点v的一个邻居u的状态为1的时候&lt;/em&gt;. 因为该节点状态为1, 即还没有把它以后的节点全部遍历, 所以当前节点v肯定可以从u到达, 而现在又可以从v到达u, 所以构成一个回路.    &lt;/p&gt;
&lt;p&gt;为了表示一个节点的三种状态, 我们把visited的定义改一下, 定义为一个hashmap:     &lt;br /&gt;
&lt;code&gt;HasheMap&amp;lt;GraphNode, Boolean&amp;gt; visited = new HasheMap&amp;lt;GraphNode, Boolean&amp;gt;();&lt;/code&gt;    &lt;/p&gt;
&lt;p&gt;节点不在visited表示还未访问过, 节点对应为false表示正在访问, 节点对应为true表示已经访问该节点以及所有可以从它到达的节点.    &lt;/p&gt;
&lt;p&gt;写一下代码:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public void DFS(GraphNode nd){      
    visited.put(nd, false); // mark as status-1   
    for(GraphNode next: nd.neighbors){   
        if( !visited.contains(next) )   
            DFS(next);   
        else if(visited.get(next)==false) // found cycle   
            System.out.println(&amp;quot;Cycle detected!!!&amp;quot;);   
    }// now all touchable nodes from nd are visited   
    visited.put(nd, true); // mark as status-2   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;非递归版本的话貌似也不很容易, 暂时不写了, 以后有空了考虑一下...   &lt;/p&gt;
&lt;h2&gt;Topology Sort&lt;/h2&gt;
&lt;p&gt;这一节(以及上一节)参考这个非常棒的视频: &lt;a href="https://class.coursera.org/algo-003/lecture/52"&gt;https://class.coursera.org/algo-003/lecture/52&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;拓扑排序是一个dfs的应用, 所谓拓扑排序是指在一个DAG(有向无回路图)里给每个节点定义一个顺序(v1...vn), 使得按照这个顺序遍历的节点, 每一个节点vi都是之前遍历过的的节点(v1 ~ vi-1)所指向的(或没有任何其他节点指向的).    &lt;/p&gt;
&lt;p&gt;好像还没说清楚... 拓扑排序的一个应用就是对于各种依赖性(比如学习课程A需要先学习过课程B)组成的图寻找一个节点遍历的顺序使其可行.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;propositions&lt;/strong&gt;:    &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;拓扑排序的结果不唯一.    &lt;/li&gt;
&lt;li&gt;有回路的图不存在拓扑顺序.   &lt;/li&gt;
&lt;li&gt;如果一个节点没有出边, 那么它可以放在拓扑排序的最后面(没有节点以来它).   &lt;/li&gt;
&lt;li&gt;如果一个节点没有入边, 那么它可以放在拓扑排序的最后面.    &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单修改一下递归的dfs就可以处理拓扑排序: 维护一个计数器&lt;code&gt;K&lt;/code&gt;(初始化为n=所有节点数), 每当一个点已经遍历完毕(所有通过这个点可以到达的点都已经被走过)以后, 就把这个点的顺序设为K, 同时减少K.    &lt;/p&gt;
&lt;p&gt;就用一个HashMap来为每个节点关联一个序号好了:  &lt;br /&gt;
&lt;code&gt;HasheMap&amp;lt;GraphNode, Integer&amp;gt; order = new HasheMap&amp;lt;GraphNode, Integer&amp;gt;();&lt;/code&gt;    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public void DFS(GraphNode nd){      
    for(GraphNode next: nd.neighbors){   
        if( !visited.contains(next) )   
            DFS(next);   
    }// all touchable nodes from nd are visited   
    order.put(nd, K--);   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;是不是特别简单, 太神奇了!    &lt;/p&gt;
&lt;p&gt;上面只是对于一个点进行的, 为了给所有点拓扑排序, 只要从一个没有出边的节点出发进行遍历, 一直运行到所有的节点都已经访问过为止.    &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>Approximate Retrieval(2): simHash</title><link href="http://x-wei.github.io/simhash.html" rel="alternate"></link><updated>2015-10-08T17:30:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/simhash.html</id><summary type="html">&lt;p&gt;除了上次介绍的&lt;a href="http://x-wei.github.io/minhash.html"&gt;minhash&lt;/a&gt;方法以外, 还有一种常见的hash方法, 叫做simHash. 这里做简要介绍.  &lt;br /&gt;
这个hash函数的背景和上次一样, 还是考虑把文本抽象为ngram的集合:  &lt;br /&gt;
&lt;img alt="" src="simhash/pasted_image.png" /&gt; &lt;br /&gt;
然后相似度依旧是Jaccard similarity:  &lt;br /&gt;
&lt;img alt="" src="simhash/pasted_image001.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;simHash&lt;/h2&gt;
&lt;p&gt;simHash的方法听上去比minHash还要简单:    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对一个文档&lt;em&gt;d&lt;/em&gt;中的每一个term(ngram, shingle) &lt;em&gt;t&lt;/em&gt;, 计算其hashcode(比如用java内建的&lt;code&gt;Object.hashCode()&lt;/code&gt;函数) &lt;em&gt;hash(t)&lt;/em&gt;.    &lt;/li&gt;
&lt;li&gt;把d中所有term的&lt;em&gt;hash(t)&lt;/em&gt;合成为一个hashcode作为d的hashcode &lt;em&gt;simHash(d)&lt;/em&gt;: &lt;em&gt;simHash(d)&lt;/em&gt;的长度与&lt;em&gt;hash(t)&lt;/em&gt;相同, &lt;em&gt;simHash(d)&lt;/em&gt;的第k个bit的取值为所有&lt;em&gt;hash(t)&lt;/em&gt;第k个bit的&lt;strong&gt;众数&lt;/strong&gt;.    &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;写成数学表达式很吓人, 其实只不过不断在{0,1}和{-1,+1}之间变而已, 总之就是对所有hash(t)的每一位进行统计, 如果1多就放1, 否则就放0...  &lt;br /&gt;
&lt;img alt="" src="simhash/pasted_image002.png" /&gt;   &lt;/p&gt;
&lt;p&gt;关于为什么simHash可以满足近邻hash的条件(即两个文档jacccard sim越大, 其simhash相等的可能性越大), 不知道... 不过可以参考这个链接: &lt;a href="http://matpalm.com/resemblance/simhash/"&gt;http://matpalm.com/resemblance/simhash/&lt;/a&gt;    &lt;/p&gt;
&lt;h2&gt;simHash VS minHash&lt;/h2&gt;
&lt;p&gt;下面来比较一下二者的差别.  &lt;br /&gt;
首先是表示方式:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;simHash只需要直接拿term的集合即可使用   &lt;/li&gt;
&lt;li&gt;minHash需要首先建立字典, 然后用一个binary的向量(长度为字典长度)表示一个文档   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其次是取值范围:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;simHash得到的hash范围取决于应用到每个term上的hash函数的范围, simHash与所有term的hash位数相同.   &lt;/li&gt;
&lt;li&gt;minHash的范围等于字典的长度, 如果字典里有M个term那么minHash取值在1到M之间.    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是minHash也有优点:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要生成不同的simHash比较困难, 取决于应用在每个term上的hash函数有多少种.    &lt;/li&gt;
&lt;li&gt;生成不同的minHash非常容易: 每次shuffle就可以对一篇文章生成不同的minHash.    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以如果我们想要用多个hash来索引一个文章的时候, minHash可以很容易实现.    &lt;/p&gt;</summary><category term="ml"></category></entry><entry><title>广度优先搜索(BFS)小结</title><link href="http://x-wei.github.io/bfs-summary.html" rel="alternate"></link><updated>2015-10-08T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/bfs-summary.html</id><summary type="html">&lt;p&gt;今天总结一下广度优先搜索(BFS). BFS是树/图的遍历的常用算法之一, 对于没有边权重的图来说可以计算最短路径.  &lt;br /&gt;
由于树的BFS只是图的BFS的一种特殊情况, 而且比较简单不需要visited标记, 这里只写一下图的BFS好了.  &lt;br /&gt;
先定义一个Graph类, 这里在每一个节点保存邻居信息:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class GraphNode{   
    int val;   
    List&amp;lt;GraphNode&amp;gt; neighbors;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;BFS for trees/graphs&lt;/h2&gt;
&lt;p&gt;图的遍历需要注意不走重复节点, 所以需要一个HashSet(名字叫visited)来保存哪些节点已经访问过了. 需要注意的是, &lt;em&gt;在把一个节点放进队列queue的时刻就要把它放进visited&lt;/em&gt;, 而不是在队列里取出来的时刻再放.    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public void BFS(GraphNode start){   
    LinkedList&amp;lt;GraphNode&amp;gt; q = new LinkedList&amp;lt;GraphNode&amp;gt;();   
    HasheSet&amp;lt;GraphNode&amp;gt; visited = new HasheSet&amp;lt;GraphNode&amp;gt;();   
    q.push(start);   
    visited.add(start);   
    while(!q.empty()){   
        GraphNode cur = q.poll();   
        System.out.println(cur.val);   
        for(GraphNode next: cur.children){    
            if(!visited.contains(next)){   
                q.push(next);   
                visited.add(next); // mark node as visited when adding to queue!    
            }   
        }   
    }//while   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;BFS with distance&lt;/h2&gt;
&lt;p&gt;在BFS的同时我们可以记录从start节点到当前node的距离, 方法是把一个距离信息同时入队(封装一个&lt;code&gt;Pair&amp;lt;GraphNode, Integer&amp;gt;&lt;/code&gt;), 或者使用一个与queue&lt;em&gt;平行&lt;/em&gt;的队列保存距离信息.  &lt;br /&gt;
在上面的代码中, 加入:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;//...   
LinkedList&amp;lt;Integer&amp;gt; distq = new LinkedList&amp;lt;Integer&amp;gt;();   
distq.push(0);// distance from start to start   
//...   
// in the while(!q.empty()) loop:    
    int d = distq.poll();//get distance from start to current node   
    for(GraphNode next: node.children){   
        distq.push(d+1);// distance from start to next node   
        //...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于Tree的情况来说, 这里的dist其实就是当前节点的深度depth.    &lt;/p&gt;
&lt;h2&gt;properties&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;性质1:&lt;/strong&gt;  &lt;br /&gt;
每个节点node的distance都是node距离起始点start的最短距离.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性质2:&lt;/strong&gt;  &lt;br /&gt;
距离start近的节点(depth浅的节点)一定比距离start远的节点早被访问到.    &lt;/p&gt;
&lt;p&gt;这是对一个树BFS的时候节点的访问顺序:  &lt;br /&gt;
&lt;img alt="" src="bfs-summary/pasted_image.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;BFS "by layer"&lt;/h2&gt;
&lt;p&gt;参考上面的性质, 可以一次处理"一层"的节点, "一层"的意思是指所有节点距离start的距离相同. 代码在while循环里不是一次poll一个节点, 而是一次把queue的内容处理完, 然后换新的queue进入下一次while循环. 代码重新写一下:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public void BFS(GraphNode start){   
    ArrayList&amp;lt;GraphNode&amp;gt; q = new ArrayList&amp;lt;Tree&amp;gt;();   
    HasheSet&amp;lt;GraphNode&amp;gt; visited = new HasheSet&amp;lt;GraphNode&amp;gt;();   
    q.push(start);   
    visited.add(start);   
    while(!q.empty()){   
        ArrayList&amp;lt;GraphNode&amp;gt; newq = new ArrayList&amp;lt;Tree&amp;gt;();// create a new queue   
        for(GraphNode cur: q){// deal with all nodes in the queue    
            System.out.print(cur.val+&amp;quot;, &amp;quot;);// all nodes in q are of the same distance/depth   
            for(GraphNode next: cur.children)    
                if(!visited.contains(next))   
                    { newq.push(next);visited.add(next); }   
        }   
        System.out.println();   
        q = newq;//replace q with newq   
    }//while   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上程序每次打印一行, 第i行包括了距start距离为i的所有节点.  &lt;br /&gt;
由于这样的话每次不必在队首poll出元素(而是依次处理所有queue的元素), 所以可以改用ArrayList. 此时while循环里的不变量是: 所有q里面的节点距离start的距离都相同.    &lt;/p&gt;
&lt;h2&gt;complexity&lt;/h2&gt;
&lt;p&gt;假设一个图有N个节点和M条边, BFS会走遍所有节点, 时间是O(N), 然后由于每个节点会检查所有的出边, 最终所有的边都会被检查过, 时间是O(M), 所以BFS的时间复杂度是&lt;strong&gt;O(N+M)&lt;/strong&gt;.    &lt;/p&gt;
&lt;p&gt;队列里面最多可能存放所有节点, 空间复杂度为&lt;strong&gt;O(N)&lt;/strong&gt;.    &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>Mindmap of algorithms &amp; data structures</title><link href="http://x-wei.github.io/algo-ds-mindmap.html" rel="alternate"></link><updated>2015-10-05T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algo-ds-mindmap.html</id><summary type="html">&lt;p&gt;Here is a mindmap of the common algorithms and data structures, it can give an overview of the algorithmic terms.    &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algo-ds-mindmap/Algo%20%26%20DS.png" /&gt;   &lt;/p&gt;
&lt;p&gt;I shall update its content later on. And maybe write some blog entries on some of the items.   &lt;/p&gt;
&lt;p&gt;This mindmap is drawn using &lt;a href="http://www.xmind.net/"&gt;xmind&lt;/a&gt;.   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>minHash: 一种快速approximate retrieval方法</title><link href="http://x-wei.github.io/minhash.html" rel="alternate"></link><updated>2015-09-27T11:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/minhash.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;approximate retrieval&lt;/strong&gt;(相似搜索)这个问题之前实习的时候就经常遇到: 如何快速在大量数据中如何找出相近的数据.    &lt;/p&gt;
&lt;p&gt;问题描述: 假设有N个数据, 并且对于他们有一个相似度(或距离)的度量函数&lt;code&gt;sim(i,j)&lt;/code&gt;, 我们的问题就是如何快速找出所有N个点中相似度较大的i和j组合.    &lt;/p&gt;
&lt;p&gt;乍一看这个问题必须要对所有的(i,j)计算相似度, 但是N^2的复杂度在N太大的情况下是不能够忍受的.    &lt;/p&gt;
&lt;h2&gt;kdtree&lt;/h2&gt;
&lt;p&gt;之前在algo-note里面遇到过&lt;a href="http://x-wei.github.io/algoI_week5_2.html"&gt;kdtree&lt;/a&gt;, 用它可以使得寻找nearest neighbor的复杂度减少到logN. 但是这种情况对于维度低一点(比如二三维)的情况合适, 维度到了成千上万的时候并不是很好的选择, 所以这里不多讨论.    &lt;/p&gt;
&lt;h2&gt;simhash&lt;/h2&gt;
&lt;p&gt;另一个思路是, 使用某个hash函数, 对于每一个数据计算一个哈希值. 这个hash函数要满足: &lt;strong&gt;当i和j的相似度很高的时候, hash(i)和hash(j)的值(很可能)相同.&lt;/strong&gt; 这次介绍的minHash就是这样的一种方法.    &lt;/p&gt;
&lt;h2&gt;Jaccard similarity&lt;/h2&gt;
&lt;p&gt;明确问题含义, 首先需要定义相似度. 这里主要考虑文本相似度的问题, 假设字典D有M个term(term可以是单词, 也可以是n-gram或叫shingle): &lt;br /&gt;
&lt;img alt="" src="minhash/pasted_image.png" /&gt;   &lt;/p&gt;
&lt;p&gt;一段文本(document i)可以用binary vectorization变为一个binary的向量:  &lt;br /&gt;
&lt;img alt="" src="minhash/pasted_image001.png" /&gt; &lt;br /&gt;
(这里没有用TF或者TFIDF, 只用一个简单的binary向量化, 因为只有binary的时候才适合我们接下来的推导...)   &lt;/p&gt;
&lt;p&gt;每个document可以看作一些term的&lt;em&gt;集合&lt;/em&gt;, 集合之间的相似度有一个经典的度量: jaccard similarity. &lt;br /&gt;
对集合S1和S2, 他们的相似度定义为:  &lt;br /&gt;
&lt;img alt="" src="minhash/pasted_image003.png" /&gt; &lt;br /&gt;
也很好理解, 重合部分比例越高相似度就越高, 另外jaccard-sim取值在0到1之间.    &lt;/p&gt;
&lt;p&gt;对于document i和j, 他们的向量形式分别是di和dj. 现在我们希望计算hash(di)和hash(dj), 使得:    &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="minhash/pasted_image004.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;minHash&lt;/h2&gt;
&lt;p&gt;min hash的思路是这样的, 首先生成一个随机的(1...M)的排序(permutation)π:  &lt;br /&gt;
&lt;img alt="" src="minhash/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;p&gt;然后, 对于每个document d, 都按照这个permutation, 把d的分量从新排列:  &lt;br /&gt;
&lt;img alt="" src="minhash/pasted_image006.png" /&gt;   &lt;/p&gt;
&lt;p&gt;然后定义&lt;code&gt;minHash(di)&lt;/code&gt;为permutation以后的di里的第一个不为0的位置:  &lt;br /&gt;
&lt;img alt="" src="minhash/pasted_image008.png" /&gt; &lt;br /&gt;
(上面个公式里d的下标只是代表第i个文本, 并不代表分量... 我应该写上标的..) &lt;br /&gt;
所以&lt;code&gt;minHash()&lt;/code&gt;返回1到M之间的一个数.    &lt;/p&gt;
&lt;h2&gt;proof&lt;/h2&gt;
&lt;p&gt;现在证明一下为什么这样选择minHash函数可以保证两个文本的哈希值相等的概率为他们的jaccard similarity.    &lt;/p&gt;
&lt;p&gt;对于d2和d2, 我们分别查看π(d1)和π(d2)的每个分量, 这两个数有(11), (10), (01), (00)这四种可能, 分别记每种可能性的出现次数为a,b,c,d:  &lt;br /&gt;
&lt;img alt="" src="minhash/pasted_image009.png" /&gt; &lt;br /&gt;
那么jaccard similarity可以表示为:  &lt;br /&gt;
&lt;img alt="" src="minhash/pasted_image010.png" /&gt; &lt;br /&gt;
再看&lt;code&gt;minHash()&lt;/code&gt;是如何计算的, 当π(d1)_k和π(d2)_k都为0的时候会继续增加k, 一直到π(d1)_k和π(d2)_k中某一个为1.  &lt;br /&gt;
那么&lt;code&gt;minHash(d1)==minHash(d2)&lt;/code&gt;的情况就是二者都为1的情况, 这种情况的可能性为:  &lt;br /&gt;
&lt;img alt="" src="minhash/pasted_image011.png" /&gt; &lt;br /&gt;
这个概率恰好就是jaccard similarity.    &lt;/p&gt;</summary><category term="ml"></category></entry><entry><title>linux系统添加swap分区&amp;调整swapness</title><link href="http://x-wei.github.io/linux-swap.html" rel="alternate"></link><updated>2015-09-27T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/linux-swap.html</id><summary type="html">&lt;p&gt;当年装mint 17.1的时候心想我的电脑有4GB内存怎么可能不够用, 于是果断没有分一个swap分区, 呵呵...   &lt;/p&gt;
&lt;p&gt;然后就看到chrome这几年来吃内存越来越严重, 导致我开多几个标签页再开eclipse的话电脑就很有可能直接卡死... 郁闷啊 ! 于是决定给系统增加一个swap分区. 之前给&lt;a href="http://thealternative.ch/index.php?view=linuxdays"&gt;thealternative&lt;/a&gt;写邮件询问这件事, Sandro Kalbermatter同学热情回复了我告诉我怎么做, 按照他说的果然成功了, 特此一记.    &lt;/p&gt;
&lt;h2&gt;step1. 建立swap分区&lt;/h2&gt;
&lt;p&gt;首先, 用gparted调整磁盘分区, 缩小一个磁盘的大小, 然后用空出来的空间新建一个swap分区.    &lt;/p&gt;
&lt;p&gt;关于swap分区应该多大, 根据&lt;a href="http://www.linux.com/news/software/applications/8208-all-about-linux-swap-space"&gt;这个帖子&lt;/a&gt;, 大约是内存的2-3倍, 不过我只是分了和内存一样大的4G空间, 感觉这样应该够用了(吧).   &lt;/p&gt;
&lt;p&gt;我是把存放文件的500G分区缩小, 这个过程会比较慢, 大概二十多分钟以后才结束:  &lt;br /&gt;
&lt;img alt="" src="linux-swap/pasted_image.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;step2. 编辑fstab&lt;/h2&gt;
&lt;p&gt;建立好了swap分区以后, 打开终端, 输入&lt;code&gt;sudo blkid&lt;/code&gt;查看所有的磁盘分区.    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;sudo blkid   
/dev/sda1: &lt;span class="nv"&gt;LABEL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;FILES&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;UUID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ddefc0a7-30a1-42fb-a71a-0aebb55cb0b3&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;TYPE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ext2&amp;quot;&lt;/span&gt;    
/dev/sda2: &lt;span class="nv"&gt;UUID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;952b70b9-c7ee-4adf-9ceb-ac631ed8d7eb&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;TYPE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;swap&amp;quot;&lt;/span&gt;    
/dev/sdb1: &lt;span class="nv"&gt;LABEL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;WIN7&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;UUID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;D268862068860407&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;TYPE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ntfs&amp;quot;&lt;/span&gt;    
/dev/sdb5: &lt;span class="nv"&gt;UUID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;0ee51625-2fe3-49c8-b388-53076bce7955&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;TYPE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ext4&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后看到了swap分区的UUID以后, 将其复制, 然后编辑fstab文件: &lt;code&gt;sudo leafpad /etc/fstab&lt;/code&gt;:   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;UUID=put-the-uud-here       none            swap            defaults  0 0&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;然后重启, 就可以看到swap分区了!  &lt;br /&gt;
&lt;img alt="" src="linux-swap/pasted_image001.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;step3. 调整swapness&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://askubuntu.com/questions/103915/how-do-i-configure-swappiness"&gt;swapness&lt;/a&gt;是一个在0到100之间的数, 当系统的内存剩余不到百分之swapness的时候, 开始使用swap分区. 默认的系统swapness是60, 就是内存占用超过40%的时候就开始使用swap分区了.    &lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;cat /proc/sys/vm/swappiness&lt;/code&gt;可以查看当前的swapness.    &lt;/p&gt;
&lt;p&gt;由于内存读写要比swap分区快很多, 在内存足够的情况下完全没有必要使用swap, 于是修改swapness为20:    &lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo leafpaf /etc/sysctl.conf&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;在文件里加入一行: &lt;code&gt;vm.swappiness = 10&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;重启即可...   &lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>lin-reg = max-likelihood: 贝叶斯视角看线性回归</title><link href="http://x-wei.github.io/linreg-bayes.html" rel="alternate"></link><updated>2015-09-26T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/linreg-bayes.html</id><summary type="html">&lt;p&gt;几乎所有的ml课都是从线性回归讲起, ETH的课也不例外. 不过这次老师用了贝叶斯的视角讲这个问题, 自从高中接触丁老师讲的线性回归以来 第一次听到一个不同于最小二乘的解读, 感觉很有意思. 又想起来刘未鹏那篇非常棒的&lt;a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/"&gt;博客&lt;/a&gt;, 于是想记录一下.    &lt;/p&gt;
&lt;h2&gt;notation&lt;/h2&gt;
&lt;p&gt;首先有n个数据点:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image001.png" /&gt; &lt;br /&gt;
其中y是实数, 每个x有d个维度, 为了方便表示截距, 再给x加入一个始终等于1的维度:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image002.png" /&gt; &lt;br /&gt;
例子: y代表房价, x代表了房子的面积, 使用时间, 距离市中心的距离等因素.   &lt;/p&gt;
&lt;h2&gt;least square viewpoint&lt;/h2&gt;
&lt;p&gt;在最小二乘的视角里, 线性回归是用一个x的线性函数拟合y:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image003.png" /&gt; &lt;br /&gt;
使得拟合结果和观测结果的误差尽量小.  &lt;br /&gt;
不过这次不说最小二乘, 所以接下来不讨论这个思路...   &lt;/p&gt;
&lt;h2&gt;assumptions in Bayes viewpoint&lt;/h2&gt;
&lt;p&gt;在贝叶斯视角里, 我们假设: &lt;br /&gt;
&lt;strong&gt;假设1. y = 某个x的线性函数 + 观测噪音&lt;/strong&gt; &lt;br /&gt;
即:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image006.png" /&gt; &lt;br /&gt;
其中εi是一个&lt;em&gt;随机变量&lt;/em&gt;, 所以y也是一个随机变量.  &lt;br /&gt;
另外再有一个比较强的假设: &lt;br /&gt;
&lt;strong&gt;假设2.  ε服从centered高斯分布, iid.&lt;/strong&gt; &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image007.png" /&gt; &lt;br /&gt;
(btw, 对一个随机变量建模, 一般来说, 连续随机变量就用高斯, 离散随机变量用泊松)   &lt;/p&gt;
&lt;h2&gt;Bayes formula&lt;/h2&gt;
&lt;p&gt;贝叶斯公式长这个样子:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image004.png" /&gt; &lt;br /&gt;
只看最左边和最右边的内容, 表达为:    &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;posterior = likelihood * prior &lt;br /&gt;
后验概率 = 可能性 * 先验概率   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(上面其实应该是"正比于"而不是等号, 由于P(Y)我们并不关心, 所以可以直接忽略之)   &lt;/p&gt;
&lt;p&gt;公式里Y代表可以观察到结果, X代表结果背后不能直接观察的量(&lt;em&gt;不要和数据里的XY混淆...&lt;/em&gt;).  &lt;br /&gt;
贝叶斯公式的意义在于, 让我们从可观测的Y反推不可观测的X的概率. 既然我们已经得到了观测结果Y, 那么找到使得后验概率最大的X就说明我们在观测基础上得到了最可信的X的估计.    &lt;/p&gt;
&lt;p&gt;那么在我们这个问题里, X代表模型, 即某一个β的取值; Y代表观测结果, 即我们看到的n个数据点.  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image005.png" /&gt; &lt;br /&gt;
所以我们的问题就是: 在已经有了这些观测点的基础之上, 应该选那个β的取值, 使得后验概率最大?   &lt;/p&gt;
&lt;h2&gt;lin-reg = max-likelihood&lt;/h2&gt;
&lt;p&gt;线性回归认为, 对于任意的β的取值, 其先验概率都是一样的, 所以在贝叶斯公式里可以忽略ℙ(X), 只需要考虑最大化likelihood ℙ(Y|​X)即可 — 再一次, 不要把贝叶斯的XY和数据的X和Y混淆...  &lt;br /&gt;
即选择β: &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image015.png" /&gt;  &lt;br /&gt;
由于随机变量y只是随机变量ε的一个函数(且给定β, ε和y一一对应):  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image008.png" /&gt; &lt;br /&gt;
所以可以最大化ε的likelihood:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image009.png" /&gt; &lt;br /&gt;
由于之前对ε有假设:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image010.png" /&gt; &lt;br /&gt;
那么:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image011.png" /&gt; &lt;br /&gt;
(不要以为ε独立于β: ε=y - βt x, 所以上面表达式里其实还是有β的. ) &lt;br /&gt;
⇒ 两边取log并加上负号:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image014.png" /&gt; &lt;br /&gt;
Voila, 所以极大似然=最小二乘!  &lt;br /&gt;
对, 饶了一圈还是最小二乘, 但是这样的意义变了, 明白了为什么要最小化平方误差这个值.   &lt;/p&gt;
&lt;h2&gt;precise solution to linreg&lt;/h2&gt;
&lt;p&gt;(notation有点混乱了, 之前贝叶斯里面应该用AB而不是用XY的orz...) &lt;br /&gt;
每个x是一个列向量, 这里, 把所有数据用矩阵形式表示:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image016.png" /&gt; &lt;br /&gt;
矩阵表示的好处是平方误差可以用矩阵表示:  &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image017.png" /&gt; &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image018.png" /&gt; &lt;br /&gt;
对矩阵运算求偏导, 偏导为0的时候即可得到最优的β: &lt;br /&gt;
&lt;img alt="" src="linreg-bayes/pasted_image019.png" /&gt;   &lt;/p&gt;</summary><category term="ml"></category></entry><entry><title>numpy: list, array, matrix小结</title><link href="http://x-wei.github.io/list_array_matrix.html" rel="alternate"></link><updated>2015-09-09T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/list_array_matrix.html</id><summary type="html">&lt;p&gt;python科学计算包的基础是numpy, 里面的array类型经常遇到. 一开始可能把这个array和python内建的列表(list)混淆, 这里简单总结一下列表(list), 多维数组(np.ndarray)和矩阵(np.matrix)的区别.    &lt;/p&gt;
&lt;h2&gt;list列表&lt;/h2&gt;
&lt;p&gt;列表属于python的三种基本集合类型之一, 其他两种是元组(tuple)和字典(dict). tuple和list区别主要在于是不是mutable的.    &lt;/p&gt;
&lt;p&gt;list和java里的数组不同之处在于, python的list可以包含任意类型的对象, 一个list里可以包含int, string或者其他任何对象, 另外list是可变长度的(list有&lt;code&gt;append&lt;/code&gt;, &lt;code&gt;extend&lt;/code&gt;和&lt;code&gt;pop&lt;/code&gt;等方法).   &lt;/p&gt;
&lt;p&gt;所以, python内建的所谓"列表"其实是功能很强大的数组, 类比一下可以说它对应于java里面的&lt;code&gt;ArrayList&amp;lt;Object&amp;gt;&lt;/code&gt; .    &lt;/p&gt;
&lt;h2&gt;ndarray多维数组&lt;/h2&gt;
&lt;p&gt;ndarray是numpy的基石, 其实它更像一个java里面的标准数组: 所有元素有一个相同数据类型(dtype), 不过大小不是固定的.    &lt;/p&gt;
&lt;p&gt;ndarray对于大计算量的性能非常好, 所以list要做运算的时候一定要先转为array(&lt;code&gt;np.array(_a_list_)&lt;/code&gt;).    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ndarray带有一些非常实用的&lt;a href="http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html"&gt;函数&lt;/a&gt;, 列举几个常用的: &lt;code&gt;sum, cumsum, argmax, reshape, T, ...&lt;/code&gt;   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ndarray有&lt;a href="http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#arrays-indexing"&gt;fancy indexing&lt;/a&gt;, 非常实用, 比如: &lt;code&gt;a[a&amp;gt;3]&lt;/code&gt; 返回数组里大于3的元素   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ndarray之间的乘法: 如果用乘法运算符&lt;code&gt;*&lt;/code&gt;的话, 返回的是每个位置元素相乘(类似matlab里面的&lt;code&gt;.*&lt;/code&gt;), 想要矩阵相乘需要用&lt;code&gt;dot()&lt;/code&gt;.   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常见矩阵的生成: &lt;code&gt;ones, zeros, eye, diag, ...&lt;/code&gt;   &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;matrix矩阵&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;matrix是ndarray的子类&lt;/em&gt;, 所以前面ndarray那些优点都保留了.    &lt;/p&gt;
&lt;p&gt;同时, matrix全部都是二维的, 并且加入了一些更符合直觉的函数, 比如对于matrix对象而言, 乘号运算符得到的是矩阵乘法的结果. 另外&lt;code&gt;mat.I&lt;/code&gt;就是逆矩阵...   &lt;/p&gt;
&lt;p&gt;不过应用最多的还是ndarray类型.    &lt;/p&gt;
&lt;p&gt;参考资料:  &lt;br /&gt;
&lt;a href="http://docs.scipy.org/doc/numpy/reference/index.html"&gt;http://docs.scipy.org/doc/numpy/reference/index.html&lt;/a&gt; &lt;br /&gt;
&lt;a href="http://math.mad.free.fr/depot/numpy/base.html"&gt;http://math.mad.free.fr/depot/numpy/base.html&lt;/a&gt; &lt;br /&gt;
&lt;a href="http://stackoverflow.com/questions/4151128/what-are-the-differences-between-numpy-arrays-and-matrices-which-one-should-i-u"&gt;http://stackoverflow.com/questions/4151128/what-are-the-differences-between-numpy-arrays-and-matrices-which-one-should-i-u&lt;/a&gt;   &lt;/p&gt;</summary><category term="python"></category></entry><entry><title>[Algorithms I] Week 6 Hash Tables</title><link href="http://x-wei.github.io/algoI_week6.html" rel="alternate"></link><updated>2015-09-01T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week6.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Can we do better than BST if we do not need ordered operations ?&lt;/em&gt;   &lt;/p&gt;
&lt;p&gt;(No compare methods, use equals method)   &lt;/p&gt;
&lt;p&gt;Idea: save items in an array.  &lt;br /&gt;
&lt;strong&gt;Hash function&lt;/strong&gt;: method for calclulating the array index of  a key.    &lt;/p&gt;
&lt;p&gt;Issues:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;computing hash function   &lt;/li&gt;
&lt;li&gt;equality tests   &lt;/li&gt;
&lt;li&gt;collision resolution   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Classic space-time tradeoff.&lt;/em&gt;   &lt;/p&gt;
&lt;h1&gt;1. Hash Functions&lt;/h1&gt;
&lt;p&gt;Goal: scramble the keys uniformly to produce a table index.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;effcient to compute   &lt;/li&gt;
&lt;li&gt;all indices are equally likely for any key   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;challenge: need different approach for different key types.    &lt;/p&gt;
&lt;h2&gt;Java's hashing&lt;/h2&gt;
&lt;p&gt;All java object has a methode &lt;code&gt;int hashCode()&lt;/code&gt; &lt;br /&gt;
requirement:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if x.equals(y) ⇒ x.hashCode()==y.hashCode()   &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(hopefully) if x.equals(y)==false ⇒ x.hashCode!=y.hashCode()   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Default implementation: &lt;em&gt;memory address&lt;/em&gt; for x.    &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Custom implementations for standard types: Integer, Double, String, File, URL, Date...   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image.png" /&gt; &lt;br /&gt;
Strings: Horner's method — compute a polynome.  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image001.png" /&gt; &lt;br /&gt;
recipe for user-defined types:  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image002.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Modeular hasing&lt;/h2&gt;
&lt;p&gt;(hash code VS hash function)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Hash code&lt;/em&gt;: 32-bit integer between -2^31 and 2^31-1 &lt;em&gt;(can be negative!!)&lt;/em&gt;   &lt;/li&gt;
&lt;li&gt;&lt;em&gt;Hash function&lt;/em&gt;: integer between 0 and M-1 (used directly as array index, should &amp;gt;=0)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;BUG code:&lt;/strong&gt;    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private int hash(Key k){   
    return k.hashCode()%M;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;→ bug: &lt;em&gt;number returned can be negative !&lt;/em&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1-in-billion bug code:&lt;/strong&gt;  &lt;br /&gt;
&lt;code&gt;return Math.abs(k.hashCode()) % M;&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;→ bug: Math.abs() returns negative numbers for -2^31 &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image003.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;correct code:&lt;/strong&gt; &lt;br /&gt;
just take the first 31 bits: x&amp;amp;0x7fffffff &lt;br /&gt;
&lt;code&gt;return k.hashCode()&amp;amp;0x7fffffff % M;&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;另一个hash的思路是用random(用hashcode作为随机种子)   &lt;/p&gt;
&lt;h2&gt;uniform hasing assumption&lt;/h2&gt;
&lt;p&gt;each key is equally likely to hash to an integer between 0 and M-1   &lt;/p&gt;
&lt;p&gt;一些数学结论:  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image004.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;2. Separate Chaining&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;one strategy for collision resolution.&lt;/em&gt;  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;idea&lt;/strong&gt;: Using a table of size M &amp;lt; N,  build a list for each of the table positions.    &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image006.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class SeparateChainingHashST&amp;lt;Key, Value&amp;gt;{   
    private int M = 97;   
    private Node[] st = new Node[97];   
    private static class Node{   
        Object key, val; // no generic array creation!    
        Node next;   
        public Node(Key k, Value v, Node nxt){...}   
    }   
    int hash(Key k){   
        return (k.hashCode()&amp;amp;0x7fffffff) % M;   
    }   
    public Value get(Key k){   
        int h = hash(k);   
        for(Node x=st[h]; x!=null; x=x.next)   
            if(k.equals(x.val)) return (Value)x.val; //cast   
        return null;   
    }   
    public void put(Key k, Value v){   
        int h = hash(k);   
        for(Node x=st[h]; x!=null; x=x.next)   
            if(k.equals(x.val))    
                {x.val = v; return;}   
        st[h] = new Node(k,v,st[h]);   
    }   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意内部类Node里用的是Object — 因为不能声明generic array.    &lt;/p&gt;
&lt;h2&gt;analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;proposition&lt;/strong&gt; &lt;br /&gt;
Under the assumption of uniform hashing, the number of keys in a list is within a constant factor to N/M.  &lt;br /&gt;
&lt;em&gt;proof.&lt;/em&gt; &lt;br /&gt;
binominal distribution.   &lt;/p&gt;
&lt;p&gt;M times faster than sequential search &lt;br /&gt;
→ typical choice: M ~ N/5   &lt;/p&gt;
&lt;h1&gt;3. Linear Probing&lt;/h1&gt;
&lt;p&gt;Another approch for collision resolution.    &lt;/p&gt;
&lt;p&gt;idea: &lt;strong&gt;open addressing&lt;/strong&gt; &lt;br /&gt;
Use an array of size &lt;strong&gt;M&amp;gt;N&lt;/strong&gt;, when a key collides, &lt;em&gt;find next open slot&lt;/em&gt;.  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image007.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert: when occupied, move pointer until got open slot   &lt;/li&gt;
&lt;li&gt;search: when not found, move pointer until find or reach open slot   &lt;/li&gt;
&lt;li&gt;&lt;em&gt;delete&lt;/em&gt;: set key to null, then for all items behind this key: set to null, then insert this key......   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;array M &lt;em&gt;must&lt;/em&gt; be larger than N ⇒ array resizing is necessary.    &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class LinearProbingHashST&amp;lt;Key, Value&amp;gt;{   
    private int M, N;   
    private Object[] keys;//cannot use generic array   
    private Object[] vals;   
    public void put(Key k, Value v){   
        int i = hash(k);   
        for(;keys[i]!=null;i=(i+1)%M)   
            if(keys[i].equals(k))    
                {vals[i]=v; return;}   
        keys[i]=k;   
        vals[i]=v;   
    }   
    public Value get(Key k){   
        int h=hash(k);   
        for(;keys[h]!=null;h=(h+1)%M)   
            if(k.equals(keys[h])) return (Value)vals[h];//ugly cast   
        return null;   
    }   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;cluster&lt;/h2&gt;
&lt;p&gt;def. &lt;strong&gt;cluster&lt;/strong&gt; &lt;br /&gt;
A contiguous block of items.    &lt;/p&gt;
&lt;p&gt;New keys are more likely to hash into a cluster.    &lt;/p&gt;
&lt;p&gt;Knuth parking pb:  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image008.png" /&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image010.png" /&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image009.png" /&gt; &lt;br /&gt;
(当年Knuth就是在证明了这个以后决定写那套书)   &lt;/p&gt;
&lt;p&gt;Typical choice: &lt;strong&gt;N/M ~ 1/2&lt;/strong&gt; (3/2 for search hit and 5/2 for search miss)   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image011.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;4. Hash Table Context&lt;/h1&gt;
&lt;p&gt;widely used in applicataions.    &lt;/p&gt;
&lt;p&gt;cost for computing hash VS cost for searching:  &lt;br /&gt;
hashCode() for strings in java 1.1: exemain only 8-9 evenly spaced characters to save time. &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image012.png" /&gt;   &lt;/p&gt;
&lt;p&gt;uniform hashing assumption: performance not guaranteed... &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image013.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image014.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;one-way hash functions&lt;/strong&gt; &lt;br /&gt;
Hard to find a key that hash to a desired value, or 2 keys having the same hash value.  &lt;br /&gt;
&lt;img alt="" src="algoI_week6/pasted_image015.png" /&gt; &lt;br /&gt;
used for fingurprints or store passwords, but too expensive for ST implementations.    &lt;/p&gt;
&lt;h2&gt;Seperate chaining VS linear probing&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image016.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;variations&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image017.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;ST choice: hash tables VS balanced search trees&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week6/pasted_image018.png" /&gt;   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 5-2 Geometric Applications of BSTs</title><link href="http://x-wei.github.io/algoI_week5_2.html" rel="alternate"></link><updated>2015-08-29T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week5_2.html</id><summary type="html">&lt;h1&gt;1. 1d Range Search&lt;/h1&gt;
&lt;p&gt;Goal: &lt;em&gt;intersections&lt;/em&gt; of geometric objects.  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image.png" /&gt; &lt;br /&gt;
Solution: &lt;strong&gt;BST&lt;/strong&gt;   &lt;/p&gt;
&lt;h2&gt;1d range search&lt;/h2&gt;
&lt;p&gt;operations required:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert   &lt;/li&gt;
&lt;li&gt;search   &lt;/li&gt;
&lt;li&gt;delete   &lt;/li&gt;
&lt;li&gt;&lt;em&gt;range search&lt;/em&gt;: all keys between k1 and k2   &lt;/li&gt;
&lt;li&gt;&lt;em&gt;range count&lt;/em&gt;: how many keys are between k1 and k2   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ find points on an interval  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image001.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;implementation by BST&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;range count&lt;/strong&gt; &lt;br /&gt;
using the &lt;code&gt;rank()&lt;/code&gt; function for the BST (or use the size of a tree) &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image002.png" /&gt; &lt;br /&gt;
注意什么时候要加1...   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public int size(Key hi, Key lo){   
    if(contains(hi)) return rank(hi)-rank(lo)+1;   
    else return rank(hi) - rank(lo);   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;range search&lt;/strong&gt; &lt;br /&gt;
类似inorder traversal的方式:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;find in left subtree (if could fall into range)   &lt;/li&gt;
&lt;li&gt;check current node   &lt;/li&gt;
&lt;li&gt;find in right subtree   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_2/pasted_image003.png" /&gt; &lt;br /&gt;
running time: R+lgN (R=nb of nodes in range)   &lt;/p&gt;
&lt;h1&gt;2. Line Segment Intersection&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Orthognal line segment intersection search&lt;/em&gt;:  &lt;br /&gt;
find all intersections given N horizontal/vertical lines &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Non-degeneracy assumption: all x-coord and y-coord are distinct.    &lt;/p&gt;
&lt;p&gt;naive algo: check all pairs...   &lt;/p&gt;
&lt;h2&gt;Sweep-line algorithm&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_2/pasted_image006.png" /&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image007.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sweep a vertical line from left to right.    &lt;ul&gt;
&lt;li&gt;when hit the left end of horizontal-segment (h-seg) → insert into a BST   &lt;/li&gt;
&lt;li&gt;when hit the right end of a h-seg → delete from BST   &lt;/li&gt;
&lt;li&gt;when hit a vertical-seg: ⇒ 1d range search !    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关于怎么sweep的:&lt;/strong&gt; &lt;br /&gt;
没有仔细讲, 不过我觉得就是把所有的x坐标排好序, 有个&lt;a href="https://leetcode.com/problems/the-skyline-problem/"&gt;skyline问题&lt;/a&gt;也是涉及如何sweep的.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;proposition&lt;/strong&gt; &lt;br /&gt;
running time is NlgN+R (R=nb of intersections).  &lt;br /&gt;
&lt;em&gt;proof.&lt;/em&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sort by x-coord (or use PQ) → NlgN   &lt;/li&gt;
&lt;li&gt;insert/delete y-coord to BST → NlgN   &lt;/li&gt;
&lt;li&gt;range search → NlgN + R   &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;3. Kd-trees&lt;/h1&gt;
&lt;p&gt;An extension of BST: &lt;em&gt;2d-keys&lt;/em&gt;.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert: insert 2d points   &lt;/li&gt;
&lt;li&gt;search   &lt;/li&gt;
&lt;li&gt;range search: &lt;em&gt;find all keys lying in a 2d rectangle (h-v rectangle)&lt;/em&gt;   &lt;/li&gt;
&lt;li&gt;range count   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;gird implementation&lt;/h2&gt;
&lt;p&gt;divide space into a M-by-M grid (uniform squares). &lt;br /&gt;
space: N + M^2 &lt;br /&gt;
time: 1 + N/M^2  &lt;br /&gt;
→ choose square to balance space and time.  &lt;br /&gt;
problem: points are not uniformly distributed.  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image008.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;2d tree&lt;/h2&gt;
&lt;p&gt;Use a tree to represent the subdivision of the space.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2d tree&lt;/strong&gt;: recursively divide the space into 2 halfplanes &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image009.png" /&gt;   &lt;/p&gt;
&lt;p&gt;construct the 2d tree by adding points: &lt;em&gt;alternating between horizontal and vertical partitioning for each level of tree&lt;/em&gt;.  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image010.png" /&gt;   &lt;/p&gt;
&lt;p&gt;Data structure: BST alternating x and y-coords as key.  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image011.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Range search for 2d tree&lt;/h2&gt;
&lt;p&gt;find all points lying in a rectangle.  &lt;br /&gt;
依然类似tree traversal算法:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;check point in node   &lt;/li&gt;
&lt;li&gt;find in left subtree (if could be in range — the rectangle &lt;em&gt;intersects&lt;/em&gt; the splitting line)   &lt;/li&gt;
&lt;li&gt;find in right subtree   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_2/pasted_image012.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;analysis&lt;/strong&gt; &lt;br /&gt;
Typical case: R + lgN &lt;br /&gt;
worst case: R+ sqrt(N) (even if tree is balanced) &lt;br /&gt;
(proof is hard)   &lt;/p&gt;
&lt;h2&gt;Nearest Neighbour seach&lt;/h2&gt;
&lt;p&gt;find closest point to a query point.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;check dist from query point to node   &lt;/li&gt;
&lt;li&gt;check in left tree (&lt;em&gt;if could contain a closer point — 和两点连线与splitting line的角度有关系&lt;/em&gt;)   &lt;/li&gt;
&lt;li&gt;check in right tree   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;analysis&lt;/strong&gt; &lt;br /&gt;
typical case: lgN &lt;br /&gt;
worst case: N   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Flocking boids&lt;/strong&gt; &lt;br /&gt;
3 simple rules to get a simulation of flocking.  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image013.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Kd tree&lt;/h2&gt;
&lt;p&gt;partition the k-dim space into 2 halfspaces.  &lt;br /&gt;
cycle through k dimensions. &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image014.png" /&gt; &lt;br /&gt;
(居然时一个本科生发现的!)   &lt;/p&gt;
&lt;p&gt;Nbody simulation: &lt;br /&gt;
treat clusters as an aggregated node   &lt;/p&gt;
&lt;h1&gt;4. Interval search tree&lt;/h1&gt;
&lt;p&gt;1d interval search:　data are intervals   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert interval    &lt;/li&gt;
&lt;li&gt;search interval   &lt;/li&gt;
&lt;li&gt;delete interval   &lt;/li&gt;
&lt;li&gt;intersection query: find all intervals that intersects (lo,hi)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_2/pasted_image015.png" /&gt; &lt;br /&gt;
Nondegeneracy assumption: all left endpoint of intervals are distinct.    &lt;/p&gt;
&lt;p&gt;API:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;put(Key lo, Key hi, Value val)   
get(Key lo, Key hi)   
delete(Key lo, Key hi)   
Iterable&amp;lt;Key&amp;gt; intersects(Key lo, Key hi)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Interval search tree:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;BST using left endpoint as key   &lt;/li&gt;
&lt;li&gt;in each node: store the &lt;em&gt;max right endpoint of the subtree&lt;/em&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_2/pasted_image016.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;insert&lt;/strong&gt; &lt;br /&gt;
类似BST, 加上维护一下maxendpoint即可.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;search&lt;/strong&gt; &lt;br /&gt;
search &lt;em&gt;any one&lt;/em&gt; interval that intersects (lo,hi)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if node intersects, return   &lt;/li&gt;
&lt;li&gt;if left.maxendpoint &amp;lt; lo: go right   &lt;/li&gt;
&lt;li&gt;else: go left   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*proof. * &lt;br /&gt;
主要证明一点: if no intersection to left ⇒ then no intersection to the right &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image018.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;5. Rectangle intersection&lt;/h1&gt;
&lt;p&gt;Goal:  find all intersection among N rectangles.  &lt;br /&gt;
(non degeneracy assumption: all x and y are distinct)    &lt;/p&gt;
&lt;p&gt;bottom line: linearithmic algo.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sweep-line algorithm:&lt;/strong&gt; &lt;br /&gt;
sweep vertical line from left to right.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;when hit left part of a rect ⇒ put into an interval search tree   &lt;/li&gt;
&lt;li&gt;when hit right part of a rect ⇒ remove interval   &lt;/li&gt;
&lt;li&gt;every time befor adding ⇒ check intersection   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;reduces the 2d rect intersection pb to 1d interval search pb.&lt;/em&gt;    &lt;/p&gt;
&lt;p&gt;complexity:  &lt;br /&gt;
NlgN+RlgN   &lt;/p&gt;
&lt;p&gt;summery:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_2/pasted_image019.png" /&gt;   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 5-1 Balanced Search Trees</title><link href="http://x-wei.github.io/algoI_week5_1.html" rel="alternate"></link><updated>2015-08-26T16:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week5_1.html</id><summary type="html">&lt;p&gt;goal: lgN for insert/search/delete operations (not necessarily &lt;em&gt;binary&lt;/em&gt; trees..) &lt;br /&gt;
3 algo: 2-3 tree, (left leaning) red-black tree, B-tree   &lt;/p&gt;
&lt;h1&gt;1. 2-3 Search Trees&lt;/h1&gt;
&lt;p&gt;def. &lt;strong&gt;2-3 tree&lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allow 1 or 2 keys per node, &amp;amp; 2 or 3 children per node:    &lt;ul&gt;
&lt;li&gt;2-node: one key, 2 children (ordinary BST node)   &lt;/li&gt;
&lt;li&gt;3-node: 2 keys, 3 children (3 children: &lt;em&gt;less, between, more&lt;/em&gt;)   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;perfect balance&lt;/strong&gt;: every path from root to null link has the same length (2-3 tree的一个超好的性质, &lt;em&gt;类似于一个满二叉树&lt;/em&gt;!)   &lt;/li&gt;
&lt;li&gt;symmetric order: inorder traversal gives ascending order (和BST类似)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image.png" /&gt; &lt;br /&gt;
&lt;strong&gt;search&lt;/strong&gt; &lt;br /&gt;
Just follow the correct link... Natural generalization of search in BST...    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;insert&lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;case 1: insert into a 2-node at bottom   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;just convert a 2-node into a 3-node   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;case 2: insert into a 3-node at bottom   &lt;ul&gt;
&lt;li&gt;create a temporary 4-node (three keys)   &lt;/li&gt;
&lt;li&gt;move middle key in 4-node into parent, split the rest two keys into two 2-nodes   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image001.png" /&gt;   &lt;img alt="" src="algoI_week5_1/pasted_image002.png" /&gt;    &lt;img alt="" src="algoI_week5_1/pasted_image003.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if parent becom a 3-node → continue the process   &lt;/li&gt;
&lt;li&gt;if arrived at the root (root is a 4-node with three keys): split it into three 2-nodes   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image004.png" /&gt; &lt;img alt="" src="algoI_week5_1/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;splitting a 4-node&lt;/strong&gt;: can be done in constant time (&lt;em&gt;local transformation&lt;/em&gt;).  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image006.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;Invariant: maintains symmetric order and perfect balance.  &lt;br /&gt;
&lt;em&gt;proof.&lt;/em&gt;  &lt;br /&gt;
each transformation maintains the order and the balance, all possible transformations:  &lt;br /&gt;
这个图很好, 3-node的插入一共有三种情况: 自身是root/父亲是2-node/父亲是3-node &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image007.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;performance&lt;/strong&gt; &lt;br /&gt;
every path from root to null link has the same length.  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image008.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;direct implementation is complicated:    &lt;/li&gt;
&lt;li&gt;bottom line: &lt;em&gt;Could do it, but there's a better way.&lt;/em&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;2. Red-Black BST&lt;/h1&gt;
&lt;p&gt;LLRB tree: left-leaning red-black tree.    &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;BST representation of the 2-3 trees&lt;/em&gt; &lt;br /&gt;
&lt;strong&gt;use internal left-leaning links for 3 nodes&lt;/strong&gt;   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;红色link即为internal left leaning link (红黑树就是这么来的), 用红色link连接起来的组成一个(虚拟的)3-node 或4-node.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3-node用一个red link表示:    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image009.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4-node用两个red link表示:    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image030.png" /&gt; ⇒ &lt;img alt="" src="algoI_week5_1/pasted_image029.png" /&gt; or &lt;img alt="" src="algoI_week5_1/pasted_image027.png" /&gt; or &lt;img alt="" src="algoI_week5_1/pasted_image028.png" /&gt;   &lt;/p&gt;
&lt;p&gt;example:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image010.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;properties&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;no node has two red links (不可以一个节点连两个red link)   &lt;/li&gt;
&lt;li&gt;every path from path to null link has the same number of &lt;em&gt;black&lt;/em&gt; links (想象所有red link都变为horizontal)   &lt;/li&gt;
&lt;li&gt;all red links lean left   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image011.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;representation&lt;/h2&gt;
&lt;p&gt;Each node has only one link from parent  &lt;br /&gt;
⇒ add a boolean to encode color of links (the color of the link &lt;em&gt;from parent&lt;/em&gt;).  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image012.png" /&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private class Node{   
    private Key key;   
    private Value val;   
    Node left, right;   
    boolean color;//true means red     
}    
private boolean isRed(Node nd){   
    if (nd==null) return false;   
    return nd.color;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;insert to parent 操作: 只需把color变为RED即表示该节点 被变成了和父节点一起的一个(虚拟)节点.    &lt;/p&gt;
&lt;h2&gt;elementary operations&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;left-rotation&lt;/strong&gt; &lt;br /&gt;
(def: &lt;em&gt;convert a right-learning red link to left.&lt;/em&gt; ) &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image013.png" /&gt;   &lt;img alt="" src="algoI_week5_1/pasted_image014.png" /&gt; &lt;br /&gt;
(symmetric ordering and perfect black balance are maintained)    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private Node rotateLeft(Node h){    
    Node s = h.right;   
    h.right = s.left;   
    s.left = h;   
    s.color = h.color;   // not = BLACK   
    h.color = RED;   
    return s;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;right-rotation&lt;/strong&gt; &lt;br /&gt;
(temporarily turn a left-leaning red link to right) &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image015.png" /&gt; &lt;img alt="" src="algoI_week5_1/pasted_image016.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;private Node rotateRight(Node h){...}&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;right rotation 是为了应对这种情况:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image024.png" /&gt; rotateRight(c) ⇒ &lt;img alt="" src="algoI_week5_1/pasted_image023.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;color-flip&lt;/strong&gt; &lt;br /&gt;
(split a 4-node, with three kyes — two red links) &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image017.png" /&gt;  &lt;img alt="" src="algoI_week5_1/pasted_image018.png" /&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private void filpColor(Node h){   
    h.color = RED;   
    h.left.color = BLACK;   
    h.right.color = BLACK;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Basic strategy&lt;/strong&gt; &lt;br /&gt;
Maintain &lt;em&gt;one-to-one correspondence&lt;/em&gt; with 2-3 tree by applying elementary operations.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;search&lt;/strong&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Exactly&lt;/em&gt; the same as elementary BST. ( ⇒ The same code for floor and ceiling)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;insert&lt;/strong&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Each insert will generate a red link&lt;/strong&gt; (then should rotate to make it legal)   &lt;/p&gt;
&lt;p&gt;插入的时候有两种可能:    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;insert into a 2-node at the bottom   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image025.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;standart BST insert   &lt;/li&gt;
&lt;li&gt;if have red right link: rotateLeft   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image021.png" /&gt;   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;insert into a 3-node    &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有三种可能: insert into left/middle/right, right最简单, left捎复杂, middle最复杂, 见下图:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image026.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;standard BST insert and color nodes   &lt;/li&gt;
&lt;li&gt;if necessary, rotate to balance 4-node, 比如:    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image031.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flip colors to pass red link to upper level   &lt;/li&gt;
&lt;li&gt;if necessary, rotate to make all links left-leaning    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex: &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image032.png" /&gt; &lt;br /&gt;
ex2: &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image033.png" /&gt;    &lt;/p&gt;
&lt;p&gt;视频最后一段的demo太帅了! 叹为观止!!   &lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;p&gt;原来&lt;strong&gt;只有4种(其实是3种)情况要调整&lt;/strong&gt;:    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;left = black, right = red&lt;/em&gt;   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image034.png" /&gt;  ⇒ rotateLeft(a)   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;left =red, left.right = red [这个不会出现, 因为这对于下一层来说是case 1..]&lt;/em&gt;   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image039.png" /&gt;  ⇒ rotateLeft(e) ⇒ 变为case 3    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;left = red, left.left = red&lt;/em&gt;   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image035.png" /&gt;  ⇒ rotateRight(s) ⇒ 变为case 4   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;left = red. right = red&lt;/em&gt;   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image036.png" /&gt;      ⇒ flipColor(r)   &lt;/p&gt;
&lt;p&gt;几个状态之间的转化:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image038.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只要三行代码即可处理LLRB tree !! 老爷子牛逼...... &lt;/strong&gt; &lt;br /&gt;
(这个也是在2007年algo第四版的时候才刚刚弄出来的, 以前的代码要复杂)   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private Node put(Node nd, Key k, Value v){   
    if(nd==null) return new Node(k,v,RED);   
    int cmp = k.compareTo(nd.key);   
    if(cmp==0) nd.val = v; // 这里不急着返回 -- same trick as for BSTs..   
    else if(cmp&amp;lt;0) nd.left = put(nd.left, k, v);   
    else nd.right = put(nd.right, k, v);   
    // modifications to maintain LLRB tree property:    
    if( isRed(nd.right) &amp;amp;&amp;amp; !isRed(nd.left) ) nd = rotateLeft(nd);//case 1   
    //if( isRed(nd.left) &amp;amp;&amp;amp; isRed(nd.left.right) ) nd.left = rotateLeft(nd.left);// case 2 -- never happen...   
    if( isRed(nd.left) &amp;amp;&amp;amp; isRed(nd.left.right) ) nd = rotateRight(nd);// case 3   
    if( isRed(nd.left) &amp;amp;&amp;amp; isRed(nd.right) ) flipColor(nd);//case 4   
    return nd;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这三行代码越看越精妙......    &lt;/p&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image041.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;worst case&lt;/strong&gt;: the left path is &lt;em&gt;alternating red and black&lt;/em&gt;. &lt;br /&gt;
⇒ longest path &amp;lt;= 2 * shortest path  (height&amp;lt;= 2lgN)   &lt;/p&gt;
&lt;p&gt;practical applications: height ~ 1.0 lgN   &lt;/p&gt;
&lt;p&gt;summery:  &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image042.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;3. B-trees&lt;/h1&gt;
&lt;p&gt;setting: data access in file system.  &lt;br /&gt;
&lt;em&gt;Probe is much expensive than accessing data within a page.&lt;/em&gt;    &lt;/p&gt;
&lt;p&gt;Goal: access data using a minimum number of probes.   &lt;/p&gt;
&lt;h2&gt;B-tree&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;def.&lt;/strong&gt; &lt;br /&gt;
external nodes: contain just keys, not links &lt;br /&gt;
internal nodes: contain key-link pairs   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;def. B-tree&lt;/strong&gt; &lt;br /&gt;
Generalize 2-3 trees by allowing up to M-1 keys per node:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;= 2 keys in root   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;= M/2 keys in other nodes   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;external nodes contain client keys   &lt;/li&gt;
&lt;li&gt;internal nodes contain copies of keys to guide search   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image043.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Searching&lt;/h2&gt;
&lt;p&gt;similar to BST/2-3tree &lt;br /&gt;
ex. &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image044.png" /&gt;   &lt;/p&gt;
&lt;p&gt;(Choose M as large as possible so that M links fit into a page)   &lt;/p&gt;
&lt;h2&gt;Insertion&lt;/h2&gt;
&lt;p&gt;similar to 2-3 tree &lt;br /&gt;
&lt;img alt="" src="algoI_week5_1/pasted_image045.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image046.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;System implementations&lt;/h2&gt;
&lt;p&gt;system implementations of RBtree. &lt;br /&gt;
java:  &lt;br /&gt;
&lt;code&gt;java.util.TreeMap&lt;/code&gt;, &lt;code&gt;java.util.TreeSet&lt;/code&gt;.   &lt;/p&gt;
&lt;p&gt;八卦1: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week5_1/pasted_image047.png" /&gt;     &lt;/p&gt;
&lt;p&gt;八卦2: 
Sedgewick 的朋友, &lt;a href="https://fr.wikipedia.org/wiki/Philippe_Flajolet"&gt;Philippe Flajolet&lt;/a&gt;, 是一个X!    &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 4-2b Binary Search Trees</title><link href="http://x-wei.github.io/algoI_week4_2b.html" rel="alternate"></link><updated>2015-08-26T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week4_2b.html</id><summary type="html">&lt;p&gt;(BST是锻炼递归代码的好题目)   &lt;/p&gt;
&lt;h1&gt;1. Binary Search Trees&lt;/h1&gt;
&lt;p&gt;def. &lt;strong&gt;BST&lt;/strong&gt; &lt;br /&gt;
A binary tree where each node has a key:  &lt;br /&gt;
for every node, the key is larger than &lt;em&gt;all nodes in left&lt;/em&gt; subtree, smaller than &lt;em&gt;all nodes in right&lt;/em&gt; subtree.  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image.png" /&gt; &lt;br /&gt;
Fields: key, val, left, right   &lt;/p&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;An inner class of BST nodes:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private class Node{   
    private Key key;   
    private Value val;   
    private Node left, right;   
    public Node(Key k, Value v){...}   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;skeleton implementation of BST:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class BST&amp;lt;Key implements Comparable&amp;lt;Key&amp;gt;, Value&amp;gt;{   
private Node root;   
private class Node{...}   
public Value get(Key k){...}   
public void put(Key k, Value v){}   
public void delete(Key k){}   
public Iterable&amp;lt;Key&amp;gt; iterator(){}   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;search&lt;/strong&gt; &lt;br /&gt;
recursive version:  &lt;br /&gt;
(或者把这个函数写到Node类里面也可以. )   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private Value get(Node nd, Key k){   
    if(nd==null) return null; // search miss   
    int cmp = k.compareTo(nd.key);   
    if(cmp==0) return nd.val; // search hit   
    else if (cmp&amp;gt;0) return get(nd.right, k);   
    else return get(nd.left, k);   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;non-recursive version:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public Value get(Key k){   
    Node nd=root;   
    while(root!=null){   
        int cmp = k.compareTo(nd.key);   
        if (cmp==0) return nd.val;   
        else if(cmp&amp;gt;0) nd = nd.right;   
        else nd = nd.left;   
    }   
    return null;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;insert&lt;/strong&gt; &lt;br /&gt;
recursive version:  &lt;br /&gt;
(注意这个recursive函数的返回值不是void! 这里是一个trick: 返回的是在分叉以前的那个节点)   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private Node put(Node nd, Key k, Value v){   
    if(nd==null) return new Node(k, v);   
    int cmp = k.compareTo(nd.key);   
    if(cmp==0) nd.val = v;   
    else if(cmp&amp;gt;0) nd.right = put(nd.right, k, v);   
    else nd.left = put(nd.left, k, v);   
    return nd;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;non-recursive version: &lt;br /&gt;
不如递归版本优美...   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public void put(Key k, Value v){   
    Node nd = root;   
    while(true){   
        int cmp = k.compareTo(nd.key);   
        if(cmp==0) {   
            nd.val = v; break;   
        }   
        else if(cmp&amp;gt;0){    
            if(nd.right!=null) nd = nd.right;   
            else {nd.right = new Node(k,v); break;}   
        }   
        else if (nd.left!=null) {    
            if(nd.left!=null) nd = nd.left;   
            else {nd.left = new Node(k,v); break;}   
        }   
    }   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;complexity: depth of the BST.    &lt;/p&gt;
&lt;p&gt;shape of BST: depends on how the keys come in (order of insertion).  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image001.png" /&gt; &lt;br /&gt;
if keys come in &lt;em&gt;random&lt;/em&gt; order: could be pretty well balanced.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BST and quick-sort partitionning&lt;/strong&gt; &lt;br /&gt;
&lt;em&gt;The root of BST is just the pivot in quick sort partitioning  * &lt;br /&gt;
if all keys are distinct ⇒ one-to-one correspondence between quick sort and BST.  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image002.png" /&gt;  &lt;br /&gt;
⇒ &lt;strong&gt;proposition&lt;/strong&gt; &lt;br /&gt;
if all keys are distinct and come in randome order, the average number of compares for a search/insert is ~2lnN (or 1.39lgN).  &lt;br /&gt;
&lt;/em&gt;proof.* &lt;br /&gt;
证明见quicksort那里的数学推导...    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;proposition &lt;/strong&gt;(Reed, 2003) &lt;br /&gt;
N distinct keys come in random order, average tree height = 4.300lnN   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Worst-case:&lt;/strong&gt; &lt;br /&gt;
The tree becomes just like a linked list: ~N for insertion and search   &lt;/p&gt;
&lt;h1&gt;2. Oredered Operations in BST&lt;/h1&gt;
&lt;p&gt;task: ordered opeartions   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;min()/max()&lt;/code&gt;: min/max key   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;deleteMin()/deleteMax()&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;floor(Key k)/ceiling(Key k)&lt;/code&gt;: largest key &amp;lt;=k / smallest key &amp;gt;=k   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;rank(Key k)&lt;/code&gt;: nb of keys &amp;lt; key   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;select(int i)&lt;/code&gt;: key with rank=i   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Iterator&amp;lt;Key&amp;gt; keys(lo, hi)&lt;/code&gt;: iterates through [lo, hi]   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;min/max&lt;/h2&gt;
&lt;p&gt;easy &lt;br /&gt;
min: left-most &lt;br /&gt;
max: right-most &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image003.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;floor/ceiling&lt;/h2&gt;
&lt;p&gt;a little more complexed...    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;floor (ceiling is similar)&lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if k==nd.key   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;return nd.val   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if k&amp;lt;nd.key   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;the floor &lt;em&gt;must&lt;/em&gt; be in the left subtree   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if k&amp;gt;nd.key   &lt;ul&gt;
&lt;li&gt;如果min(nd.right) &amp;gt; k: 返回nd.val   &lt;/li&gt;
&lt;li&gt;如果min(nd.right) &amp;lt;= k: go to right   &lt;div class="codehilite"&gt;&lt;pre&gt;public Value floor(Node nd, Key k){// largest element with key &amp;lt;= k       
int cmp = k.compareTo(nd.key);         
if(cmp==0) return nd.val;//case 1   
else if(cmp&amp;lt;0) return floor(nd.left, k);//case 2   
if (nd.right==null || min(nd.right).compareTo(k)&amp;gt;0) //case 3   
    return nd.val;   
else return floor(nd.right);   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他提供的版本和我写的不一样: 递归函数floor返回的也是一个Node:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image004.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;rank/select&lt;/h2&gt;
&lt;p&gt;In each node, store the number of nodes in the subtree: &lt;em&gt;add an extra field&lt;/em&gt;.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;size&lt;/strong&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private class Node{   
    private int count;   
    //...   
}    
public int size(){   
    return size(root);   
}   
public int size(Node nd){   
    if(nd==null) return 0;// this is why we do not put size() inside the class Node!   
    return nd.count;   
}   
public void put(Node nd, Key k, Value v){   
    //.....   
    nd.count = size(nd.left)+size(nd.right)+1;//maintain count for each node   
    return nd;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;rank&lt;/strong&gt; &lt;br /&gt;
(return nb of keys &amp;lt; k)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if nd.key==k   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;return size(nd.left)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if nd.key&amp;gt;k   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;return rank(nd.left, k)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if nd.key&amp;lt;k   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;return size(nd.left)+1+rank(nd,right, k)   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private int rank(Node nd, Key k){   
    if(nd==null) return 0;//remember null case   
    int cmp = k.compareTo(nd.key);   
    if(cmp==0) return size(nd.left)   
    else if (cmp&amp;lt;0) return rank(nd.left, k);   
    else return size(nd.left)+1+rank(nd.right,k);   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;select() similar...   &lt;/p&gt;
&lt;h2&gt;iteration&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Inorder traversal 中序遍历&lt;/strong&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public Iterable&amp;lt;Key&amp;gt; keys(){   
    Queue&amp;lt;Key&amp;gt; q = new Queue&amp;lt;Key&amp;gt;();   
    inorder(root, q);   
    return q;   
}    
private void inorder(Node nd, Queue&amp;lt;Key&amp;gt; q){   
    if(nd==null) return;   
    inorder(nd.left);   
    q.enqueue(nd.key);   
    inorder(nd.right);   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="" src="algoI_week4_2b/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;property&lt;/strong&gt; &lt;br /&gt;
inorder-traversal gives the keys &lt;em&gt;in ascending order&lt;/em&gt;.  &lt;br /&gt;
(proof by induction)   &lt;/p&gt;
&lt;h1&gt;3. Deletions in BST&lt;/h1&gt;
&lt;p&gt;one final function to implement: delete(Key k), deleteMin(), deleteMax() &lt;br /&gt;
→ and remember to update the count field...   &lt;/p&gt;
&lt;p&gt;(感觉这篇文章其实就讲的很清楚了: &lt;a href="http://www.algolist.net/Data_structures/Binary_search_tree/Removal"&gt;http://www.algolist.net/Data_structures/Binary_search_tree/Removal&lt;/a&gt;   这个在递归函数里使用了parent这个参数)   &lt;/p&gt;
&lt;h2&gt;lazy approch&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;put(k, null)&lt;/code&gt;, and leave the key in the tree (tombstone) &lt;br /&gt;
→ not good if have large number of tombstons...    &lt;/p&gt;
&lt;h2&gt;deleteMin/Max&lt;/h2&gt;
&lt;p&gt;go the the left-most node → replace it with its right node.  &lt;br /&gt;
Recusive function with the &lt;em&gt;returning-node trick&lt;/em&gt;:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private Node deleteMin(Node nd){   
    if(nd==null) return null; // this might not happen   
    if(nd.left==null) return nd.right;   
    else nd.left = deleteMin(nd.left);   
    nd.count = size(nd.left)+1+size(right);//remember to maintain the count field   
    return nd;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个递归的技巧又一次使用了.   &lt;/p&gt;
&lt;h2&gt;Hibbard deletion&lt;/h2&gt;
&lt;p&gt;first find node with the key to delete, 3 cases:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 children:    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;simply set parent link to null &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image006.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 child:    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;replace parent link with the child &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image007.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2 children (most subtle)&lt;/strong&gt;   &lt;ul&gt;
&lt;li&gt;first replace node key with smallest key in right subtree   &lt;/li&gt;
&lt;li&gt;remove the smallest key in right subtree   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_2b/pasted_image008.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;code of Hibbard deletion&lt;/strong&gt; &lt;br /&gt;
Again (for the 3rd time) use the &lt;em&gt;return-nd trick&lt;/em&gt;...   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private Node delete(Node nd, Key k){   
    if(nd==null) return null;// search miss   
    int cmp = k.compareTo(nd.key);   
    if(cmp&amp;gt;0) nd.right = delete(nd.right, k);   
    else if(cmp&amp;lt;0) nd.left = delete(nd.left,k);   
    else{   
        //if nd is the node to delete   
        if(nd.left==null) return nd.right;   
        if(nd.right==null) return nd.left;   
        Key k2 = min(nd.right);   
        nd.key = k2;   
        nd.right = delete(nd.right, k2);   
    }   
    nd.count = size(nd.left)+1+size(nd.right);   
    return nd;   
}    
public void delete(Key k){   
    root = delete(root, k);   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;感觉用了recursive return-nd 这个trick的实现很漂亮.... 比那篇博客里放一个参数进递归函数以及用auxroot的办法要好不少...    &lt;/p&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;problem: &lt;em&gt;not symmetric&lt;/em&gt; &lt;br /&gt;
If random insert and delete for a while ⇒ tree become much less balanced ! Tree height tend to be sqrt(N).    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;summery&lt;/strong&gt; &lt;br /&gt;
BST is much better in average case, but not guaranteed for worst case.  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2b/pasted_image009.png" /&gt;   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 4-2a Elementry Symbol Tables</title><link href="http://x-wei.github.io/algoI_week4_2a.html" rel="alternate"></link><updated>2015-08-25T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week4_2a.html</id><summary type="html">&lt;h1&gt;1. Symbol Table API&lt;/h1&gt;
&lt;p&gt;key-value pair abstraction    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;insert&lt;/strong&gt; a value with a key   &lt;/li&gt;
&lt;li&gt;given a key, &lt;strong&gt;search&lt;/strong&gt; for its value   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Association array abstraction&lt;/h2&gt;
&lt;p&gt;Associate a value to a key — generalized array: &lt;em&gt;a[key]=val&lt;/em&gt;.    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class ST&amp;lt;Key, Value&amp;gt;{   
    void put(Key k, Value v);//remove key if value=null   
    Value get(Key k);//return null if key is absent   
    void delete(Key k);   
    boolean contains(Key k);   
    boolean isEmpty();   
    int size();   
    Iterable&amp;lt;Key&amp;gt; keys();//better to return an ordered sequence of keys   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;conventions:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;values are not null   &lt;/li&gt;
&lt;li&gt;get() returns null if key not present   &lt;/li&gt;
&lt;li&gt;put() can &lt;em&gt;overwrite&lt;/em&gt; older value   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ some one-line implementations:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;contains: &lt;code&gt;return get(k)!=null;&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;delete: &lt;code&gt;put(k, null);&lt;/code&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Assume keys to be comparable: &lt;code&gt;class ST&amp;lt;Key implements Comparable&amp;lt;Key&amp;gt;, Value&amp;gt;&lt;/code&gt;— can thus use &lt;code&gt;compareTo()&lt;/code&gt; method.  &lt;br /&gt;
Else →  we can only use the &lt;code&gt;equals()&lt;/code&gt; method...  &lt;br /&gt;
Be careful when implementing the equals method: 坑不少...  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2a/pasted_image.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;2. Elementary implementations&lt;/h1&gt;
&lt;p&gt;naive implementations   &lt;/p&gt;
&lt;h2&gt;using unordered linked list&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;ListNode{key, value, next}&lt;/em&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;search: scan through all keys ~N   &lt;/li&gt;
&lt;li&gt;insert: scan through, if not found, add to front ~N   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_2a/pasted_image001.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;using ordered array&lt;/h2&gt;
&lt;p&gt;using 2 arrays: &lt;em&gt;keys[] (sorted), vals[]&lt;/em&gt; &lt;br /&gt;
⇒ can improve performance by binary search   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;search operation&lt;/strong&gt; &lt;br /&gt;
write a function rank() that returns the number of keys &amp;lt; k searched.  &lt;br /&gt;
找不到的时候: &lt;em&gt;比k小的元素个数=lo (lo&amp;gt;hi, 可以想想当hi=lo以后是怎么移动的)&lt;/em&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private int rank(Key k){   
    int lo=0, hi=keys.length-1;   
    while(hi&amp;gt;=lo){   
        int mid = lo + (hi-lo)/2;   
        int cmp = keys[mid].compareTo(keys[k]);   
        if(cmp==0) return mid;   
        else if(cmp&amp;gt;0) hi = mid-1;   
        else lo = mid+1;   
    }   
    return lo;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Using rank() to implement the get() method:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public Value get(Key k){   
    int rk = rank(k);   
    if(rk&amp;lt;N &amp;amp;&amp;amp; keys[rk].compareTo(k)==0) return vals[rk];   
    return null;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;insert operation&lt;/strong&gt; &lt;br /&gt;
Like insertion sort, time complexity is ~N for each insert.    &lt;/p&gt;
&lt;p&gt;summery:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_2a/pasted_image002.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;3. Ordered Opeartions&lt;/h1&gt;
&lt;p&gt;When keys are comparable ⇒ provide &lt;em&gt;more functionalities&lt;/em&gt; in the API.  &lt;br /&gt;
for example:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;min()/max()&lt;/code&gt;: min/max key   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;deleteMin()/deleteMax()&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;floor(Key k)/ceiling(Key k)&lt;/code&gt;: largest key &amp;lt;=k / smallest key &amp;gt;=k   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;rank(Key k)&lt;/code&gt;: nb of keys &amp;lt; key   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;select(int i)&lt;/code&gt;: key with rank=i   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Iterator&amp;lt;Key&amp;gt; keys(lo, hi)&lt;/code&gt;: iterates through [lo, hi]   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_2a/pasted_image004.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_2a/pasted_image003.png" /&gt;   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 4-1 Priority Queue</title><link href="http://x-wei.github.io/algoI_week4_1.html" rel="alternate"></link><updated>2015-08-24T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week4_1.html</id><summary type="html">&lt;h1&gt;1. API and elementary implementations&lt;/h1&gt;
&lt;p&gt;Collection: data struct for inserting and deleting items (ex. stack and queue).  &lt;br /&gt;
Priority queue: a special kind of collection — remove &lt;em&gt;largest/smallest&lt;/em&gt; element.    &lt;/p&gt;
&lt;p&gt;API:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class Max&amp;lt;Kye implements Comparable&amp;lt;Key&amp;gt;&amp;gt;{   
    public MaxPQ();    
    public void insert(Key k);   
    public Key delMax();    
    public boolean isEmpty();     
    public Key max();   
    int size();

}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;PQ client example&lt;/h2&gt;
&lt;p&gt;find &lt;em&gt;M largest&lt;/em&gt; elements from N items. (N is too huge to store) &lt;br /&gt;
⇒ 思路: 用 &lt;strong&gt;Min&lt;/strong&gt;&lt;em&gt;PQ&lt;/em&gt;, 当size&amp;gt;M时删掉最小元素 — 最后剩下的就是最大的M个元素了.  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;elementary(naive) implementations&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;unordered array implementation&lt;/strong&gt; &lt;br /&gt;
insert ~1,  &lt;br /&gt;
remove ~N   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ordered array implementation&lt;/strong&gt; &lt;br /&gt;
insert ~N — ~ insertion sort, &lt;br /&gt;
remove ~1   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;goal&lt;/strong&gt;:  &lt;br /&gt;
insert O(lgN) &amp;amp; remove max O(lgN)   &lt;/p&gt;
&lt;h1&gt;2. Binary Heaps&lt;/h1&gt;
&lt;p&gt;binary heap: a special kind of &lt;em&gt;complete binary tree&lt;/em&gt;.    &lt;/p&gt;
&lt;p&gt;def. "&lt;strong&gt;complete binary tree"&lt;/strong&gt; &lt;br /&gt;
All level except the last level are full, all nodes in the last level are as far left as possible.   &lt;br /&gt;
完全二叉树大概长这个样子:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image001.png" /&gt;   &lt;/p&gt;
&lt;p&gt;property: a complete binary tree with N items has height = lgN.    &lt;/p&gt;
&lt;p&gt;def. &lt;strong&gt;binary heap&lt;/strong&gt; &lt;br /&gt;
Binary heap is a complete binary tree that satisfies: &lt;em&gt;each node &amp;gt;= any of its 2 children&lt;/em&gt; ("heap ordering").    &lt;/p&gt;
&lt;p&gt;property of binary heap:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;max element is root   &lt;/li&gt;
&lt;li&gt;height is lgN   &lt;/li&gt;
&lt;li&gt;&lt;em&gt;each node still makes a heap&lt;/em&gt; (use this property to construct heap from bottom up)   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Array representation of binary heap&lt;/h2&gt;
&lt;p&gt;Use an array &lt;code&gt;a[]&lt;/code&gt; to represent a complete binary tree: very easy to get children and parent.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;index starting from 1&lt;/strong&gt; (root = a[1], do not use a[0])    &lt;/li&gt;
&lt;li&gt;for node at index &lt;code&gt;i&lt;/code&gt;, its children are: &lt;code&gt;i*2&lt;/code&gt; and &lt;code&gt;i*2+1&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;for node at index &lt;code&gt;i&lt;/code&gt; (i&amp;gt;1), its parent is: &lt;code&gt;i/2&lt;/code&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_1/pasted_image002.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;简言之就是:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image003.png" /&gt;   &lt;/p&gt;
&lt;p&gt;内部成员变量:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class MaxPQ&amp;lt;Key implements Comparable&amp;lt;Key&amp;gt;&amp;gt;{   
    private Key[] a;   
    private int N;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;siftup (swim)&lt;/strong&gt; &lt;br /&gt;
if a node is larger than its parent: &lt;em&gt;exchange with parent until heap ordering is restored.&lt;/em&gt;    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private void swim(int k){   
    while(k&amp;gt;1 &amp;amp;&amp;amp; less(a[k/2], a[k]){   
        exch(a,k,k/2);   
        k /= 2;   
    }   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;⇒ &lt;strong&gt;use siftup for inserting elements&lt;/strong&gt; &lt;br /&gt;
when inserting an element, first append it to the end of the array, then siftup the element to its right position.    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public void insert(Key k){    
a[N++]=x;   
swim(N);   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;siftdown (sink)&lt;/strong&gt; &lt;br /&gt;
if a node is smaller than its children: &lt;em&gt;exchange it with the bigger child.&lt;/em&gt; 用公司高层变动来类比很形象...    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private void sink(int k){   
    while(k*2&amp;lt;=N){   
        int maxIndex = less(a[k],a[k*2])? k*2 : k;   
        if(k*2+1&amp;lt;=N &amp;amp;&amp;amp; less(a[maxIndex],a[k*2+1]) maxIndex = 2*k+1;   
        if(maxIndex==k) break;   
        exch(a,k,maxIndex);   
        k = maxIndex;   
    }   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;⇒ use siftdown for deleting max operation&lt;/strong&gt; &lt;br /&gt;
First put a[N] to the position of root, then sink. (注意要防止loitering)   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public Key delMax(){   
    Key ret = a[1];   
    a[1] = a[N];   
    a[N--] = null; // avoid loitering   
    sink(1);   
    return ret;   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;insert: ~lgN &lt;br /&gt;
remove max: ~lgN   &lt;/p&gt;
&lt;p&gt;improvements:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use a &lt;strong&gt;d-way heap&lt;/strong&gt; instead of a 2-way heap (for ex. 3-way heap, the children of i are i&lt;em&gt;3, i&lt;/em&gt;3+1, i*3+2, the parent of i is i/3)   &lt;/li&gt;
&lt;li&gt;Fibonacci heap: insert is &lt;em&gt;~1&lt;/em&gt;, remove max still ~lgN, (but too complicated to use in practice).    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_1/pasted_image004.png" /&gt;   &lt;/p&gt;
&lt;p&gt;considerations:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use immutable keys to avoid client from changing the keys (&lt;code&gt;final&lt;/code&gt; keyword in java)   &lt;/li&gt;
&lt;li&gt;underflow/overflow: throw exceptions for delMax() when empty, use resizing array for implementation.   &lt;/li&gt;
&lt;li&gt;expand the API with other operations: remove an arbitrary item, change the prority of an item (like handling an array)...   &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;3. Heapsort&lt;/h1&gt;
&lt;p&gt;Basic idea:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create a max heap with all N entries &lt;strong&gt;("heap-construction")&lt;/strong&gt;   &lt;/li&gt;
&lt;li&gt;then repeatedly remove all N items &lt;strong&gt;("sortdown")&lt;/strong&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;heap construction&lt;/strong&gt;  &lt;br /&gt;
Construct the heap using a &lt;strong&gt;bottom-up&lt;/strong&gt; method: build the heaps with small size first.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one-node heaps (jus leaf node of heap): need not consider   &lt;/li&gt;
&lt;li&gt;larger heaps: children(subtrees) are already heap-order → just perform sink operation for root   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⇒ &lt;em&gt;sink elements at indices from N/2 to 1&lt;/em&gt;   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;for(int k=N/2; k&amp;gt;=1; k++)   
sink(k);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;→ complexity is &lt;strong&gt;linear&lt;/strong&gt;, see analysis below.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;heap destruction &lt;/strong&gt; &lt;br /&gt;
now that we have a max-heap, to get the sorted array &lt;em&gt;in-place,&lt;/em&gt; simply do:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;while(N&amp;gt;1){   
exch(a,1, N--);   
sink(1);   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;proposition&lt;/strong&gt; &lt;br /&gt;
Heap construction uses &lt;strong&gt;&amp;lt;2N&lt;/strong&gt; compares and exchanges.  &lt;br /&gt;
&lt;em&gt;proof&lt;/em&gt; &lt;br /&gt;
一个有h层的heap, 高度为k的subtree有 2^(h-k)个, 每个subtree最多可以交换k次(从root交换到最底层)  &lt;br /&gt;
→ 每一层最多有 k*2^(h-k) 次交换  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image007.png" /&gt;   &lt;br /&gt;
(第一个等式可以用数学归纳法证...)  &lt;br /&gt;
&lt;a href=""&gt;详细证明见http://algs4.cs.princeton.edu/24pq/&lt;/a&gt;  (Q20答案)   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;proposition&lt;/strong&gt; &lt;br /&gt;
Heapsort use &amp;lt; 2NlgN compares and exchanges.    &lt;/p&gt;
&lt;p&gt;Heapsort is the first &lt;em&gt;in-place&lt;/em&gt; sorting algorithm with NlgN &lt;em&gt;worst-case&lt;/em&gt; performance.  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;p&gt;⇒ heapsort is &lt;em&gt;optimal for time and space&lt;/em&gt;, but:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inner loop is longer than quicksort   &lt;/li&gt;
&lt;li&gt;poor use of cache memory (too many references to cache — look far away from the array entry when going down through the tree)   &lt;/li&gt;
&lt;li&gt;not stable: because it does long-distance exchanges   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Summary:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image006.png" /&gt;   &lt;/p&gt;
&lt;h1&gt;4. Event-driven simulation&lt;/h1&gt;
&lt;p&gt;Goal: simulating the motion of N particles in elastic collision (using a priority queue).  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image008.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;model&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_1/pasted_image009.png" /&gt; &lt;br /&gt;
bouncing balls (without collision) &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image010.png" /&gt;    &lt;/p&gt;
&lt;p&gt;Ball class:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image011.png" /&gt;   &lt;/p&gt;
&lt;p&gt;challenge: which objects to check? How to do it efficently ?   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Time driven simulation&lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;upate the position of balls every &lt;code&gt;dt&lt;/code&gt; seconds   &lt;/li&gt;
&lt;li&gt;if overlap detected: figure how the velocity change and continue the simulation.    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;problem with time-driven simulation:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1/2*N^2 overlap check per time unit   &lt;/li&gt;
&lt;li&gt;if dt small: too much calculation   &lt;/li&gt;
&lt;li&gt;if dt too large: might miss collisions   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Event driven simulation&lt;/h2&gt;
&lt;p&gt;change state only when something happens   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;particles move in straight line before collision   &lt;/li&gt;
&lt;li&gt;→ collision time can be &lt;em&gt;predicted&lt;/em&gt;   &lt;/li&gt;
&lt;li&gt;maintain PQ for collisions, key=collision time    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;collision prediction&lt;/strong&gt; &lt;br /&gt;
input: each particle has radius &lt;code&gt;s&lt;/code&gt;, position &lt;code&gt;(rx, ry)&lt;/code&gt;, velocity &lt;code&gt;(vx, vy)&lt;/code&gt;. &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image013.png" /&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image014.png" /&gt;  &lt;br /&gt;
(美国高中物理这么凶残?...)   &lt;/p&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;anyway, 这个是封装好的类: &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image015.png" /&gt; &lt;br /&gt;
注意, 使用了count记录一个particle到目前为止的碰撞次数.    &lt;/p&gt;
&lt;p&gt;initialization: &lt;strong&gt;quadratic&lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fill PQ with all &lt;em&gt;potential&lt;/em&gt;  particle-particle collisions   &lt;/li&gt;
&lt;li&gt;Fill (the same) PQ with all &lt;em&gt;potential&lt;/em&gt;  particle-wall collisions   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Main loop &lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get next event from PQ, event time = t   &lt;/li&gt;
&lt;li&gt;ignore if the event is &lt;em&gt;invalidated&lt;/em&gt;   &lt;/li&gt;
&lt;li&gt;advance all particles to time t   &lt;/li&gt;
&lt;li&gt;update velocities   &lt;/li&gt;
&lt;li&gt;predict future collisions and insert to PQ   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week4_1/pasted_image018.png" /&gt; &lt;br /&gt;
判断invalidate:  &lt;br /&gt;
一个event构造(predict)时记录粒子构造时刻的碰撞次数(countA, countB), &lt;br /&gt;
然后在调用invalidate的时候, 如果粒子的碰撞次数发生了改变, 则返回false.  &lt;br /&gt;
(详见他们的代码: &lt;a href="http://algs4.cs.princeton.edu/61event/CollisionSystem.java.html"&gt;http://algs4.cs.princeton.edu/61event/CollisionSystem.java.html&lt;/a&gt;)   &lt;/p&gt;
&lt;p&gt;Event class:  &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image016.png" /&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week4_1/pasted_image017.png" /&gt;   &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 3-2 Quicksort</title><link href="http://x-wei.github.io/algoI_week3_2.html" rel="alternate"></link><updated>2015-08-22T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week3_2.html</id><summary type="html">&lt;p&gt;(maybe best algorithm for sorting.)   &lt;/p&gt;
&lt;h1&gt;1. Quicksort&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Idea:&lt;/strong&gt;     &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;shuffle the array     &lt;/li&gt;
&lt;li&gt;&lt;em&gt;Partition&lt;/em&gt; the array into two subarrays to left and right of pivot  (*now pivot is &lt;strong&gt;*in its final position&lt;/strong&gt;)   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;no larger entry to the left of pivot   &lt;br /&gt;
no smaller entry to the right of pivot     &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sort each subarray recursively     &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image.png" /&gt;      &lt;/p&gt;
&lt;h2&gt;Implemetation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;The partition process:&lt;/strong&gt;    &lt;br /&gt;
这个方法也比较巧妙.  &lt;br /&gt;
Use 2 pointers i and j (个人觉得用hi, lo, pivot更好...) :    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image001.png" /&gt;    &lt;br /&gt;
→ a[i]&amp;gt;=a[lo], a[j]&amp;lt;&lt;strong&gt;=&lt;/strong&gt;a[lo] (注意是大于&lt;strong&gt;等于&lt;/strong&gt;/小于&lt;strong&gt;等于&lt;/strong&gt;)    &lt;br /&gt;
⇒ exchange i and j    &lt;br /&gt;
→ Scan until i and j cross (ie. j&amp;lt;=i)    &lt;br /&gt;
⇒ finally exchange lo with &lt;strong&gt;j&lt;/strong&gt; &lt;br /&gt;
函数的签名定义的好: 把lo到hi部分的数组分成两部分, 并返回分割点的index.   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private static int partition(Comparable[] a, int lo, int hi){   
    int i=lo+1, j=hi;   
    while(i&amp;lt;j){   
        while( i&amp;lt;=hi &amp;amp;&amp;amp; less(a[i],a[lo]) ) i++; //a[i]&amp;gt;=a[lo]   
        while( j&amp;gt;=lo &amp;amp;&amp;amp; less(a[lo],a[j]) ) j--; //a[j]&amp;lt;=a[lo]   
        if(i&amp;lt;j) exch(a,i++,j--);   
    }   
    exch(a,lo,j); //exchange pivot with j   
    return j; //j in its final position   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个函数其实并不好写对:     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;test for cross pointers is not trival (ex. edge case: the pivot is the smallest/largest entry in the range)   &lt;/li&gt;
&lt;li&gt;i&amp;lt;=hi is necessary !    &lt;/li&gt;
&lt;li&gt;for keys equal to a[lo]: better to stop at them   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;invariance:    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image002.png" /&gt;      &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Quicksort:   &lt;/strong&gt; &lt;br /&gt;
使用partition函数和辅助sort函数(recursive).  注意在整个流程开始以前先shuffle一下.     &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private static void sort(Comparable[] a, int lo, int hi){   
    if(hi&amp;lt;=lo) return;   
    int pivot = partition(a, lo, hi);   
    sort(a,lo,pivot-1);   
    sort(a,pivot+1,hi);   
    return;
}   
public static void sort(Comparable[] a){   
    StdRandom.shuffle(a); // don&amp;#39;t forget to shuffle the array   
    sort(a,0,a.length-1);   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The randomness is preserved: the subarrays after partitionning is still randomly ordered.      &lt;/p&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;Performance: ~40% faster than mergesort.      &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Best case&lt;/strong&gt;   &lt;/p&gt;
&lt;h1&gt;compares = NlgN&lt;/h1&gt;
&lt;p&gt;(each partition will divide the array in half)     &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Worst case  &lt;/strong&gt;   &lt;/p&gt;
&lt;h1&gt;compares = 1/2*N^2&lt;/h1&gt;
&lt;p&gt;N+(N-1)+...+1 &lt;br /&gt;
if the array is already in order, &lt;em&gt;each partition will have one subarray of length=0&lt;/em&gt;     &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Average case  &lt;/strong&gt;   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;proposition  &lt;/strong&gt; &lt;br /&gt;
On average, for array with N distinct keys, the #compares =  ~2NlnN, #exchanges = ~1/2&lt;em&gt;NlnN.    &lt;br /&gt;
&lt;/em&gt;Proof.*    &lt;br /&gt;
C(N) := # compares for N entries   &lt;br /&gt;
pivot 在N个数离的排名是uniform的    &lt;br /&gt;
接下来的数学推到很漂亮(不过可能没啥用..)     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image003.png" /&gt;       &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image004.png" /&gt;      &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image006.png" /&gt;         &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(上面最后一行写错了... 是2NlnN...orz)
random shuffle: probalistic guarantee against worst case.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pitfalls    &lt;/strong&gt; &lt;br /&gt;
implementations will get &lt;em&gt;quadratic&lt;/em&gt; performance if array:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is sorted or reverse sorted   &lt;/li&gt;
&lt;li&gt;has many duplicates (even if randomized)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Staility  &lt;/strong&gt; &lt;br /&gt;
Quicksort is &lt;strong&gt;NOT&lt;/strong&gt; stable.   &lt;br /&gt;
partitionning can make long range exchanges   &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image007.png" /&gt;      &lt;/p&gt;
&lt;h2&gt;Practical improvements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cutoff to insertion sort for &amp;lt;10 items    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ ~20% improvement    &lt;br /&gt;
Or we can leave the small subarrays unsorted and sort them at last using insertion sort      &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;estimate median by sampling 3 items       &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image008.png" /&gt; &lt;br /&gt;
 → 10% improvement     &lt;/p&gt;
&lt;h1&gt;2. Selection&lt;/h1&gt;
&lt;p&gt;Goal: &lt;em&gt;given un array, find the kth largest item.&lt;/em&gt;    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Upper bound for this problem: NlgN (just sort the array)    &lt;/li&gt;
&lt;li&gt;for small k (ex k=1,2,3), the upper bound is N (one-pass/two-pass)     &lt;/li&gt;
&lt;li&gt;Lower bound is N: at least have to look at everything     &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Quick select&lt;/h2&gt;
&lt;p&gt;Algo proposed also by Hoare:      &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;partition the array into two arrays left of pivot and right of pivot.      &lt;/li&gt;
&lt;li&gt;if pivot==k: return      &lt;/li&gt;
&lt;li&gt;continue the partition for just one of the subarrays       &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类似于二分查找的过程....  &lt;br /&gt;
注意这里&lt;strong&gt;是不用递归的&lt;/strong&gt;! 因为partition函数返回的直接就是pivot&lt;em&gt;在整个数组里的&lt;/em&gt;位置!    &lt;/p&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;privater static int partition(Comparable[] a, int lo, int hi){...}

public static Comparable select(Comparable[] a, int k){   
    StdRandom.shuffle(a);   
    int lo=0,hi=a.length-1;   
    while(true){   
        int j = partition(a,lo,hi);   
        if(j&amp;lt;k) lo=j+1;   
        if(j==k) return a[j];   
        else hi=j-1;   
        if(hi&amp;lt;=lo) break;   
    }   
    return a[k];//这里不太理解为什么会在hi&amp;lt;lo的时候直接返回a[k]   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Proposition  &lt;/strong&gt; &lt;br /&gt;
Quick selection takes &lt;strong&gt;linear&lt;/strong&gt; time on average.   &lt;br /&gt;
*proof  * &lt;br /&gt;
intuitively, each partition will ct the subarray size in half:  &lt;br /&gt;
N+N/2+N/4+... = 2N   &lt;br /&gt;
formal analysis 略...   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;worst case&lt;/strong&gt;: quadratic (but very rare to happen)   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theoretical results&lt;/strong&gt;   &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image009.png" /&gt;         &lt;/p&gt;
&lt;h1&gt;3. Duplicate keys&lt;/h1&gt;
&lt;p&gt;if array contains many duplicate keys.    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;huge array     &lt;/li&gt;
&lt;li&gt;small number of distinct keys     &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;for mergesort  &lt;/strong&gt; &lt;br /&gt;
insensitive... always ~NlgN compares.     &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for quicksort  &lt;/strong&gt; &lt;br /&gt;
Will get &lt;em&gt;quadratic&lt;/em&gt; time if not stop on equal keys. (found in 1990s)    &lt;br /&gt;
mistake: put all items equal to pivot *to just one side   * &lt;br /&gt;
→ N^2 compares if all keys are equal from lo to hi.  &lt;br /&gt;
correct: put all items equal to pivot in their final place.    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image010.png" /&gt;      &lt;/p&gt;
&lt;h2&gt;3-way partitionning&lt;/h2&gt;
&lt;p&gt;(by Dijkstra)   &lt;br /&gt;
partition the array into 3 parts:     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image011.png" /&gt;       &lt;/p&gt;
&lt;p&gt;Dijkstra's 3-way partition algo:  &lt;br /&gt;
使用3个指针: lt指向中间部分的左边界, gt指向右边界;  i指针从左向右扫描, 算法很subtle:     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lt=lo, gt=hi, i=lo   &lt;/li&gt;
&lt;li&gt;if a[i]==v : i++   &lt;/li&gt;
&lt;li&gt;if a[i]&amp;lt;v: exch(i,lt), i++, lt++   &lt;/li&gt;
&lt;li&gt;if a[i]&amp;gt;v: exch(i,gt), gt--    &lt;/li&gt;
&lt;li&gt;repeat until i and gt cross (i&amp;gt;gt)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;invariance&lt;/em&gt;&lt;/strong&gt;:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[lo, lt)&lt;/code&gt; &lt;strong&gt;&lt;em&gt;all &amp;lt; v&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[lt, i)&lt;/code&gt; &lt;strong&gt;&lt;em&gt;all == v&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(gt, hi]&lt;/code&gt; &lt;strong&gt;&lt;em&gt;all &amp;gt;v&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image012.png" /&gt;      &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image013.png" /&gt;      &lt;/p&gt;
&lt;h2&gt;Implementation: 3-way quick sort&lt;/h2&gt;
&lt;p&gt;不必再写partition函数, 直接在sort递归函数里面.     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image014.png" /&gt;        &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private static void sort(Comparable[] a, int lo, int hi){   
    if(hi&amp;lt;=lo) return; // 递归函数别忘了先写终止条件...   
    int lt=lo, gt = hi;   
    Comparable v = a[lo];   
    for(int i=lo;i&amp;lt;=gt;){ //不能写 i++   
        if( less(a[i],v) )   
            exch(a, i++, lt++);   
        else if ( less(v,a[i]) )   
            exch(a,i,gt--);   
        else // v==a[i]   
            i++;   
    }   
    sort(a, lo, lt-1);   
    sort(a, gt+1, hi);  
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image015.png" /&gt;    &lt;br /&gt;
当N个数有很多重复的时候, lower bound可以变小于NlgN:     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image016.png" /&gt;       &lt;br /&gt;
And Sedgewick proved that the 3-wy partition is propotional to the lower bound....     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image017.png" /&gt;      &lt;/p&gt;
&lt;h1&gt;4. System Sorts&lt;/h1&gt;
&lt;p&gt;Arrays.sort() in java:   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;import java.util.Arrays;&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image018.png" /&gt;    &lt;br /&gt;
quicksort for primitive arrays, mergesort for objects: java设计者认为如果用obj array表示空间不是问题...   &lt;/p&gt;
&lt;p&gt;Pb in java's system sort: killer input exsit (havn't shuffle)...    &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image020.png" /&gt;      &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_2/pasted_image021.png" /&gt;      &lt;br /&gt;
总结一下学过的5/6种排序:     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_2/pasted_image022.png" /&gt;      &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 3-1 Mergesort</title><link href="http://x-wei.github.io/algoI_week3_1.html" rel="alternate"></link><updated>2015-08-21T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week3_1.html</id><summary type="html">&lt;p&gt;Two classical sorting algorithms: mergesort, quicksort.    &lt;/p&gt;
&lt;h1&gt;1. Mergesort&lt;/h1&gt;
&lt;p&gt;Divide and conquer: top 10 algorithms of the 20th century, invented by von Neumann.     &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Idea&lt;/strong&gt;:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;divide array into 2 halves   &lt;/li&gt;
&lt;li&gt;recursively sort each half   &lt;/li&gt;
&lt;li&gt;merge two sorted halves   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Merge&lt;/strong&gt;:  &lt;br /&gt;
Goal: a[lo] to a[mid] and a[mid+1] to a[hi] are sorted ⇒ get a[lo] to a[hi] sorted.  &lt;br /&gt;
→&lt;em&gt;use an auxiliary array to copy data&lt;/em&gt;: using 3 indices i,j,k.     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image.png" /&gt;      &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private static void merge(Comparable[]a, Comparable[] aux, int hi, int mid, int lo ){   
for(int k=lo;k&amp;lt;=hi;k++) aux[k]=a[k];   
int i=lo, j=mid+1, k=lo;   
while(i&amp;lt;=mid &amp;amp;&amp;amp; j&amp;lt;=hi){   
    if(less(aux[j],aux[i])) a[k++] = aux[j++];   
    else a[k++] = aux[i++];   
}   
while(i&amp;lt;=mid) a[k++] = aux[i++];   
while(j&amp;lt;=hi) a[k++] = aux[j++];   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;note: we use &lt;code&gt;if(less(aux[j],aux[i]))&lt;/code&gt;instead of&lt;code&gt;if(less(aux[j],aux[i]))&lt;/code&gt;, because less(a,b) == true iff a&amp;lt;b (strict), and we want to make mergesort &lt;strong&gt;stable&lt;/strong&gt;. See section (5) below.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assertion&lt;/strong&gt; &lt;br /&gt;
We can also add &lt;em&gt;assertions&lt;/em&gt;: &lt;code&gt;assert isSorted(a, lo, mid); assert isSorted(a,mid+1, hi);&lt;/code&gt;    &lt;br /&gt;
Enable/disable assertion at runtime:  &lt;br /&gt;
&lt;code&gt;java -ea MyProgram&lt;/code&gt; //enable assertion &lt;br /&gt;
&lt;code&gt;java -da MyProgram&lt;/code&gt; //disable assertion: &lt;strong&gt;default&lt;/strong&gt; &lt;br /&gt;
Best practice:  &lt;br /&gt;
use assertions to check interval invariants; &lt;br /&gt;
do NOT use assert for external argument checking !    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mergesort   &lt;/strong&gt; &lt;br /&gt;
为了mergesort需要写两个辅助函数: merge和sort(recursive):   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class MergeSort extends AbstractSort{   
    public static void sort(Comparable[] a){   
        Comparable[] aux = new Comparable[a.length];   
        sort(a,aux,0,a.length-1);   
    }   
    private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi){   
        if(hi&amp;lt;=lo) return;    
        int mid = (hi+lo)/2;    
        sort(a,aux,mid+1,hi);   
        sort(a,aux,lo,mid);   
        merge(a,aux,hi,mid,lo);

    }   
    private static void merge(Comparable[]a, Comparable[] aux, int hi, int mid, int lo ){   
    // as before...   
    }   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有几点注意的:    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注意递归终止条件是&lt;code&gt;hi&amp;lt;=lo&lt;/code&gt;, 不是&lt;code&gt;==&lt;/code&gt;.    &lt;/li&gt;
&lt;li&gt;实现的代码不难, 但是定义好辅助函数的参数并不简单... 比如在merge里使用了mid作为参数.    &lt;/li&gt;
&lt;li&gt;aux的数组直接写在了函数参数里面, 好处是可以防止反复声明数组带来的开销.   &lt;/li&gt;
&lt;li&gt;发现他们写的时候mid都是写成: &lt;code&gt;mid = lo+(hi-lo)/2&lt;/code&gt;, &lt;a href="http://stackoverflow.com/questions/25571359/why-we-write-lohi-lo-2-in-binary-search"&gt;查了一下&lt;/a&gt;发现这样的原因是为了防止hi+lo整数溢出...嗯有道理.    &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;proposition (time)&lt;/strong&gt; &lt;br /&gt;
Mergesort takes at most NlgN compares and 6NlgN array access.  &lt;br /&gt;
&lt;em&gt;Proof.&lt;/em&gt; &lt;br /&gt;
def: C(N)=#compares for N elements, A(N)=#array access for N elements, the recurrence eq:  &lt;br /&gt;
C(N) &amp;lt;= 2&lt;em&gt;C(N/2) + N; C(1) = 0  (最多N次比较: 每个a[]的数都由比较得到)    &lt;br /&gt;
A(N) &amp;lt;= 2&lt;/em&gt;A(N/2) + 6N; A(1) = 0 (~~这里不太理解为什么是6N, 怎么数都是4N或者5N啊?......~~2N复制到aux, 2N复制回去, 2N比较)    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image001.png" /&gt;    &lt;br /&gt;
(上图蓝色的一列是extra cost)      &lt;br /&gt;
或者用递推公式, 发现D(N)/N的递推关系:     &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image002.png" /&gt;        &lt;br /&gt;
或者用数学归纳法:    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image003.png" /&gt;      &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposition(memory)&lt;/strong&gt;    &lt;br /&gt;
Mergesort takes N extra memory. &lt;br /&gt;
⇒ mergesort is NOT &lt;em&gt;in-place&lt;/em&gt; sorting method.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;def&lt;/strong&gt;. &lt;em&gt;"in-place"&lt;/em&gt; &lt;br /&gt;
A sorting algo is in-place if it uses &amp;lt;C*lgN extra memory.  &lt;br /&gt;
ex. insertion sort, shellsort, selection sort...   &lt;/p&gt;
&lt;h2&gt;Practical improvements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;use insertion sort for small arrays:     &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cutoff to insertion sort for &amp;lt;7 items.    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image004.png" /&gt;    &lt;br /&gt;
⇒ lead to 20% improvement!     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stop if alread sorted: *a[mid]&amp;lt;a[mid+1]!   *   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_1/pasted_image005.png" /&gt;      &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;switch the role of &lt;code&gt;a[]&lt;/code&gt; and &lt;code&gt;aux[]&lt;/code&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_1/pasted_image006.png" /&gt;       &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image007.png" /&gt;      &lt;/p&gt;
&lt;h1&gt;2. Bottom-up Mergesort&lt;/h1&gt;
&lt;p&gt;bottom-up version of mergesort &lt;em&gt;without recursion&lt;/em&gt;.  &lt;br /&gt;
Idea:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pass and merge subarrays of size 1 in pairs      &lt;/li&gt;
&lt;li&gt;repeat for subarrays of size 2,4,8,....      &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_1/pasted_image008.png" /&gt;      &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;p&gt;看着上面那个图好写一点... 就是每次用更大的size来两两merge一遍数组   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public static void sort(Comparable[] a){   
    Comparable[] aux = new Comparable[a.length];   
    for(int sz=1;sz&amp;lt;a.length;sz*=2){   
        for(int i=0;i&amp;lt;a.length-sz;i+=sz*2)   
            merge( a,aux,i,i+sz-1,Math.min(i+sz*2-1) );//&amp;lt;-注意mid和hi的计算方法   
    }   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;3. Sorting Complexity&lt;/h1&gt;
&lt;p&gt;some items:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;computational model: allowed operations, (ex. &lt;em&gt;decision tree for compare based sorting&lt;/em&gt;).     &lt;/li&gt;
&lt;li&gt;cost model: operation counts.    &lt;/li&gt;
&lt;li&gt;upper bound: cost guarantee (ex. NlgN for mergesort). .    &lt;/li&gt;
&lt;li&gt;lower bound: limit on cost guarantee for all algorithms (no algorithm can do better).    &lt;/li&gt;
&lt;li&gt;Optimal algorithm: algo with best cost guarantee. (upper bound=lower bound)   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;证明lower bound 的方法很有意思:    &lt;/p&gt;
&lt;h2&gt;lower bound for sorting&lt;/h2&gt;
&lt;p&gt;(binary) decision tree for the case of 3 distinct items:      &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image009.png" /&gt;         &lt;/p&gt;
&lt;p&gt;each possible ordering is a leaf of the decision tree → there are N! possible orderings → tree height should be lg(N!) = NlgN (cf. &lt;a href="https://en.wikipedia.org/wiki/Stirling%27s_approximation"&gt;https://en.wikipedia.org/wiki/Stirling%27s_approximation&lt;/a&gt;)    &lt;br /&gt;
&lt;strong&gt;proposition.  &lt;/strong&gt; &lt;br /&gt;
Any compare-based sorting algorithm must have at least lg(N!)~NlgN compares in the worst case. (for N distinct keys)        &lt;br /&gt;
&lt;em&gt;proof.&lt;/em&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;binary tree of height h has at most 2^h leaves     &lt;/li&gt;
&lt;li&gt;N! possible orderings → at least N! leaves     &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_1/pasted_image010.png" /&gt;     &lt;br /&gt;
 So, lower bound for sorting = ~NlgN ⇒ &lt;em&gt;mergesort &lt;strong&gt;&lt;em&gt;is&lt;/em&gt;&lt;/strong&gt; an asymptotical optimal algorithm&lt;/em&gt;. (In terms of time complexity, the shortcoming of mergesort is always the extra space usage)   &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image011.png" /&gt;       &lt;br /&gt;
 但是并不是说NlgN是&lt;em&gt;所有&lt;/em&gt;排序问题的下界:   &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image012.png" /&gt;      &lt;/p&gt;
&lt;h1&gt;4. Comparators&lt;/h1&gt;
&lt;p&gt;Java mechenism for comparing same data on different ways.    &lt;/p&gt;
&lt;h2&gt;Comparable interface&lt;/h2&gt;
&lt;p&gt;→Sorting using &lt;em&gt;natural order&lt;/em&gt; for a data type. &lt;br /&gt;
    public class Data implements Comparable&lt;Date&gt;{ &lt;br /&gt;
    public int compareTo(Date that){ &lt;br /&gt;
    //...} &lt;br /&gt;
    }   &lt;/p&gt;
&lt;h2&gt;Comparator interface&lt;/h2&gt;
&lt;p&gt;→Sorting using  an &lt;em&gt;alternative order&lt;/em&gt;. (total order property is required...)   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public interface Comparator&amp;lt;Key&amp;gt;{   
    int compare(Key v, Key w);   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Comparator can be passed as arguments in java system sort:   &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image013.png" /&gt;      &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Using Comparators in our sorting algos   &lt;/strong&gt; &lt;br /&gt;
Use another signature:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;change Comparable to Object   &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;add Comparator in arguments   &lt;/p&gt;
&lt;p&gt;public static void sort(Object[] a, Comparator comparator); &lt;br /&gt;
public static boolean less(Comparator c, Object v, Object w);    &lt;/p&gt;
&lt;p&gt;public static void exch(Object[] a, int i, int j);   &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Implementing a comparator    &lt;/strong&gt; &lt;br /&gt;
Add static comparator to a class:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the declaration of a class, define an inner class that implements the Comparator interface,    &lt;/li&gt;
&lt;li&gt;Then declare an instance of this inner class as a static final variable...   &lt;/li&gt;
&lt;li&gt;note: the inner class should be &lt;strong&gt;static&lt;/strong&gt; also.      &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week3_1/pasted_image014.png" /&gt;    &lt;br /&gt;
以上的方法目的是为某个类提供预先定义好的comparator(比如&lt;code&gt;String.CASE_INSENSITIVE_ORDER&lt;/code&gt;), 另外也可以直接再声明一个类作为comparator, 然后实例化这个类传进去, 就像之前做过的那样.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Application: Graham scan algo for convex hull  &lt;/strong&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image015.png" /&gt;    &lt;br /&gt;
We can get the result of compare by calling &lt;code&gt;ccw(a,b,c)&lt;/code&gt; : &lt;br /&gt;
*ccw(p,q1,q2)=true ⇔ q2&amp;gt;q1 in terms of polar angle wrt p. (别忘了p是y坐标最小的点, 否则还要讨论角坐标为负数的情况, 见下图).    * &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image016.png" /&gt;         &lt;/p&gt;
&lt;h1&gt;5. Stability&lt;/h1&gt;
&lt;p&gt;Typical application: first sort by student name then by section.    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;def. :stable"&lt;/strong&gt; &lt;br /&gt;
&lt;em&gt;A stable sort preserves the relative order for items with equal keys.&lt;/em&gt;    &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Insertion sort and mergesort are stable, whereas selection sort and shell sort are not.&lt;/em&gt; (And always need to carefully check code: "less than" vs. "less than or equal to").   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;insertion sort:&lt;/strong&gt;    &lt;br /&gt;
stable &lt;br /&gt;
proof: we never move equal items pass each other: &lt;code&gt;if(less(a[j], a[j-1])) exch(...)&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;selection sort:  &lt;/strong&gt; &lt;br /&gt;
not stable   &lt;br /&gt;
counter example:  &lt;br /&gt;
when exchanging A1 and B1, we move B1 behind B2    &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image017.png" /&gt;        &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;shell sort:  &lt;/strong&gt; &lt;br /&gt;
counter example: long-dist exchanges   &lt;br /&gt;
&lt;img alt="" src="algoI_week3_1/pasted_image018.png" /&gt;      &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;merge sort:   &lt;/strong&gt; &lt;br /&gt;
stable &lt;br /&gt;
proof: suffices to verify that merge operation is stable, if keys are equal, always take element from left subarray.    &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 2-2 Elementary Sorts</title><link href="http://x-wei.github.io/algoI_week2_2.html" rel="alternate"></link><updated>2015-08-18T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week2_2.html</id><summary type="html">&lt;h1&gt;1. Introduction&lt;/h1&gt;
&lt;p&gt;rearanging array of size N into ascending order &lt;br /&gt;
test client code: &lt;code&gt;Insertion.sort(a);&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;sort &lt;em&gt;any&lt;/em&gt; datatype &lt;/p&gt;
&lt;h3&gt;callback&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;callback = reference to executable code&lt;/em&gt; &lt;br /&gt;
i.e. passing functions as argument to sort() method&lt;br /&gt;
sort() function calls object's &lt;code&gt;compareTo()&lt;/code&gt; method  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image.png" /&gt; &lt;br /&gt;
→ implement the &lt;code&gt;Comparable&lt;/code&gt; interface:    &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    public class XX implements Comparable&amp;lt;XX&amp;gt;{
    ...
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;the interface: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    public interface Comparable&amp;lt;Item&amp;gt;{
        public int compareTo(Item that);
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;compareTo():&lt;br /&gt;
return -1 (if this&amp;lt;that)/+1/0; 
needs a &lt;em&gt;total order.&lt;/em&gt; 
→ in the sort() implementation:&lt;br /&gt;
has not dependencies on type of data.  &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    public static void sort(Comparable[] a){
        if(a[i].compareTo(a[j])&amp;gt;0)...
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;helper functions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;less&lt;/p&gt;
&lt;p&gt;private static boolean less(Comparable v, Comparable u){
returnv.compareTo(u)&amp;lt;0;
}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;exch&lt;/p&gt;
&lt;p&gt;private void exch(Comparable[] a, int i, int j) {
        Comparable swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;isSorted&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;test if sorted
if algo passes the test using only less ant swap, then it's correct. &lt;/p&gt;
&lt;h1&gt;2. Selection Sort&lt;/h1&gt;
&lt;p&gt;Idea: each time&lt;em&gt;: find the minimum from the remaining items.&lt;/em&gt; 
&lt;strong&gt;a[min] is the smallest element to right of a[i] ⇒ swap a[i] and a[min]&lt;/strong&gt; (elements to left of i are sorted) &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image002.png" /&gt;    &lt;/p&gt;
&lt;h2&gt;invariants&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;entries to the left of i are in sorted order, and are fixed (&lt;em&gt;in final position&lt;/em&gt;) ever since&lt;/li&gt;
&lt;li&gt;no entry to the right of i is smaller than any entry to the left of i&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class SelectionSort extends AbstractSorting{
//...
public static void sort(Comparable[] a){
    for(int i = 0; i&amp;lt;a.length; i++){
        int min = i;
        for(int j = i+1; j&amp;lt;a.length; j++)
            if(less(a[j],a[min])) 
                min = j;
        exch(a,min,i);
    }
}
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;proposition:&lt;/strong&gt;
selection sort uses &lt;em&gt;N-1 + N-2 + ... + 1 = ~N^2/2&lt;/em&gt; compares, and &lt;em&gt;N&lt;/em&gt; exchanges. 
→ quadratic time&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_2/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;insensitive&lt;/strong&gt; to input: quadratic time &lt;em&gt;even if input is already sorted.&lt;/em&gt; &lt;/li&gt;
&lt;li&gt;data movement is &lt;em&gt;minimum&lt;/em&gt;: linear time of exchanges (every exchange puts an item to its final position)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;3. Insertion sort&lt;/h1&gt;
&lt;p&gt;quite different performance characteritics than selection sort. &lt;/p&gt;
&lt;p&gt;Idea: &lt;strong&gt;In iteration i: move all entries larger than a[i] to its left.&lt;/strong&gt;  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image004.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;invariants&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;entries to the left of i are in ascending order (but &lt;em&gt;not&lt;/em&gt; in final position)&lt;/li&gt;
&lt;li&gt;entries to the right of i are not yet been seen   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_2/pasted_image005.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;publc class InsertionSorting extends AbstractSorting{
    public static void sort(Comparable[] a){
        for(int i=1; i&amp;lt;a.length; i++)
            for(int j=i; j&amp;gt;0; j--){
                if(less(a[j],a[j-1]))
                    exch(a,j,j-1);
                else break;
            }
    }
    //...
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;proposition &lt;/strong&gt;(average case): &lt;br /&gt;
(the performance &lt;em&gt;on average&lt;/em&gt; — &lt;em&gt;for randomly sorted array&lt;/em&gt; ) &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image007.png" /&gt; &lt;br /&gt;
&lt;em&gt;proof:&lt;/em&gt;
&lt;em&gt;expect each entry to move halfway back&lt;/em&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image008.png" /&gt;   &lt;/p&gt;
&lt;h3&gt;best case and worst case&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;best case&lt;/strong&gt;
if array already sorted min ascending order: 
&lt;em&gt;N-1 compares, 0 exchanges.&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;worst case&lt;/strong&gt;
if array sorted in descending order: 
every element goes all the way back → 1/2&lt;em&gt;N^2 compares,  1/2&lt;/em&gt;N^2 exchanges&lt;/p&gt;
&lt;h3&gt;partially  sorted arrays&lt;/h3&gt;
&lt;p&gt;def.&lt;strong&gt;" inversion"&lt;/strong&gt;
an inversion is a pair of entries that are out of order. &lt;/p&gt;
&lt;p&gt;def. &lt;strong&gt;"partially sorted"&lt;/strong&gt;&lt;br /&gt;
An array is called partially sorted if the &lt;em&gt;number of inversions is &amp;lt;= c&lt;/em&gt;N. *&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;proposition. &lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Insertion sort runs in linear time for partially sorted array.&lt;/strong&gt; 
&lt;em&gt;proof.&lt;/em&gt; 
&lt;em&gt;number of exchanges = number of inversions. &lt;/em&gt;
&lt;em&gt;number of compares = number of exchanges + N-1&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;4. Shell Sort&lt;/h1&gt;
&lt;p&gt;First non-trival sorting methode: an improvement of insertion sort. &lt;/p&gt;
&lt;p&gt;def. &lt;strong&gt;"h-sorted array"&lt;/strong&gt;&lt;br /&gt;
an array is h-sorted if every h-interleaved subarray is sorted. (h=1: just a sorted array)  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image009.png" /&gt;     &lt;/p&gt;
&lt;p&gt;Idea: move entries &amp;gt;1 position at a time by &lt;em&gt;h-sorting&lt;/em&gt; the array, then decrease h.   &lt;/p&gt;
&lt;p&gt;use decreasing sequences of value h:  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image010.png" /&gt;     &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;How to h -sort  &lt;/strong&gt;&lt;br /&gt;
simply insertion sort with &lt;em&gt;stride length=h&lt;/em&gt;.&lt;br /&gt;
why insertion sort: &lt;br /&gt;
for big h: small subarray &lt;br /&gt;
for small h: nearly in order   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;proposition&lt;/strong&gt;&lt;br /&gt;
A g-sorted array &lt;em&gt;remains g-sorted&lt;/em&gt; after h-sorting it.  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image011.png" /&gt;  &lt;br /&gt;
(subtle to prove...)  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;which sequence of h to use&lt;/strong&gt;
&lt;code&gt;3x+1&lt;/code&gt; sequence proposed by Knuth. &lt;em&gt;1,4,13,40....&lt;/em&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class ShellSort extends AbstractSort{
    public static void sort(Comparable[] a){
        int h = 1, N=a.length;
        while(h&amp;lt;N/3) h = h*3+1;//find the beginning h (N&amp;gt;h&amp;gt;N/3)
        while(h&amp;gt;=1){//performs h-sort
            for(int i= h;i&amp;lt;N;i+=h)
                for(int j = i;j-h&amp;gt;=0;j-=h)
                    if( less(a[j],a[j-h]) )
                        exch(a,j,j-h)
                    else break;
            h = h/3;
        }
    }
    //...
    private static boolean isHsorted(Comparable[] a, int h) {
        for (int i = h; i &amp;lt; a.length; i++)
            if (less(a[i], a[i-h])) return false;
        return true;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每次hsort, 外围的循环是&lt;code&gt;for(int i= h;i&amp;lt;N;i+=h)&lt;/code&gt;, 需要理解一下: i移动一次以后, 进行的是另一个subarray 的插入排序, 当移动到N-1的时候所有subarray的插入排序才结束. (也就是说不是先完成一个subarray的插入排序再完成另一个, 这些是插入排序是同步进行的)&lt;/p&gt;
&lt;h2&gt;analysis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;proposition (for worst case   )&lt;/strong&gt;&lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image012.png" /&gt;   &lt;br /&gt;
→ better than quadratic time !     &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;property  (found in practice)&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;of compares &amp;lt; Cte * N * (# of &lt;em&gt;h&lt;/em&gt; used )&lt;/h1&gt;
&lt;p&gt;→ #compares &amp;lt; NlgN * Cte &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image013.png" /&gt; &lt;br /&gt;
*accurate model has not been discovered  *&lt;/p&gt;
&lt;p&gt;(所以shellsort在实际使用中几乎和快速排序一样快! — 尽管没有数学证明来保证)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;why we are interested in shell sort&lt;/strong&gt;
useful in practice: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fast for medium sized arrays (beat even the classical sophistiated algorithms)  &lt;/li&gt;
&lt;li&gt;tiny code volumn (used in embeded systems)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;lead to interesting questions for 50 years: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;asymptotic growth rate ?&lt;/li&gt;
&lt;li&gt;best sequence of h ?&lt;/li&gt;
&lt;li&gt;average case performance ?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;5. shuffling&lt;/h1&gt;
&lt;h2&gt;shuffle array using sort&lt;/h2&gt;
&lt;p&gt;one way to shuffle an array: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;for each array entry, generate a random real number&lt;/li&gt;
&lt;li&gt;sort the array of real numbers&lt;/li&gt;
&lt;li&gt;⇒ the original array is shuffled !&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;proposition  &lt;/strong&gt;&lt;br /&gt;
this shuffle sort produces a uniformly random permutation of input array &lt;br /&gt;
&lt;em&gt;drawback:  cost for sorting...&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Goal: get uniformly random permutation in &lt;em&gt;linear time&lt;/em&gt;.   &lt;/p&gt;
&lt;h2&gt;Knuth shuffle&lt;/h2&gt;
&lt;p&gt;algo:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;for i = [0,N):&lt;br /&gt;
    - r = rand( [0~i&lt;strong&gt;]&lt;/strong&gt; ) or rand( &lt;strong&gt;[&lt;/strong&gt;i, N-1] ) &lt;br /&gt;
    - swap a[r] and a[i]   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_2/pasted_image014.png" /&gt;&lt;/p&gt;
&lt;p&gt;implementation: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public static void shuffle(Object[] a){
    for(int i=0;i&amp;lt;a.length;i++){
        int r = StdRandom.uniform(i+1);
        exch(a,r,i);
    }   
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;proposition&lt;/strong&gt;&lt;br /&gt;
Knuth algo produces an uniformly random permutation of input array. &lt;/p&gt;
&lt;p&gt;&lt;em&gt;proof.&lt;/em&gt;&lt;br /&gt;
Sufficient to prove that, for card i and position j, the proba(card i comes to position j) = 1/N. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;if i&amp;lt;=j, P = 1/j * j/(j+1) * (j+1)/(j+2) * ... * (N-1)/N&lt;/li&gt;
&lt;li&gt;if j&amp;lt;i, P = 1/i * i/(i+1) * (i+1)/(i+2) * ... * (N-1)/N&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CQFD.&lt;/p&gt;
&lt;h2&gt;example: online poker&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.cigital.com/papers/download/developer_gambling.php"&gt;https://www.cigital.com/papers/download/developer_gambling.php&lt;/a&gt;  ←那个扑克网站已经被黑出翔了...  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image015.png" /&gt;  &lt;br /&gt;
bugs: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;r never get 52 (52th card never moved)&lt;/li&gt;
&lt;li&gt;r = rand(N) instead of rand(0~i), → shuffle not uniform&lt;/li&gt;
&lt;li&gt;random() uses 32bit seed: only 2^32 possible shuffles, &lt;em&gt;2^32&amp;lt;52!&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;seed = millisec from midnight, ~86*10^6 suffles&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;6. Convex Hull&lt;/h1&gt;
&lt;p&gt;application of sorting for the field of computational geometry.  &lt;/p&gt;
&lt;h2&gt;convex hull&lt;/h2&gt;
&lt;p&gt;smallest polygoneenclosing all N points. &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image017.png" /&gt;      &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;input: N points&lt;/li&gt;
&lt;li&gt;output: sequence of &lt;em&gt;vertices&lt;/em&gt; in counterclockwise (&lt;em&gt;ccw&lt;/em&gt;) order. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;application: robot motion planning; farest pair.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;geometric properties&lt;/strong&gt;:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;can traverse convex hull by making only ccw turns&lt;/li&gt;
&lt;li&gt;let p be the point with lowest y-coord, wrt p, vertices appear in increasing order of polar angle.   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_2/pasted_image018.png" /&gt;   &lt;/p&gt;
&lt;h2&gt;Algo&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Graham scan algorithm:&lt;/strong&gt;&lt;br /&gt;
    * choose p with smallest y coord &lt;br /&gt;
    * &lt;em&gt;sort points by polar angle&lt;/em&gt; with p &lt;br /&gt;
    * consider points in order (stack is used), &lt;em&gt;discard unless creates a ccw turn&lt;/em&gt;.   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_2/pasted_image019.png" /&gt;   &lt;img alt="" src="algoI_week2_2/pasted_image020.png" /&gt;    &lt;img alt="" src="algoI_week2_2/pasted_image021.png" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CCW&lt;/strong&gt; &lt;br /&gt;
given three points a b c, returns if a→b→c is a CCW turn.  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image023.png" /&gt;    &lt;br /&gt;
(assumption: no 3 points on a line)&lt;br /&gt;
 ⇒ calculate &lt;em&gt;cross product of ab and bc ⇒ determinants!&lt;/em&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week2_2/pasted_image024.png" /&gt;   &lt;br /&gt;
area&amp;gt;0 ⇔ CCW   &lt;/p&gt;
&lt;h2&gt;implementation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class Point2D{
private double x,y;
public static boolean ccw(Point2D a,Point2D b,Point2D c){
    double area2 = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
    return area2&amp;gt;0;
}

}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;convex hull:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public static Stack&amp;lt;Point2D&amp;gt; GrahamScan(Point2D[] p){
    //* assumes that points are sorted by polar angle in p[]
    Stack&amp;lt;Point2D&amp;gt; hull = new Stack&amp;lt;Point2D&amp;gt;();
    hull.push(p[0]);
    hull.push(p[1]);
    for(int i=2;i&amp;lt;p.length;i++){
        Point2D b = hull.pop(), a = hull.peek(), c = p[i];
        while(!Point2D.ccw(a,b,c)){
            b = hull.pop();
            a = hull.peek();
        }
        //now a,b,c makes a ccw turn:
        hull.push(b);
        hull.push(c);
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;running time: &lt;em&gt;NlgN for sorting and linear for the rest.&lt;/em&gt; &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 2-1 Stacks and Queues</title><link href="http://x-wei.github.io/algoI_week2_1.html" rel="alternate"></link><updated>2015-07-09T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week2_1.html</id><summary type="html">&lt;p&gt;fundamental data types: stacks and queues
operations: 
&lt;strong&gt;insert, remove, test empy, iterate,&lt;/strong&gt;...  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image.png" /&gt;  &lt;/p&gt;
&lt;p&gt;module programming: seperate interface and implementation&lt;/p&gt;
&lt;h1&gt;1. Stacks&lt;/h1&gt;
&lt;p&gt;ex. a stack of strings&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API: &lt;/p&gt;
&lt;p&gt;public interface StackoOfStrings{
    void push(String item);
    String pop();
    boolean isEmpty();
    //int size();
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;implementation 1: using a linkedlist&lt;/h3&gt;
&lt;p&gt;insert/remove from the top of the linkedlist&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;inner class&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;ListNode&lt;/span&gt;{
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;;
    &lt;span class="n"&gt;ListNode&lt;/span&gt; &lt;span class="k"&gt;next&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;implementation  &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class LinkedStackOfStrings implements StackoOfStrings{
    class Node{
        String item;
        Node next;
        Node(String item, ListNode nxt){...}
    }
    private Node first;

    public LinkedStackOfStrings(){
        first = null;
    }
    public void push(String item){
        Node nd = new Node(item,first);
        first = nd;
    }
    public String pop(){
        String firstItem = first.item;
        first = first.next;
        return firstItem;
    }
    public boolean isEmpty(){
        return first==null;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;complexity: const time for every operation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;array implementation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;use array (of length N) to store items → defect: stack has limited capacity&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;keep a pointer *top: &lt;strong&gt;*pointing to the next empty space to push &lt;/strong&gt;(top 的定义很重要)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;problems of the array implementation: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;underflow: pop from an empty stack  &lt;/li&gt;
&lt;li&gt;overflow: size larger than capacity ⇒ resizing  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;loitering&lt;/strong&gt;: holding a ref to an obj which is no longer needed:
ex. &lt;code&gt;return s[top--]&lt;/code&gt;
java system will not know that s[top] is no longer needed ⇒ have to clear it explicitely
⇒   &lt;/p&gt;
&lt;p&gt;String item = s[top--]; 
s[top]=null; 
return item&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;implementation (containg resizing array operations)  &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class ArrayStackOfStrings implements StackOfStrings{
        private String[] s;
        private int top=0;
        public ArrayStackOfStrings(){// to be tuned
            s = new String[1];//initial capacity=1
        }
        public boolean isEmpty(){
            return top==0;
        }
        private vois resize(int capacity){//helper functoin
            String[] s2 = new String[capacity];
            for(int i=0;i&amp;lt;top;i++)
                s2 = s[i];
            s = s2;
        }
        public void push(String item){
            if(top==s.length)//doubling size 
                resize(s.lenth*2);
            s[top++]=item;
        }
        public String pop(){
            String item = s[--top];//NOT top--!
            s[top]=null;
            if(top&amp;gt;0 &amp;amp;&amp;amp; top==s.length/4) //top&amp;gt;0 is necessary
                resize(s.length/2);
            return item;
        }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;2. Resizing Arrays&lt;/h1&gt;
&lt;p&gt;resolving the overflow pb: grow and shrink the array
→ need to copy all items when changing array size
⇒ pb: &lt;em&gt;ensure that sizing happens infrequently&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;resizing strategy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;repeated doubling:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(initial capacity=1) when array is full, double the size&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;amortized&lt;/em&gt; complexity for inserting N:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;N+(2+4+8+...+N) ~3N&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shrinking array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⇒ shrink the array by half when array is &lt;strong&gt;1/4 full&lt;/strong&gt;
not half full → &lt;em&gt;thrashing&lt;/em&gt; will happen if push-pop-push-pop when array is full &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image001.png" /&gt;      &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[invariant]&lt;/strong&gt;: array always 20%~100% full&lt;/li&gt;
&lt;li&gt;complexity:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;in an amortized sense&lt;/em&gt;, will be constant &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image002.png" /&gt;  &lt;br /&gt;
&lt;strong&gt;proposition&lt;/strong&gt;: from empty stack, M operations of push/pop taked time propotional to M&lt;/p&gt;
&lt;h3&gt;comparison: resizable array vs linkedlist&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;linkedlist implementation: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;operations takes const time even in worst time
extra time and space for dealing with linkes &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;resizing array implementation:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;operation taked const &lt;em&gt;amortized&lt;/em&gt; time
but in worst case takes linear time (ex. to be evited for critical systems)
less wasted space&lt;/p&gt;
&lt;h2&gt;3. Queues&lt;/h2&gt;
&lt;p&gt;FIFO data structure
API&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public interface QueueOfStrings{
    void enqueue(String item);
    String dequeue();
    boolean isEmpty();
    //int size();
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;linked list implementation&lt;/h3&gt;
&lt;p&gt;maintain &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; node pointers: 
pointing to 2 points of queue (&lt;code&gt;first&lt;/code&gt; for dequeue, &lt;code&gt;last&lt;/code&gt; for enqueue ) &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image003.png" /&gt;   &lt;br /&gt;
→ &lt;em&gt;take care of corner cases&lt;/em&gt;: 
- empty queue: first is null (and last is also null) 
- just one item in queue: first and last &lt;em&gt;point to the same node&lt;/em&gt;
(总之first和last的定义很重要)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    public class LinkedQueueOfStrings implements QueueOfStrings{
        class Node{...  }
        private Node first,last;
        public LinkedQueueOfStrings(){
            first = null;
        }
        public void enqueue(String item){//same as push
            Node nd = new Node(item,null);
            if(isEmpty()){
                last = nd;
            first = last;
            }
            else{
                last.next = nd;
                last = nd;
            }
        }
        public String dequeue(){//same as pop in stack
            String firstItem = first.item;
            first = first.next;
            if(isEmpty())
                last=null;
            return firstItem;
        }
        public boolean isEmpty(){
            return first==null;
        }
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;resizing array implementation&lt;/h3&gt;
&lt;p&gt;maintain &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;: 
&lt;code&gt;head&lt;/code&gt; is the queue head, &lt;code&gt;tail&lt;/code&gt; is the &lt;em&gt;next empty position&lt;/em&gt; for the next element to enqueue
→ trick: head and tail should take &lt;em&gt;mod capacity + &lt;/em&gt;resizing array &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image004.png" /&gt; &lt;br /&gt;
不知道写的对不对: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    public class ArrayQueueOfStrings implements QueueOfStrings{
        private String[] q;
        private head=0,tail=0;
        public LinkedQueueOfStrings(){
            q = new String[1];//init capacity
        }
        public boolean isEmpty(){
            return head==tail;
        }
        private void resize(newsz){
            q2 = new String[newsz];
            int i = head,j=0;
            while(i!=tail){
                q2[j++] = q[i];
                i=(i+1)%q.length;
            }
            q = q2;
            head=0;
            tail=j;
        }
        public void enqueue(String item){
            if( (tail+1)%q.length==head )
                resize(q.length*2);
            q[tail] = item;
            tail = (tail+1)%q.length;
        }
        public String dequeue(){
            String firstItem = q[head];
            head = (head+1)%q.length;
            int sz = (tail-head)%q.length;
            if(sz&amp;gt;0 &amp;amp;&amp;amp; sz==q.length/4)
                resize(s.length/2);
            return firstItem;
        }
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;4. Generics&lt;/h1&gt;
&lt;p&gt;queues/stacks for other types of data ⇒ &lt;em&gt;generics 泛型&lt;/em&gt;(java 1.5 才引进泛型机制...)
use &lt;em&gt;type paramater&lt;/em&gt;→ avoid casting, and discover type mismatch errors &lt;em&gt;at compile time&lt;/em&gt; &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    public interface Stack&amp;lt;Item&amp;gt;{
        public void push(Item item);
        public Item pop();
        public boolean isEmpty();
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;a pb with array implementation&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;java不支持创立泛型数组&lt;/strong&gt;
generic array creation is not allowed. 不可以new 一个泛型数组!
&lt;code&gt;s = new Item[capacity];&lt;/code&gt;会报错 &lt;br /&gt;
⇒ use an ugly &lt;em&gt;cast&lt;/em&gt;:
&lt;code&gt;s = (Item[]) new Object[capacity];&lt;/code&gt;
(will get warning: "unchecked cast" → java被黑了... )&lt;/p&gt;
&lt;h3&gt;autoboxing for primitive types&lt;/h3&gt;
&lt;p&gt;each primitive type has a &lt;em&gt;wrapper class&lt;/em&gt;
ex. int ↔ Integer
autoboxing: automatic cast between a primitive type and its wrapper class. &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image005.png" /&gt; &lt;br /&gt;
(syntactic sugar 语法糖 i.e. 对语言功能没有影响只是方便使用)&lt;br /&gt;
btw: &lt;a href="https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E7%B3%96"&gt;https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E7%B3%96&lt;/a&gt; (居然还有语法盐和语法糖精......)&lt;/p&gt;
&lt;h1&gt;5. Iterators&lt;/h1&gt;
&lt;h3&gt;Interface&lt;/h3&gt;
&lt;p&gt;support iteration over stacks and queues, &lt;em&gt;without revealing the internal representation&lt;/em&gt; of stack/queue
⇒ implement the &lt;code&gt;Iterable&lt;/code&gt; interface&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Iterable&lt;/code&gt; interface: can return an *Iterator *&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public interface Iterable{
    Iterator&amp;lt;Item&amp;gt; iterator();
}
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Iterator interface: hasNext() and next() interface&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public interface Iterator&amp;lt;Item&amp;gt;{
    boolean hasNext();
    Item next();
    void remove();//optional, bad practice to use it
}
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;to make a data structure Interable → elegant client code   &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_1/pasted_image006.png" /&gt; &lt;br /&gt;
&lt;strong&gt;how-to:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;implement &lt;code&gt;Iterable&lt;/code&gt; interface&lt;/li&gt;
&lt;li&gt;write a &lt;em&gt;private inner class&lt;/em&gt; XXIterator that implment the &lt;code&gt;Iterator&lt;/code&gt; interface.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ex. &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image007.png" /&gt;   &lt;/p&gt;
&lt;h3&gt;Bag data structure&lt;/h3&gt;
&lt;p&gt;Supports adding and iterating through without caring about the order.&lt;br /&gt;
API: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    public class&amp;lt;Item&amp;gt; Bag implements Iterable&amp;lt;Item&amp;gt;{
        public void add(Item);
        int size(); 
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;can be implemented by stack or queue(without pop/dequeue)&lt;/p&gt;
&lt;h1&gt;6. Applications&lt;/h1&gt;
&lt;h3&gt;Java collections library&lt;/h3&gt;
&lt;p&gt;List interface: &lt;code&gt;java.util.List&lt;/code&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image008.png" /&gt;   &lt;br /&gt;
implementations: &lt;code&gt;ArrayList&lt;/code&gt;, &lt;code&gt;LinkedList&lt;/code&gt;. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pb with the java's implementation of stacks and queues:  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Stack&lt;/code&gt; class also implements List interface (&lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;remove()&lt;/code&gt;, &lt;code&gt;contains()&lt;/code&gt; are implemented);&lt;br /&gt;
&lt;code&gt;Queue&lt;/code&gt; is an interface rather than a class...&lt;br /&gt;
⇒ &lt;strong&gt;poorly designed API  &lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Stacks applications&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;function calls: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week2_1/pasted_image009.png" /&gt;  &lt;br /&gt;
recursion: can always use an explicit stack to remove recursion&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;arithemic evaluation (Dijkstra)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;四种类型: 左括号, 右括号, 数字, 算子  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image010.png" /&gt;&lt;br /&gt;
最后一行应该是value stack.  &lt;br /&gt;
&lt;img alt="" src="algoI_week2_1/pasted_image011.png" /&gt;   &lt;/p&gt;
&lt;p&gt;⇒ 后缀表达式, 逆波兰式......&lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week1-Lab: Percolation</title><link href="http://x-wei.github.io/algoI_week1_lab.html" rel="alternate"></link><updated>2015-07-07T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week1_lab.html</id><summary type="html">&lt;h1&gt;model &amp;amp; problem&lt;/h1&gt;
&lt;p&gt;(原文描述太啰嗦了)&lt;br /&gt;
A system using an N-by-N grid of sites. &lt;br /&gt;
→ Each site is either open or blocked. &lt;br /&gt;
→ A &lt;strong&gt;full&lt;/strong&gt; site is an open site that can be connected to an open site in the top row via a chain of neighboring open sites. (这个full的定义有玄机 而且导致后面写程序时有个问题, 看论坛想了半天才想出来, 见后文.)&lt;br /&gt;
→ We say the system &lt;strong&gt;percolates&lt;/strong&gt; if there is a path of connected open sites form the top row to the bottom row.   &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="file:///home/wx/Dropbox/ZIM_NOTES/0._TmpNotes/Algorithms%2C_4th_ed/Week1-Assignment-Percolation/pasted_image.png" /&gt;   &lt;/p&gt;
&lt;p&gt;⇒ pb: if sites are independently set to be open with probability &lt;strong&gt;p&lt;/strong&gt;, what is the probability that the system percolates? &lt;br /&gt;
&lt;img alt="" src="file:///home/wx/Dropbox/ZIM_NOTES/0._TmpNotes/Algorithms%2C_4th_ed/Week1-Assignment-Percolation/pasted_image001.png" /&gt; &lt;br /&gt;
→ When N is sufficiently large, there is a threshold value **p&lt;strong&gt;&lt;em&gt; such that when p &amp;lt; p&lt;/em&gt; a random N-by-N grid almost never percolates, and when p &amp;gt; p&lt;em&gt;, a random N-by-N grid almost always percolates. &lt;br /&gt;
→ No mathematical solution for determining the percolation threshold p&lt;/em&gt; has yet been derived. &lt;br /&gt;
⇒ Your task is to *write a computer program to estimate p&lt;/strong&gt;.   &lt;/p&gt;
&lt;h1&gt;Method&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class Percolation {
   public Percolation(int N)               // create N-by-N grid, with all sites blocked
   public void open(int i, int j)          // open site (row i, column j) if it is not open already
   public boolean isOpen(int i, int j)     // is site (row i, column j) open?
   public boolean isFull(int i, int j)     // is site (row i, column j) full?
   public boolean percolates()             // does the system percolate?
   public static void main(String[] args   // test client (optional)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Corner cases: the row and column indices i and j are integers between 1 and N. &lt;strong&gt;1≤i,j≤N&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;if i/j out of range: &lt;code&gt;java.lang.IndexOutOfBoundsException&lt;/code&gt;
if N&amp;lt;=0 in constructor: &lt;code&gt;java.lang.IllegalArgumentException&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Performance requirements: N2 for constructor, const for other operations&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Monte Carlo simulation&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;all sites init to be closed&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ randomly choose a blocked site (i,j) and open it 
→ &lt;em&gt;repeat until percolates&lt;/em&gt; ⇒ the fraction of opened sites is an estimation of p*&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ex. 20*20 grid, when percolated: &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="file:///home/wx/Dropbox/ZIM_NOTES/0._TmpNotes/Algorithms%2C_4th_ed/Week1-Assignment-Percolation/pasted_image002.png" /&gt; &lt;br /&gt;
⇒ estimated p* = 204/400=0.51&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;repeat the estimation for T times, get T estimations &lt;/p&gt;
&lt;p&gt;→ get mean and std:  &lt;br /&gt;
&lt;img alt="" src="file:///home/wx/Dropbox/ZIM_NOTES/0._TmpNotes/Algorithms%2C_4th_ed/Week1-Assignment-Percolation/pasted_image003.png" /&gt; &lt;br /&gt;
→ 95% 置信区间: &lt;br /&gt;
&lt;img alt="" src="file:///home/wx/Dropbox/ZIM_NOTES/0._TmpNotes/Algorithms%2C_4th_ed/Week1-Assignment-Percolation/pasted_image004.png" /&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;create API for this simulation: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public class PercolationStats {
   public PercolationStats(int N, int T)     // perform T independent experiments on an N-by-N grid
   public double mean()                      // sample mean of percolation threshold
   public double stddev()                    // sample standard deviation of percolation threshold
   public double confidenceLo()              // low  endpoint of 95% confidence interval
   public double confidenceHi()              // high endpoint of 95% confidence interval
   public static void main(String[] args)    // test client (described below)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-if  N ≤ 0 or T ≤ 0: &lt;code&gt;java.lang.IllegalArgumentException&lt;/code&gt;&lt;br /&gt;
-&lt;code&gt;main()&lt;/code&gt; : takes two command-line arguments N and T&lt;br /&gt;
⇒ performs T independent computational experiments on an N-by-N grid, and prints out the mean, standard deviation, and the 95% confidence interval for p*. &lt;br /&gt;
(Use &lt;a href="http://introcs.cs.princeton.edu/java/stdlib/javadoc/StdRandom.html"&gt;standard random&lt;/a&gt; from our standard libraries to generate random numbers; use &lt;a href="http://introcs.cs.princeton.edu/java/stdlib/javadoc/StdStats.html"&gt;standard statistics&lt;/a&gt; to compute the sample mean and standard deviation. &lt;br /&gt;
Here is the algo API: &lt;a href="http://algs4.cs.princeton.edu/code/index.php"&gt;http://algs4.cs.princeton.edu/code/index.php&lt;/a&gt;)  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Code&lt;/h1&gt;
&lt;p&gt;注意一定要用它们提供的那些库, 否则自己写的话代码就长了.... &lt;br /&gt;
shuffle, mean, stddev什么的直接用他们的函数库就可以做到. &lt;br /&gt;
&lt;a href="http://algs4.cs.princeton.edu/code/index.php"&gt;http://algs4.cs.princeton.edu/code/index.php&lt;/a&gt; &lt;br /&gt;
另外UF也是用他们写好的, WeightedQuickUnionUF.   &lt;/p&gt;
&lt;p&gt;按照提示, 除了格子的N^2个节点以外再增加两个节点: 顶部和底部的虚拟节点. 这里写的时候注意一开始也是不恩能够把它们与第一行/最后一行相连的 — 要在一个格子open以后再相连. &lt;/p&gt;
&lt;h3&gt;backwash问题&lt;/h3&gt;
&lt;p&gt;这次题目有一点比较困难就是, 需要实现isFull()函数, 这个函数判断一个格子(i,j)是否和顶部相连. 这里如果直接用UF的connected()判断是否和顶部虚拟节点相连的话是有问题的, 如下图: &lt;br /&gt;
&lt;img alt="" src="file:///home/wx/Dropbox/ZIM_NOTES/0._TmpNotes/Algorithms%2C_4th_ed/Week1-Assignment-Percolation/pasted_image005.png" /&gt; &lt;br /&gt;
白色格子表示格子是open的, 蓝色格子表示格子是open并且是&lt;em&gt;full&lt;/em&gt;的(i.e. 和顶部相连的), 左边图片里的状态是对的, 右边图片里底下部分的格子状态则不对: 如左下角的格子, 其实是没有和顶部联通的, 如果我们用两个虚拟节点的话, 由于底部虚拟节点和顶部虚拟节点相连, 所以和底部虚拟节点相连的左下角部分就被判断成了full的. &lt;/p&gt;
&lt;p&gt;这个问题一开始我以为可以很简单解决, 后来发现没那么容易... (注意题目还要求isFull()也要在常数时间给出结果).&lt;br /&gt;
一个不优雅的办法是, 建立两个UF, 一个用来判断percolation, 另一个UF里没有底部虚拟节点所以可以专门用来判断isFull(). &lt;/p&gt;
&lt;p&gt;这样解决的话使可以通过测试, 不过非常不好看, 另外一个UF的内存占用是8N^2(内部有size[]和id[]两个int数组), 比较大. &lt;/p&gt;
&lt;p&gt;在论坛上找了半天, 看了一些人的分享终于想到了这个非常妙的办法: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UF只建立顶部虚拟节点, 不建立底部虚拟节点. &lt;/li&gt;
&lt;li&gt;判断isFull只需要用UF的connected()一下就好了&lt;/li&gt;
&lt;li&gt;问题是怎么判断percolation: &lt;br /&gt;
    a. 建立一个数组 &lt;code&gt;boolean connectedToBottom[]&lt;/code&gt;, 指示某一点是否和底部相连 &lt;br /&gt;
    b. trick在这里: 不必修改一个联通分支的所有点的&lt;code&gt;connectedToBottom&lt;/code&gt;的值, &lt;strong&gt;只需要修改联通分支的root(UF的find)即可&lt;/strong&gt;. 在进行union的时候先查看两个component的root是不是连到底部, 然后有一个连到底部的话, 在union以后把合并后的联通分支的&lt;code&gt;connectedToBottom&lt;/code&gt;状态改为true即可 &lt;br /&gt;
    c. 然后判断percolate: 先找到顶部虚拟节点锁在component的root, 然后看这个root是否连到底部即可!   &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样用一个boolean数组(N^2内存)代替了一个新的UF(8N^2内存), 而且实现也更加优雅.  &lt;br /&gt;
非常有意思的练习...&lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Algorithms I] Week 1-2 Analysis of Algorithms</title><link href="http://x-wei.github.io/algoI_week1_2.html" rel="alternate"></link><updated>2015-07-02T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week1_2.html</id><summary type="html">&lt;h1&gt;1. Introduction&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_2/pasted_image.png" /&gt;&lt;/p&gt;
&lt;h1&gt;2. Observations&lt;/h1&gt;
&lt;p&gt;ex. &lt;strong&gt;3-SUM pb&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;given N distinct numbers, how many triples sum up to 0? (pb related to computatioal geogtry)&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brute force method:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;for(int i=0;i&amp;lt;N;i++)
    for(int j=i+1;j&amp;lt;N;j++)
        for(int k=j+1;k&amp;lt;N;k++)
            {if(a[i]+a[j]+a[k]==0)
                count++;
            }
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;mesuring running time:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;stdlib.jar里面提供了一个&lt;code&gt;Stopwatch&lt;/code&gt;类用于记录运行时间.  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;log-log plot&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;T(N) = running time for input of size N&lt;br /&gt;
log(N)-log(T(N)) plot:&lt;br /&gt;
often get a straight line — power law  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;doubling ratio&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(for checking the power law relationship, checking the power order)&lt;br /&gt;
each time double the size of input, then take log of the time ratio of 2 runs: log( T(2N)/T(N) )  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image003.png" /&gt;  &lt;/p&gt;
&lt;h1&gt;3.Mathematical Models&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;total running time: sum of cost*frequency of operations &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cost of some basic operations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;array allocation: c*N (because all array entries have to be set to 0/false/null)&lt;/li&gt;
&lt;li&gt;string concatenation: c*N (proportional to the length  of string !)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;simplification&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;crude analysis&lt;br /&gt;
ignore lower terms &lt;strong&gt;tilde notation&lt;/strong&gt;  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image005.png" /&gt;  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;estimating discrete sum by relaxation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Replace the sum with an integral, and use calculus — 很机智...   &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image006.png" /&gt;&lt;/p&gt;
&lt;h1&gt;4. Order of Growth Classification&lt;/h1&gt;
&lt;p&gt;(discard the leading coefficient when considering the growth order)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;only a small set of growth functions: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;1, logN, N, NlogN, N^2, N^3, 2^N&lt;/code&gt; &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image007.png" /&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exemples:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;binary search ⇒ logN&lt;br /&gt;
divide and conquer ⇒ NlogN&lt;br /&gt;
exhaustive search ⇒ 2^N &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image008.png" /&gt;&lt;/p&gt;
&lt;p&gt;practical performance: &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image009.png" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ex. &lt;strong&gt;binary search&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;public int binearch(int arr[], int key){//arr[] already sorted
    int lo=0,hi=arr.length;
    while(i&amp;lt;j){
        int m = (lo+hi)/2;
        if(arr[m]==key) return m;
        else if(arr[m]&amp;lt;key) lo=m+1;
        else hi=m-1;
    }
    return -1;
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(→ Bug in Java's Arrays.binarySearch() discovered in 2006......) &lt;br /&gt;
→ invariant: if key in arr, arr[lo]&amp;lt;=key&amp;lt;=arr[hi] &lt;br /&gt;
&lt;strong&gt;proposition. &lt;/strong&gt;binary search uses at most logN+1 compares to search a sorted array of size N.
&lt;strong&gt;pf. &lt;/strong&gt;
denote &lt;em&gt;T(N)&lt;/em&gt; := nb of compares for array with size &amp;lt;=N&lt;br /&gt;
→ T(1)=1&lt;br /&gt;
→ recurrence relation: T(N)&amp;lt;=T(N/2)+1&lt;br /&gt;
⇒ T(N)=logN  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;a faster 3-SUM&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ first sort the array &lt;em&gt;(~NlogN)&lt;/em&gt;&lt;br /&gt;
→ for any pair a[i] and a[j], do binary search for -(a[i]+a[j])   &lt;em&gt;~(N2LogN)&lt;/em&gt;&lt;br /&gt;
⇒ reduce from N3 to N2logN ! (for 8k numbers, running time goes from 51s to 0.96s)  &lt;/p&gt;
&lt;h1&gt;5. Theory of Algorithms&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;types of analysis&lt;/p&gt;
&lt;p&gt;-best case
-worst case
-average case(random input, "expected cost")&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;notations&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;big Theta/big O/big Omega&lt;/strong&gt;  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image010.png" /&gt;   &lt;br /&gt;
    - big O: &lt;em&gt;upper bound  → * once a specific algo is found, find an upper bound&lt;br /&gt;
    - big Omega: &lt;/em&gt;lower bound   &lt;em&gt;→ proove that no algo can do better&lt;br /&gt;
    - big Theta: symptotic growth (same order, optimal algo)  → lower and upper bound &lt;/em&gt;match* &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image011.png" /&gt;   &lt;br /&gt;
⇒ in this course: use tilde notation: contain leading constants for highest order term&lt;/p&gt;
&lt;h1&gt;6. Memory&lt;/h1&gt;
&lt;p&gt;KB: 2^10 bytes&lt;br /&gt;
MB: 2^20 bytes (1 million) 
GB: 2^30 bytes (1 billion) 
64-bit machines: &lt;em&gt;8 byte pointers&lt;/em&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;typical memory usage:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;for primary types: &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image012.png" /&gt;&lt;br /&gt;
for arrays  (with &lt;em&gt;array overhead=24bytes&lt;/em&gt;) :  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image013.png" /&gt; &lt;br /&gt;
&lt;em&gt;Obj overhead: 16 bytes&lt;/em&gt; (obj的大小=16+obj内部filed的大小)&lt;br /&gt;
&lt;em&gt;references&lt;/em&gt;: 8 bytes (ex. inner class has a ref to encolsing class)&lt;br /&gt;
&lt;em&gt;padding&lt;/em&gt;: each obj uses a multiply of 8 bytes (obj大小=8 bytes的整数倍)    &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image014.png" /&gt;   &lt;br /&gt;
&lt;img alt="" src="algoI_week1_2/pasted_image015.png" /&gt;     &lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>[Spark MOOC note] lab4. Predicting Movie Ratings</title><link href="http://x-wei.github.io/sparkmooc_notelab4.html" rel="alternate"></link><updated>2015-06-30T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/sparkmooc_notelab4.html</id><summary type="html">&lt;h1&gt;Part 0: Preliminaries&lt;/h1&gt;
&lt;p&gt;Each line in the ratings dataset (&lt;em&gt;ratings.dat.gz&lt;/em&gt;) is formatted as: &lt;br /&gt;
&lt;code&gt;UserID::MovieID::Rating::Timestamp&lt;/code&gt; ⇒ tuples of &lt;code&gt;(UserID, MovieID, Rating)&lt;/code&gt;in &lt;em&gt;ratingsRDD&lt;/em&gt; &lt;br /&gt;
Each line in the movies (&lt;em&gt;movies.dat&lt;/em&gt;) dataset is formatted as: &lt;br /&gt;
&lt;code&gt;MovieID::Title::Genres&lt;/code&gt; ⇒ tuples of &lt;code&gt;(MovieID, Title)&lt;/code&gt; in &lt;em&gt;ratingsRDD&lt;/em&gt;    &lt;/p&gt;
&lt;p&gt;487650 ratings and 3883 movies&lt;/p&gt;
&lt;p&gt;⇒ Since the key is an integer and the value is a unicode string, we can use a function to combine them into a single unicode string (e.g., &lt;code&gt;unicode('%.3f' % key) + ' ' + value&lt;/code&gt;) before sorting the RDD using &lt;code&gt;sortBy()&lt;/code&gt;.&lt;/p&gt;
&lt;h1&gt;Part 1: Basic Recommendations&lt;/h1&gt;
&lt;p&gt;naive method: &lt;em&gt;always recommend the movies with the highest average rating...&lt;/em&gt;
⇒ 20 movies with the highest average rating and more than 500 reviews&lt;/p&gt;
&lt;p&gt;&lt;em&gt;movieNameWithAvgRatingsRDD&lt;/em&gt;: &lt;code&gt;(avgRating, Title, nbRatings)&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;Part 2: Collaborative Filtering&lt;/h1&gt;
&lt;p&gt;MLlib: &lt;a href="https://spark.apache.org/mllib/"&gt;https://spark.apache.org/mllib/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Collaborative filtering&lt;/em&gt; is a method of making automatic predictions (filtering) about the interests of a user by collecting preferences or taste information from many users (collaborating). The underlying assumption of the collaborative filtering approach is that if a person A has the same opinion as a person B on an issue, A is more likely to have B's opinion on a different issue x than to have the opinion on x of a person chosen randomly. &lt;/p&gt;
&lt;p&gt;一图胜千言: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lab4/Collaborative_filtering.gif" /&gt;&lt;/p&gt;
&lt;h3&gt;Matrix Factorization&lt;/h3&gt;
&lt;p&gt;CF问题实际上是矩阵分解的问题: 
We have a matrix whose entries are movie ratings by users (shown in red in the diagram below). Each column represents a user (shown in green) and each row represents a particular movie (shown in blue).&lt;/p&gt;
&lt;p&gt;其中&lt;em&gt;rating矩阵&lt;/em&gt;(用户/电影矩阵)只有一些项的值存在(即用户打分的那些项), 所以要用分解后的两个矩阵之乘积来估计rating矩阵中的缺失项.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;With collaborative filtering, the idea is to approximate the ratings matrix by factorizing it as the product of two matrices: one that describes properties of each user (shown in green), and one that describes properties of each movie (shown in blue).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lab4/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;p&gt;若N个用户, M个电影 ⇒ 把rating矩阵(N&lt;em&gt;M)分解为 一个N&lt;/em&gt;d矩阵(&lt;em&gt;user矩阵&lt;/em&gt;)与一个d&lt;em&gt;M(&lt;/em&gt;movie矩阵*)矩阵之积. &lt;/p&gt;
&lt;p&gt;其中d个维度可以有(隐含的)意义: 比如f[j]第一个维度代表了电影j中动作片的成分, f[i]的第一个维度表示用户i对动作片的喜爱程度, 以此类推... 所以f[i]与f[j]的内积就可以是用户i对电影j的评分的一个不错的预测. &lt;/p&gt;
&lt;p&gt;假设&lt;em&gt;f[j]已知&lt;/em&gt;, 那么f[i]要满足: 对那些用户i已经打过分的电影(即r_ij存在)上的估计偏差最小:   &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lab4/pasted_image.png" /&gt;    &lt;br /&gt;
(后面加上的那一项是正则项: 不希望f[i]的模过大)&lt;/p&gt;
&lt;p&gt;不过前面的假设, "f[j]已知"这个条件其实并不成立 ⇒ &lt;strong&gt;Alternating Least Squares algorithm&lt;/strong&gt;: 交替优化f[i]和f[j]的取值, 每次固定一个, 而优化另一个, 交替进行, 直到收敛(好像Kmeans也是利用的这种方法). &lt;/p&gt;
&lt;p&gt;&lt;em&gt;first randomly filling the users matrix with values and then optimizing the value of the movies such that the error is minimized. Then, it holds the movies matrix constrant and optimizes the value of the user's matrix.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;train-test-validation split&lt;/h3&gt;
&lt;p&gt;⇒ break up the ratingsRDD dataset into three pieces:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A training set (RDD), which we will use to train models&lt;/li&gt;
&lt;li&gt;A validation set (RDD), which we will use to choose the best model&lt;/li&gt;
&lt;li&gt;A test set (RDD), which we will use for our experiments&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;trainingRDD, validationRDD, testRDD = ratingsRDD.randomSplit([6, 2, 2], seed=0L)&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Root Mean Square Error (RMSE)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lab4/pasted_image003.png" /&gt;  &lt;br /&gt;
compute the sum of squared error given predictedRDD and actualRDD RDDs. 
Both RDDs consist of tuples of the form (UserID, MovieID, Rating)&lt;/p&gt;
&lt;h3&gt;alternating least square of MLllib&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://spark.apache.org/docs/latest/api/python/pyspark.mllib.html#pyspark.mllib.recommendation.ALS"&gt;https://spark.apache.org/docs/latest/api/python/pyspark.mllib.html#pyspark.mllib.recommendation.ALS&lt;/a&gt;
ALS takes a training dataset (RDD) and several parameters that control the model creation process.&lt;/p&gt;
&lt;p&gt;The most important parameter to ALS.train() is the &lt;em&gt;rank&lt;/em&gt;, which is the number of rows in the Users matrix (green in the diagram above) or the number of columns in the Movies matrix (blue in the diagram above). (In general, a lower rank will mean higher error on the training dataset, but a high rank may lead to overfitting.)&lt;/p&gt;
&lt;p&gt;貌似ALS接受一个(userid, itemid, rating)的RDD作为输入, 预测时接受一个(userid, itemid)的RDD作为输入, 返回一个(userid, itemid, rating)的RDD.  (也就是说, 前面的notation在这里继续被使用了).&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;model = ALS.train(trainingRDD, rank, seed=seed, iterations=iterations,
                      lambda_=regularizationParameter)
predictedRatingsRDD = model.predictAll(validationForPredictRDD)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以在这里查看job详情: &lt;a href="http://localhost:4040/jobs/"&gt;http://localhost:4040/jobs/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;compare model&lt;/h3&gt;
&lt;p&gt;Looking at the RMSE for the results predicted by the model versus the values in the test set is one way to evalute the quality of our model. &lt;em&gt;Another way to evaluate the model is to evaluate the error from a test set where every rating is the average rating for the training set.&lt;/em&gt;
⇒ 这里没有太理解, 难道是说test set 的平均rating预测结果和training set的平均rating应该比较接近么?? 
⇒ 终于明白了: "&lt;em&gt;Your model more accurately predicts the ratings than using just the average rating, as the model's RMSE is significantly lower than the RMSE when using the average rating.&lt;/em&gt;"&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求一个tuple rdd最后一列的和的时候, 需要先map成最后一列再reduce: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;trainingRDD.map(lambda x:x[-1]).reduce(lambda x,y:x+y)&lt;/code&gt;&lt;br /&gt;
直接写&lt;code&gt;reduce(lambda x,y:x[-1]+y[-1])&lt;/code&gt;貌似是不行的&lt;/p&gt;</summary><category term="spark"></category></entry><entry><title>[Algorithms I] Week 1-1 Union-Find</title><link href="http://x-wei.github.io/algoI_week1_1.html" rel="alternate"></link><updated>2015-06-27T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/algoI_week1_1.html</id><summary type="html">&lt;h1&gt;1. Dynamic Connectivity pb&lt;/h1&gt;
&lt;h3&gt;pb statement&lt;/h3&gt;
&lt;p&gt;a set of N obj, &lt;em&gt;indexed by 0,1,...,N-1&lt;/em&gt;
⇒ 
&lt;em&gt; UNION: connect objects &lt;code&gt;void union(int p, int q)&lt;/code&gt;
&lt;/em&gt; FIND: is there a path connecting 2 obj?  &lt;code&gt;boolean connected(int p, int q)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ex: &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;connect components&lt;/strong&gt;(联通分支): max set of obj that are mutually connected. &lt;/p&gt;
&lt;h3&gt;UF API&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;union(p,q): connect 2 obj&lt;/li&gt;
&lt;li&gt;connected(p,q): test if p and q are connected &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;find(p)&lt;/strong&gt;: find the &lt;em&gt;component id&lt;/em&gt; of p&lt;/li&gt;
&lt;li&gt;count(): nb of components&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意:
命名不是很好, 这里的&lt;code&gt;find()&lt;/code&gt;函数不对应FIND query, &lt;code&gt;connected()&lt;/code&gt;函数才是真正的FIND query, find()函数是为了connected()函数而做的一个辅助函数(find(p): return the root of the node p )
在connected里就可以调用find: &lt;code&gt;return find(p)==find(q)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;应该是interface更好一些... &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public interface UF{
void union(int p, int q);
boolean connected(int p, int q);
//int find(int p);
//int count();
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;测试client: &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;h1&gt;2. Quick Find&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;"eager approach"&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;data structure&lt;/h3&gt;
&lt;p&gt;⇒ an int array &lt;code&gt;id[]&lt;/code&gt;
initialized to &lt;em&gt;id[p]=p for all p&lt;/em&gt;
interpretation: &lt;em&gt;id[p] = &lt;strong&gt;&lt;em&gt;component id of obj p&lt;/em&gt;&lt;/strong&gt;
⇒ p and q are connected &lt;/em&gt;iff* id[p]==id[q] (ie. find very fast)
没有用find()函数  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image002.png" /&gt;  &lt;/p&gt;
&lt;h3&gt;UF operations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;FIND:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;connected(p,q):&lt;/code&gt; very fast, just check id[p] and id[q]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UNION:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;when merging 2 components :
&lt;code&gt;union(p,q)&lt;/code&gt;: &lt;code&gt;id[p]=id[q]&lt;/code&gt;(总是让第一个参数p的id变为第二个参数q的id), &lt;br /&gt;
⇒ then have to modify &lt;em&gt;all entries&lt;/em&gt; with id equal to &lt;code&gt;id[p]&lt;/code&gt; !&lt;br /&gt;
⇒ too many entries to change  &lt;/p&gt;
&lt;h3&gt;implementation&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;(class  QuickFindUF implements UF)&lt;/em&gt;&lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;p&gt;complexity: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FIND: cte&lt;/li&gt;
&lt;li&gt;UNION: lin...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;if N obj + N unions ⇒ &lt;em&gt;quad time !&lt;/em&gt;&lt;br /&gt;
btw, 程序运行速度: &lt;strong&gt;~10^9/s&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;3. Quick Union&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;"lazy approach"&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;data structure&lt;/h3&gt;
&lt;p&gt;⇒ also an int array &lt;code&gt;id[]&lt;/code&gt;
considering a set of &lt;em&gt;trees, &lt;/em&gt;此时每个联通分支都是一个tree&lt;br /&gt;
interpretation: &lt;em&gt;id[p] = &lt;em&gt;&lt;strong&gt;parent index of obj p &lt;/strong&gt;(觉得这个数组叫做father更好....)&lt;br /&gt;
⇒ p is a root node &lt;/em&gt;iff&lt;/em&gt; id[p]==p&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image005.png" /&gt;&lt;/p&gt;
&lt;h3&gt;UF operations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;FIND:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;connected(p,q):&lt;/code&gt;check if &lt;em&gt;root of p == root of q&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UNION: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;union(p,q):&lt;/code&gt;just set p's root to be &lt;em&gt;child&lt;/em&gt; of q's root (把第一个参数p的那棵树放入第二个参数q的树的根节点作为子树)&lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image006.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;root():&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前两个的操作都需要一个函数查找一个节点的root,  需要写一个函数实现, 也很简单, 一路找parent即可:   &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private int root(int p){
    while (p!=id[p]) p=id[p];
    return p;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;implementation&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image007.png" /&gt;&lt;/p&gt;
&lt;h3&gt;complexity&lt;/h3&gt;
&lt;p&gt;in the worst case (all elements is in a list form), root() is ~N, so:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FIND: lin&lt;/li&gt;
&lt;li&gt;UNION: lin&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;quick find和quick union的问题: &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image009.png" /&gt;&lt;/p&gt;
&lt;h1&gt;4. Quick Union Improvements&lt;/h1&gt;
&lt;h2&gt;improvement1: weighting&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;keep track of tree size&lt;/em&gt; ⇒ balance by taking the small tree be a child of the large tree  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image010.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image011.png" /&gt;&lt;/p&gt;
&lt;p&gt;⇒ add an extra array: &lt;code&gt;sz[]&lt;/code&gt; sz[i] is the size of the tree with root i&lt;/p&gt;
&lt;h3&gt;implementation&lt;/h3&gt;
&lt;p&gt;(数组&lt;code&gt;int  sz[]&lt;/code&gt; 初始全部为1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;依然需要&lt;code&gt;root()&lt;/code&gt;函数.&lt;/p&gt;
&lt;p&gt;private int root(int p){
    while(p!=id[p]) p=id[p];
    return p;
}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIND &lt;/p&gt;
&lt;p&gt;public boolean connected(int p, int q){
    return root(p)==root(q);
}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UNION&lt;/p&gt;
&lt;p&gt;public void  union(int p, int q){
    int rp = root(p), rq=root(q);
    if(rp==rq) return; // 
    if (sz[rp]&amp;lt;sz[rq]){
        id[rp]=rq;
        sz[rq]+=sz[rp];
    }
    else{...}
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;complexity&lt;/h3&gt;
&lt;p&gt;FIND: proportional to &lt;em&gt;depth of p and&lt;/em&gt; q in their tree
UNION: const if p and q are root&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;proposition&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;the max depth of weightedQuickUnion is &lt;strong&gt;lgN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[pf] considering a node &lt;code&gt;x&lt;/code&gt;, in tree &lt;code&gt;T1&lt;/code&gt;, &lt;code&gt;dep(x)&lt;/code&gt; is x's depth in its tree.  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image012.png" /&gt; &lt;br /&gt;
→   &lt;code&gt;dep(x)&lt;/code&gt; will increase by 1, iff &lt;code&gt;T1&lt;/code&gt; is merged into another tree &lt;code&gt;T2&lt;/code&gt; (and by the algo, shoud have |T1|&amp;lt;=|T2| )&lt;br /&gt;
→   x's tree's size become |T1|+|T2| &amp;gt;= 2&lt;em&gt;|T1| 
⇒   everytime dep(x) increased by 1, x's tree's size will &lt;/em&gt;at least double*&lt;br /&gt;
at first dep(x)=1, if dep(x) increases lgN times, the size of the tree will be &amp;gt;=  N &lt;br /&gt;
CQFD.&lt;/p&gt;
&lt;p&gt;so the &lt;code&gt;root()&lt;/code&gt; function takes only lgN time. 
&lt;strong&gt;conclusion&lt;/strong&gt;: both UNION and FIND will be in &lt;strong&gt;lgN &lt;/strong&gt;time. &lt;/p&gt;
&lt;h2&gt;improvement 2: path compression&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;imporve the root() function: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;when looking for root of a node ⇒ link &lt;em&gt;all nodes in the path &lt;/em&gt;up to the root. &lt;br /&gt;
⇒ just a constant extra time compared to old implementation. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2 pass implementation: &lt;/p&gt;
&lt;p&gt;private int root(int p){
    int r = p;
    while(r!=id[r]) r=id[r];
    while(p!=r){
        int t = p;
        p=id[p];
        id[t]=r;
    }
    return r;
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;flatens the tree greatly. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;single pass implementation: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;just make all other node &lt;em&gt;point to its grandparent&lt;/em&gt; (halving the path length)
⇒ not as flatening as before, but in practice will almost be the same. 
just one extra line of code: 
    private int root(int p){
        while(p!=id[p]){ 
            id[p] = id[ id[p] ];
            p=id[p];  &lt;br /&gt;
        }
        return p;
    }&lt;/p&gt;
&lt;h3&gt;complexity&lt;/h3&gt;
&lt;p&gt;(for weighet quick union with path compression — &lt;em&gt;WQUPC&lt;/em&gt;)&lt;br /&gt;
very very small: &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image013.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lg*()&lt;/strong&gt; function: "&lt;em&gt;iterated log function&lt;/em&gt;", lg&lt;em&gt;(N) = the number of time to take log to get to 1
lg&lt;/em&gt;()几乎可以看成常数了:  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image014.png" /&gt; &lt;br /&gt;
ex. &lt;em&gt;lg&lt;/em&gt;(65536) = 4* (x^16=65536)&lt;br /&gt;
because: lg(65536)=16 ; lg(16) = 4; lg(4)=2; lg(2)=1. &lt;br /&gt;
&lt;strong&gt;⇒ N obj, M unions will take (almost) linear time&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image015.png" /&gt; &lt;br /&gt;
(有人证明了不存在&lt;em&gt;理论上&lt;/em&gt;linear的算法. )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;conclusion&lt;/strong&gt;: both UNION and FIND will be in &lt;strong&gt;constant time&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;summery&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image017.png" /&gt; &lt;br /&gt;
上面这个表格好像quick union的部分有问题? 最坏情况下应该是N+MN吧??&lt;br /&gt;
书上是这么写的:  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image016.png" /&gt;&lt;/p&gt;
&lt;p&gt;WQUCF reduce 30 years to 6 seconds. &lt;/p&gt;
&lt;h1&gt;5. Union Find Application&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image018.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;percolation&lt;/li&gt;
&lt;li&gt;dynamic connectivity&lt;/li&gt;
&lt;li&gt;Kruskal MST algo&lt;/li&gt;
&lt;li&gt;Games (GO)&lt;/li&gt;
&lt;li&gt;.......&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;percolation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;model: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;N&lt;em&gt;N grid of sites&lt;br /&gt;
⇒ each site is open with proba=&lt;/em&gt;p*&lt;br /&gt;
⇒ sys &lt;strong&gt;percolate&lt;/strong&gt; iff bottom and top are connected by open sites.  &lt;br /&gt;
&lt;img alt="" src="algoI_week1_1/pasted_image019.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;question: the &lt;em&gt;percolation probability&lt;/em&gt; as a function of &lt;em&gt;p &lt;/em&gt;(&lt;strong&gt;phase transition&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image020.png" /&gt; &lt;br /&gt;
nobody knows how to get the threshold mathematically&lt;br /&gt;
⇒ run &lt;em&gt;simulations&lt;/em&gt; to find out the phase transition &lt;em&gt;threshold&lt;/em&gt;.   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Monte Carlo simulation   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ all sites initilized to be &lt;em&gt;closed&lt;/em&gt;&lt;br /&gt;
→ randomly open sites &lt;em&gt;one by one&lt;/em&gt; &lt;br /&gt;
→ when the sys percolates, the &lt;em&gt;vacancy percentage&lt;/em&gt; is an estimate of &lt;em&gt;p&lt;/em&gt; &lt;br /&gt;
*(run above simulation for millions of times)   &lt;/p&gt;
&lt;h3&gt;implementation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;N^2 sites, named 0 to N^2-1  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image022.png" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add 2 more vertual sites: one on top, one on bottom   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="algoI_week1_1/pasted_image021.png" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;openning a site: union to adjcent open sites (at most 4 unions)&lt;/li&gt;
&lt;/ul&gt;</summary><category term="algorithm"></category></entry><entry><title>[Spark MOOC note] Lec8. Exploratory Data Analysis and Machine Learning</title><link href="http://x-wei.github.io/sparkmooc_note_lec8.html" rel="alternate"></link><updated>2015-06-23T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/sparkmooc_note_lec8.html</id><summary type="html">&lt;h2&gt;STATISTICS, BUSINESS QUESTIONS, AND LEARNING TECHNIQUES&lt;/h2&gt;
&lt;p&gt;2 different kinds of statistics: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;descriptive statistics&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex. median — describes data, &lt;em&gt;but cannot generalize beyong that&lt;/em&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inferential statistics&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex. &lt;em&gt;t-testing — inferences beyond the data&lt;/em&gt;
techniques leveraged for machine learning and prediction&lt;/p&gt;
&lt;p&gt;supervised learning (clf, reg), unsupervised learning (clustering, dim-reduction)
 → UL often used in a larger SL pb (ex. &lt;em&gt;auto-encoder&lt;/em&gt;)&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec8/pasted_image.png" /&gt;&lt;/p&gt;
&lt;h2&gt;EXPLORATORY DATA ANALYSIS&lt;/h2&gt;
&lt;p&gt;5-number summary:&lt;/p&gt;
&lt;p&gt;The five-number summary is a descriptive statistic that provides information about a set of observations. It consists of the five most important sample percentiles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The sample minimum (smallest observation)&lt;/li&gt;
&lt;li&gt;The lower quartile or first quartile&lt;/li&gt;
&lt;li&gt;The median (middle value)&lt;/li&gt;
&lt;li&gt;The upper quartile or third quartile&lt;/li&gt;
&lt;li&gt;The sample maximum (largest observation)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec8/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;→ box plot: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec8/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;h2&gt;THE R LANGUAGE AND NORMAL DISTRIBUTIONS&lt;/h2&gt;
&lt;p&gt;R: intractive exploration and visulization of data + statistical models and distributions + CRAN&lt;/p&gt;
&lt;p&gt;Central Limit Th: sum/mean of n iid random variables 
many statistical test assume data to be normally distributed&lt;/p&gt;
&lt;h2&gt;DISTRIBUTIONS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;poissons distribution: accurrence freq&lt;/li&gt;
&lt;li&gt;exponential distribution: interval between 2 (poissons) events&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Zipf/Pareto/Yule distributions&lt;/em&gt;: frequencies of different terms in a document, or web site visits&lt;/li&gt;
&lt;li&gt;binomial/multinomial distribution: nb of count of events&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;RHINE PARADOX&lt;/h2&gt;
&lt;h2&gt;SPARK'S MACHINE LEARNING TOOLKIT&lt;/h2&gt;
&lt;p&gt;mllib: scalable, distributed ML library, &lt;em&gt;sklearn-like&lt;/em&gt; ML toolkit
&lt;a href="https://spark.apache.org/docs/latest/mllib-guide.html"&gt;https://spark.apache.org/docs/latest/mllib-guide.html&lt;/a&gt;
lab: &lt;em&gt;collaborative filtering — &lt;/em&gt;matrix factorisation&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec8/pasted_image005.png" /&gt;&lt;br /&gt;
⇒ &lt;em&gt;alternating&lt;/em&gt; least square(ALS):  &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec8/pasted_image006.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;trouble with summary stats&lt;/strong&gt;: &lt;em&gt;Anscombe's Quartet&lt;/em&gt;
→ have same statistics property&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec8/pasted_image002.png" /&gt;&lt;br /&gt;
→ quite different in fact: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec8/pasted_image003.png" /&gt;&lt;br /&gt;
&lt;strong&gt;Takeaways&lt;/strong&gt;:&lt;br /&gt;
&lt;em&gt;•  Important to look at data graphically before analyzing it   &lt;/em&gt;
&lt;em&gt;•  Basic statistics properties often fail to capture real-world complexities&lt;/em&gt;  &lt;/p&gt;
&lt;h2&gt;Lab3. Text Analysis and Entity Resolution&lt;/h2&gt;
&lt;p&gt;Entity Resolution (ER) refers to the task of finding records in a data set that refer to the same entity across different data sources (e.g., data files, books, websites, databases). ER is necessary when joining data sets based on entities that may or may not share a common identifier (e.g., database key, URI, National identification number), as may be the case due to differences in record shape, storage location, and/or curator style or preference. A data set that has undergone ER may be referred to as being cross-linked.&lt;/p&gt;
&lt;p&gt;The file format of an Amazon line is:
"id","title","description","manufacturer","price"
The file format of a Google line is:
"id","name","description","manufacturer","price"&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;re.split&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;re.split()有个很讨厌的地方: 字符串以句号等结尾时, 最后总是会出现一个空字符串:
    &amp;gt;&amp;gt;&amp;gt; re.split('\W+', 'Words, words, words.')
    ['Words', 'words', 'words', '']
解决办法就是用个filter:　
&lt;code&gt;filter(None,re.split(split_regex, string.lower()) )&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tfidf&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TF rewards tokens that appear many times in the same document. It is computed as the frequency of a token in a document. IDF rewards tokens that are rare overall in a dataset. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cosine similarity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The metric of string distance we will use is called cosine similarity. We will treat each document as a vector in some high dimensional space. Then, to compare two documents we compute the cosine of the angle between their two document vectors. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;flatMap&lt;/code&gt;: 一行变多行, 别忘了...&lt;/li&gt;
&lt;li&gt;broadcast variable&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;we define the broadcast variable in the driver and then we can refer to it in each worker. Spark saves the broadcast variable at each worker, so it is only sent once.
声明广播变量的办法也很简单, 只要:
 &lt;code&gt;idfsSmallBroadcast = sc.broadcast(idfsSmallWeights)&lt;/code&gt;
然后用的时候要改成&lt;code&gt;xx.value&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EXCEPT语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;找了一下没发现spark有SQL的EXCEPT语句(就是和join相反), 于是只好这么写了:
    nonDupsRDD = (sims
                  .leftOuterJoin(goldStandard)
                 .filter(lambda x: x[1][1]==None)
                 .map(lambda x:(x[0],x[1][0])))
用leftouterjoin 然后再只保留为None的那些... 应该不是最佳写法吧...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;complexity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用的ER办法(cosine similarity)的复杂度是O2 太高了...
⇒ An &lt;strong&gt;inverted index&lt;/strong&gt; is a data structure that will allow us to avoid making quadratically many token comparisons. It maps each token in the dataset to &lt;em&gt;the list of documents that contain the token&lt;/em&gt;. So, instead of comparing, record by record, each token to every other token to see if they match, we will use inverted indices to &lt;em&gt;look up records(documents) that match on a particular token&lt;/em&gt;.
这种操作的基础是: 有很多向量的support是完全不重合的 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.&lt;code&gt;collectAsMap()&lt;/code&gt;: 把pair rdd变为map&lt;/li&gt;
&lt;li&gt;groupByKey(): 这个也用上了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;lab4前后做了四个小时 不过很有意思... 第五部分出现out of memory error就没办法了...&lt;/p&gt;</summary><category term="spark"></category></entry><entry><title>[Spark MOOC note] Lec7. Data Quality</title><link href="http://x-wei.github.io/sparkmooc_note_lec7.html" rel="alternate"></link><updated>2015-06-22T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/sparkmooc_note_lec7.html</id><summary type="html">&lt;h2&gt;DATA CLEANING&lt;/h2&gt;
&lt;p&gt;ex. 
deal with missing data, entity resolution, unit mismatch, ... &lt;/p&gt;
&lt;p&gt;deal with non-ideal samples ⇒ tradeoff between simplicity and accuracy. &lt;/p&gt;
&lt;h2&gt;DATA QUALITY PROBLEMS&lt;/h2&gt;
&lt;p&gt;data quality problems: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Conversions in complex pipelines can mess up data &lt;/li&gt;
&lt;li&gt;Combining multiple datasets can result in errrors&lt;/li&gt;
&lt;li&gt;Data degrades in accuracy or loses value over time&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还提供了一些工具帮助cleaning data: &lt;a href="http://vis.stanford.edu/wrangler/"&gt;http://vis.stanford.edu/wrangler/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;EXAMPLE: AGES OF STUDENTS IN THIS COURSE&lt;/h2&gt;
&lt;p&gt;(students' ages are self-reported...)&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec7/pasted_image.png" /&gt;&lt;/p&gt;
&lt;h2&gt;DATA CLEANING MAKES EVERYTHING OKAY?&lt;/h2&gt;
&lt;p&gt;ex. the appearance of a hole in the ozone layer. &lt;/p&gt;
&lt;h2&gt;DIRTY DATA PROBLEMS&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec7/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;Data Quality Continuum:&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec7/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;h2&gt;DATA GATHERING&lt;/h2&gt;
&lt;p&gt;solutions in the data gathering stage: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;re-emptive (先发制人) &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;integrity checks&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;retrospective&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;duplicate removal&lt;/p&gt;
&lt;h2&gt;DATA DELIVERY&lt;/h2&gt;
&lt;p&gt;solutions: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec7/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;h2&gt;DATA STORAGE&lt;/h2&gt;
&lt;p&gt;physical pb: storage is cheap → use data redundancy 
logical pb: poor metadata, etc&lt;/p&gt;
&lt;p&gt;⇒ solutions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;publish &lt;em&gt;data specifications&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;data mining tools&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;DATA RETRIEVAL&lt;/h2&gt;
&lt;p&gt;...总之就是各种方面都会引起data quality pb... &lt;/p&gt;
&lt;h2&gt;DATA QUALITY CONSTRAINTS&lt;/h2&gt;
&lt;p&gt;static constraints: 
ex. nulls not allowed, field domains&lt;/p&gt;
&lt;p&gt;data constraints follow a 80-20 rule: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec7/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Data quality metrics&lt;/strong&gt;: ...
ex. in lab2, examine log lines that are not correctly parsed.&lt;/p&gt;
&lt;h2&gt;TECHNICAL APPROACHES TO DATA QUALITY&lt;/h2&gt;
&lt;p&gt;ex. entity resolution in lab3&lt;/p&gt;
&lt;h2&gt;EXAMPLE: DEDUP/CLEANING&lt;/h2&gt;
&lt;p&gt;bing shopping被黑了
convert to &lt;em&gt;canonical form &lt;/em&gt;(ex. mailing address)&lt;/p&gt;</summary><category term="spark"></category></entry><entry><title>[Spark MOOC note] Lec6. Structured Data</title><link href="http://x-wei.github.io/sparkmooc_note_lec6.html" rel="alternate"></link><updated>2015-06-18T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/sparkmooc_note_lec6.html</id><summary type="html">&lt;h2&gt;RELATIONAL DATABASE&lt;/h2&gt;
&lt;p&gt;review: key data management concepts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data model &lt;/li&gt;
&lt;li&gt;schema&lt;/li&gt;
&lt;li&gt;&lt;em&gt;relational data model&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;structured data: have a specific schema to start with&lt;/p&gt;
&lt;p&gt;relationl database: a set of relations.
2 parts to a Relation: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;schema: name of relation, name and type of columns&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec6//pasted_image.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;instance: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;any data at given time 
(&lt;em&gt;cardinality&lt;/em&gt;:=nb of rows, &lt;em&gt;degree&lt;/em&gt;:=nb of fields)&lt;/p&gt;
&lt;h2&gt;LARGE DATABASES&lt;/h2&gt;
&lt;h2&gt;RELATIONAL DATABASE EXAMPLE AND DISCUSSION&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec6//pasted_image001.png" /&gt; &lt;br /&gt;
cardinality=3
degree=5&lt;/p&gt;
&lt;p&gt;advantages of Relational Databases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;well-def structure&lt;/li&gt;
&lt;li&gt;maintain indices for high performance&lt;/li&gt;
&lt;li&gt;consistancy maintained by transactions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;disadvantages: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;limited, rigid structure&lt;/li&gt;
&lt;li&gt;most disk space taken by large indices&lt;/li&gt;
&lt;li&gt;transactions are slow&lt;/li&gt;
&lt;li&gt;poor support for &lt;em&gt;sparse data&lt;/em&gt;(which is common)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;STRUCTURED QUERY LANGUAGE (SQL)&lt;/h2&gt;
&lt;p&gt;supported by &lt;strong&gt;DataFrame&lt;/strong&gt; of pyspark &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec6//pasted_image002.png" /&gt;&lt;/p&gt;
&lt;h2&gt;JOINS IN SQL&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec6//pasted_image003.png" /&gt;
cross join: carteian product&lt;/p&gt;
&lt;h2&gt;EXPLICIT SQL JOINS&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec6//pasted_image004.png" /&gt;
explicit version is preferred&lt;/p&gt;
&lt;h2&gt;TYPES OF SQL JOINS&lt;/h2&gt;
&lt;p&gt;⇒ controls how &lt;em&gt;unmatched&lt;/em&gt; keys are handled&lt;/p&gt;
&lt;p&gt;LEFT OUTER JOIN: 
keys appearring in left table but not in right table will be included with NULL as value&lt;/p&gt;
&lt;h2&gt;JOINS IN SPARK&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;for spark DataFrame: support inner/left outer/semi-join&lt;/li&gt;
&lt;li&gt;for &lt;em&gt;pair RDDs&lt;/em&gt;: support inner join(), leftOuterJoin(), fullOuterJoin()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;join ex:
&lt;img alt="" src="sparkmooc_note_lec6//pasted_image005.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec6//pasted_image006.png" /&gt;&lt;/p&gt;
&lt;p&gt;outerjoin ex:
&lt;img alt="" src="sparkmooc_note_lec6//pasted_image007.png" /&gt;&lt;/p&gt;
&lt;p&gt;fullouterjoin ex:
&lt;img alt="" src="sparkmooc_note_lec6//pasted_image008.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Lab 2 - Web Server Log Analysis with Apache Spark&lt;/h2&gt;
&lt;p&gt;Apache Common Log Format (CLF):&lt;br /&gt;
&lt;code&gt;127.0.0.1 - - [01/Aug/1995:00:00:01 -0400] "GET /images/launch-logo.gif HTTP/1.0" 200 1839&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Row(
host          = match.group(1),
client_identd = match.group(2),
user_id       = match.group(3),
date_time     = parse_apache_time(match.group(4)),
method        = match.group(5),
endpoint      = match.group(6),
protocol      = match.group(7),
response_code = int(match.group(8)),
content_size  = size 
)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;distinctByKey&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个pair RDD按照key来distinct不知道有没有distinctByKey之类的东西, 只好写成这样, 不知是不是对的: 
&lt;code&gt;dayHostCount = dayGroupedHosts.map(lambda group : (group[0], len(set(group[1])) ) )&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;...总体来说很有意思的一个lab...&lt;/p&gt;</summary><category term="spark"></category></entry><entry><title>[Spark MOOC note] Lec5. Semi-structured Data</title><link href="http://x-wei.github.io/sparkmooc_note_lec5.html" rel="alternate"></link><updated>2015-06-17T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/sparkmooc_note_lec5.html</id><summary type="html">&lt;h2&gt;KEY DATA MANAGEMENT CONCEPTS&lt;/h2&gt;
&lt;p&gt;data model: collection of concepts for describing data
schema: a description of a particular collection of data using a given data model&lt;/p&gt;
&lt;p&gt;structure spectrum: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image.png" /&gt;
semi-structured data: apply schema &lt;strong&gt;after&lt;/strong&gt; creating data. &lt;/p&gt;
&lt;h2&gt;FILES&lt;/h2&gt;
&lt;p&gt;files: named collection of bytes, in hierarchical namespace (but: In a Content-Addressable Storage system files are stored, arranged, and accessed based on their content or metadata, not in hierarchy)&lt;/p&gt;
&lt;h2&gt;SEMI-STRUCTURED TABULAR DATA&lt;/h2&gt;
&lt;p&gt;table: a collection of rows and columns, each row has an &lt;em&gt;index&lt;/em&gt;, each column has a &lt;em&gt;name&lt;/em&gt;. 
cell: by a pair (row, col), values can be missing, types are &lt;em&gt;inffered&lt;/em&gt; from content&lt;/p&gt;
&lt;p&gt;CSV:&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;p&gt;PDB:(filed name can be repeated on multuple lines)  &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image001.png" /&gt; &lt;/p&gt;
&lt;h2&gt;CHALLENGES WITH TABULAR DATA&lt;/h2&gt;
&lt;p&gt;challenges: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;p&gt;challenges for tabular data &lt;em&gt;from multiple source&lt;/em&gt;: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;p&gt;challenges for tabular data &lt;em&gt;from sensors&lt;/em&gt;: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image005.png" /&gt;&lt;/p&gt;
&lt;h2&gt;PANDAS AND SEMI-STRUCTURED DATA IN PYSPARK&lt;/h2&gt;
&lt;p&gt;pandas &lt;code&gt;DataFrame&lt;/code&gt;: represented as python dict (colname → series)
pandas &lt;code&gt;Series&lt;/code&gt;: 1D labeled array capable of holding any data type&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spark DataFrame&lt;/strong&gt;: &lt;em&gt;Distributed&lt;/em&gt; collection of data organized into named columns. 
types of columns are inferred from values. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="sparkmooc_note_lec5/pasted_image006.png" /&gt;&lt;/p&gt;
&lt;p&gt;Using dataframes can be 5 times faster than using RDDs: &lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image007.png" /&gt;&lt;/p&gt;
&lt;h2&gt;SEMI-STRUCTURED LOG FILES&lt;/h2&gt;
&lt;p&gt;ex. Apache web server log format&lt;/p&gt;
&lt;h2&gt;EXPLORING A WEB SERVER ACCESS LOG&lt;/h2&gt;
&lt;p&gt;NASA http server access log&lt;br /&gt;
&lt;a href="http://ita.ee.lbl.gov/html/contrib/NASA-HTTP.html"&gt;http://ita.ee.lbl.gov/html/contrib/NASA-HTTP.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;DATA MINING LOG FILES&lt;/h2&gt;
&lt;p&gt;Data mining log files is a data exploration process that often involves searching through the data for unusual events, a task that can be done using dashboards for visualizing anomalies. The data being analyzed usually includes machine resource usage data and application queue information.&lt;/p&gt;
&lt;h2&gt;FILE PERFORMANCE&lt;/h2&gt;
&lt;p&gt;binary/text performance benchmark:&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image008.png" /&gt;&lt;br /&gt;
⇒&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;read and write times are comparable &lt;/li&gt;
&lt;li&gt;binary files are mach faster than palin text files&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;compression performance benchmark:&lt;br /&gt;
&lt;img alt="" src="sparkmooc_note_lec5/pasted_image009.png" /&gt;&lt;br /&gt;
⇒ &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;write times are much larger than read times &lt;/li&gt;
&lt;li&gt;small range of compressed file size&lt;/li&gt;
&lt;li&gt;binary still much faster than text &lt;/li&gt;
&lt;li&gt;LZ4 compression ~= raw IO speed&lt;/li&gt;
&lt;/ul&gt;</summary><category term="spark"></category></entry><entry><title>[Spark MOOC note] Lec4. Spark Essentials</title><link href="http://x-wei.github.io/sparkmooc_note_lec4.html" rel="alternate"></link><updated>2015-06-16T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/sparkmooc_note_lec4.html</id><summary type="html">&lt;h2&gt;PYTHON SPARK (PYSPARK)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;a spark prog has 2 programs:&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dirver program: runs on driver machine&lt;/li&gt;
&lt;li&gt;worker program: runs on local threads or cluster nodes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;a spark prog first creates a &lt;strong&gt;SparkContext object:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tells how and where to access a cluster&lt;/li&gt;
&lt;li&gt;shell will automatically create &lt;strong&gt;the sc varible&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;in iPython: use constructor to create a &lt;code&gt;SparkContext&lt;/code&gt; obj&lt;/li&gt;
&lt;li&gt;⇒ use this SparkContext obj to create RDDs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Master:&lt;br /&gt;
The &lt;code&gt;master&lt;/code&gt; parameter (for a SparkContext) determines which type and size of cluster to use
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image.png" /&gt;&lt;/p&gt;
&lt;h2&gt;RDDs&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Resilient Distributed Dataset&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;immutable once created&lt;/li&gt;
&lt;li&gt;spark tracks linege information to compute lost data efficiently&lt;/li&gt;
&lt;li&gt;operations on collections of elements in parallel&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;to create RDDs&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;paralizing existing python collections&lt;/li&gt;
&lt;li&gt;transforming existing RDDs&lt;/li&gt;
&lt;li&gt;from files&lt;/li&gt;
&lt;li&gt;can specify the number of partitions for an RDD&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;p&gt;2 types of operations on RDD:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tranformation: lazy, &lt;em&gt;executed only one action runs on it&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;action&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Working with RDD:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create an RDD&lt;/li&gt;
&lt;li&gt;apply transformations to that RDD (ex. map, filter)&lt;/li&gt;
&lt;li&gt;apply actions on RDD (collect, count)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex code:  &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;data = [1,2,3,4]
rDD = sc.paralize(data, 4)
distFile = sc.textFile(&amp;quot;readme.txt&amp;quot;, 4) // elements are lines in the file
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;SPARK TRANSFORMATIONS&lt;/h2&gt;
&lt;p&gt;to create new dataset from existing one (lazy)&lt;/p&gt;
&lt;p&gt;examples of transformations: &lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;h2&gt;PYTHON LAMBDA FUNCTIONS&lt;/h2&gt;
&lt;p&gt;single expression&lt;/p&gt;
&lt;h2&gt;TRANSFORMATIONS&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;p&gt;⇒ spark truns the function litral into a cloture, balck code runs in driver, green code in workers&lt;/p&gt;
&lt;h2&gt;SPARK ACTIONS&lt;/h2&gt;
&lt;p&gt;cause spark to execute recipe to transform source. 
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image006.png" /&gt;&lt;/p&gt;
&lt;h2&gt;SPARK PROGRAMMING MODEL&lt;/h2&gt;
&lt;h2&gt;CACHING RDDS&lt;/h2&gt;
&lt;p&gt;to avoid having to reload data: &lt;code&gt;rdd.cache()&lt;/code&gt;⇒ read from memory instead of disk&lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image007.png" /&gt;&lt;/p&gt;
&lt;h2&gt;SPARK PROGRAM LIFECYCLE&lt;/h2&gt;
&lt;p&gt;create/paralise ⇒ transform ⇒ [cache] ⇒ action&lt;/p&gt;
&lt;h2&gt;SPARK KEY-VALUE RDDS&lt;/h2&gt;
&lt;p&gt;each element of a &lt;em&gt;pair RDD&lt;/em&gt; is a pair tuple&lt;/p&gt;
&lt;p&gt;key-value transformations: &lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image008.png" /&gt;&lt;/p&gt;
&lt;p&gt;ex:&lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image009.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image010.png" /&gt;&lt;/p&gt;
&lt;p&gt;careful using &lt;code&gt;groupByKey&lt;/code&gt;: create lots of data traffic and iterables at works&lt;/p&gt;
&lt;h2&gt;PYSPARK CLOSURES&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;one closure per worker is sent &lt;em&gt;with every task&lt;/em&gt; &lt;/li&gt;
&lt;li&gt;no communication between workers&lt;/li&gt;
&lt;li&gt;changes to global vars will not effect driver / other workers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⇒ pbs: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inefficient to send large data to each job&lt;/li&gt;
&lt;li&gt;one-way: driver → worker&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;pyspark shared vaiables&lt;/strong&gt;: 
2 types: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Broadcase variables&lt;/strong&gt;:&lt;ul&gt;
&lt;li&gt;send large, read-only variables to all workers&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Accumulators&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;aggregate values from worker to drivers &lt;/li&gt;
&lt;li&gt;only driver can access its value&lt;/li&gt;
&lt;li&gt;for workers the accumulators are write-only&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;SPARK BROADCAST VARIABLES&lt;/h2&gt;
&lt;p&gt;ex. give every worker a large dataset &lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image011.png" /&gt;&lt;/p&gt;
&lt;h2&gt;SPARK ACCUMULATORS&lt;/h2&gt;
&lt;p&gt;can only be "add" to by associative operation &lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image012.png" /&gt;&lt;/p&gt;
&lt;p&gt;careful to use accumulators in transformations: &lt;br /&gt;
&lt;img alt="" src="./sparkmooc_note_lec4/pasted_image013.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Lab1&lt;/h2&gt;
&lt;p&gt;VB更新以后虚拟机打不开了, 解决办法在: &lt;br /&gt;
&lt;a href="http://bbs.deepin.org/forum.php?mod=viewthread&amp;amp;tid=26001"&gt;http://bbs.deepin.org/forum.php?mod=viewthread&amp;amp;tid=26001&lt;/a&gt;&lt;/p&gt;</summary><category term="spark"></category></entry><entry><title>Scrapy 上手笔记</title><link href="http://x-wei.github.io/Scrapy%20%E4%B8%8A%E6%89%8B%E7%AC%94%E8%AE%B0.html" rel="alternate"></link><updated>2015-04-19T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/Scrapy 上手笔记.html</id><summary type="html">&lt;p&gt;Scrapy是用来爬取数据的很流行的包, 这里小记一下. 以前几天做的&lt;a href="https://github.com/X-Wei/OneArticleCrawler"&gt;一个爬虫&lt;/a&gt;为例子, 这个爬虫把韩寒一个app的前九百多期的文章抓了下来. &lt;/p&gt;
&lt;h2&gt;I. installation&lt;/h2&gt;
&lt;p&gt;scrapy的安装参考: &lt;a href="http://scrapy-chs.readthedocs.org/zh_CN/latest/topics/ubuntu.html"&gt;http://scrapy-chs.readthedocs.org/zh_CN/latest/topics/ubuntu.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(直接pip安装的好像缺少什么包)&lt;/p&gt;
&lt;h2&gt;II. prerequisite&lt;/h2&gt;
&lt;h3&gt;XPath&lt;/h3&gt;
&lt;p&gt;需要学习scrapy首先需要会XPath, 这是一种方便与在html/xml文档里查找所需元素的语句. 这个还是很好学的, 其实只需要花一刻钟时间看看w3school的&lt;a href="http://www.w3school.com.cn/xpath/"&gt;教程&lt;/a&gt;, 就可以掌握够用的知识进行下一步了. &lt;/p&gt;
&lt;p&gt;这里总结一下我觉得会用到的语句(不全, 不过经常用到): &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;//book&lt;/code&gt;    选取所有名字叫做book的元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bookstore/book&lt;/code&gt; 选取bookstore的子元素中所有叫book的元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;//title[@lang='eng']&lt;/code&gt; 选取lang属性为"eng"的所有title元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;//titile/text()&lt;/code&gt; 选取title元素的文字内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;descendant-or-self::text()&lt;/code&gt;: 选取自己或者所有后代节点的文字内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外还有个在线测试XPath语句的网站, 可以用这个测试XPath语句: &lt;/p&gt;
&lt;p&gt;&lt;a href="http://xpath.online-toolz.com/tools/xpath-editor.php"&gt;http://xpath.online-toolz.com/tools/xpath-editor.php&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;审查元素&lt;/h3&gt;
&lt;p&gt;再一个就是要用chrome的"审查元素"功能, 用这个功能可以看到想查找的网页内容对应在html文件的位置, 甚至可以直接右键复制想要的元素的XPath......(不过有时候并不是最合理的, 所以刚才XPath也不是白学...)&lt;/p&gt;
&lt;h2&gt;III. scrapy shell&lt;/h2&gt;
&lt;p&gt;网上的教程一般是从一个&lt;a href="http://doc.scrapy.org/en/latest/intro/tutorial.html"&gt;tutorial&lt;/a&gt;开始的, 介绍了一个小项目, 但是我觉得从scrapy shell开始应该更合理, 有时候甚至没必要建立一个工程, 在这个shell里就可以抓到想要的数据. &lt;/p&gt;
&lt;p&gt;启动的办法很简单: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;scrapy&lt;/span&gt;&lt;span class="x"&gt; shell &amp;#39;url&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;code&gt;url&lt;/code&gt;就写想要爬取的一个网址. &lt;/p&gt;
&lt;p&gt;这个shell简单说来, 就是一个测试爬虫的交互环境, 除了&lt;em&gt;多了一些特殊变量和函数&lt;/em&gt;, 就是一个普通的(i)python shell. &lt;/p&gt;
&lt;p&gt;先说两个scrapy shell多出来的变量: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;response&lt;/code&gt;: 把启动的&lt;code&gt;url&lt;/code&gt;抓取后得到的&lt;code&gt;Response&lt;/code&gt;对象, 比如 &lt;code&gt;response.body&lt;/code&gt;就包含了抓取来的html内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sel&lt;/code&gt;: 用刚刚抓取的内容建立的一个&lt;code&gt;Selector&lt;/code&gt;对象, 简单理解, Selector对象可以让我们执行XPath语句提取想要的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经常的用法就是用&lt;code&gt;response&lt;/code&gt;对象查看爬取的情况(&lt;code&gt;response.status&lt;/code&gt;), 用&lt;code&gt;sel&lt;/code&gt;对象测试XPath的正确:
&lt;code&gt;sel.xpath("xpath_statement").extract()&lt;/code&gt; 会在获取的response.body里用xpath查找并提取内容. &lt;/p&gt;
&lt;p&gt;再说两个scrapy shell添加的函数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fetch(request_or_url)&lt;/code&gt;: 修改请求或者网址, 这样scrapy shell会从新用这个request/url抓取数据, 相应的sel和response等对象也会自动更新. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;view(response)&lt;/code&gt;: 在浏览器里查看刚刚抓取的内容.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里举个例子, 抓取一个的文章标题: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    $ scrapy shell &amp;#39;http://wufazhuce.com/one/vol.921#articulo&amp;#39;
    ......
    In [1]: response.status
    Out[1]: 200
    In [2]: sel.xpath(&amp;#39;//*[@id=&amp;quot;tab-articulo&amp;quot;]/div/h2/text()&amp;#39;).extract()
    &amp;lt;string&amp;gt;:1: ScrapyDeprecationWarning: &amp;quot;sel&amp;quot; shortcut is deprecated. Use &amp;quot;response.xpath()&amp;quot;, &amp;quot;response.css()&amp;quot; or &amp;quot;response.selector&amp;quot; instead
    Out[2]: [u&amp;#39;\n\t\t\t\t\t\t\u78b0\u4e0d\u5f97\u7684\u4eba\t\t\t  \t\t&amp;#39;]
    In [3]: print sel.xpath(&amp;#39;//*[@id=&amp;quot;tab-articulo&amp;quot;]/div/h2/text()&amp;#39;).extract()[0]

                            碰不得的人
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;scrapy shell的完整文档在: 
&lt;a href="http://doc.scrapy.org/en/latest/topics/shell.html"&gt;http://doc.scrapy.org/en/latest/topics/shell.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;IV. scrapy project&lt;/h2&gt;
&lt;p&gt;接下来说建立scrapy工程, 这个按照tutorial走就好了. 
建立工程: 
&lt;code&gt;scrapy startproject my_proj&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;会新建一个my_proj文件夹, 里面的结构是: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;tree 
.
└── my_proj
    ├── scrapy.cfg
    └── my_proj
        ├── __init__.py
        ├── items.py
        ├── pipelines.py
        ├── settings.py
        └── spiders
            └── __init__.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要修改的文件主要有两个: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;items.py&lt;/code&gt; 定义要抓取的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spiders/xxx.py&lt;/code&gt; 定义自己的爬虫&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1. 自定义爬虫&lt;/h3&gt;
&lt;p&gt;先定义爬虫, 在spiders文件夹里面, 新建一个python文件, 这里定义一个&lt;code&gt;scrapy.spider.Spider&lt;/code&gt;的子类: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;OneSpider&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scrapy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;spider&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Spider&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;one_spider&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;start_urls&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://wufazhuce.com/one/vol.&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;#articulo&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;924&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;title_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;//*[@id=&amp;quot;tab-articulo&amp;quot;]/div/h2/text()&amp;#39;&lt;/span&gt; 
        &lt;span class="n"&gt;title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xpath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;title_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extract&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里, Spider子类一定需要定义三个东西: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;：　 是爬虫的名字, 一会爬取的时候需要&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start_urls&lt;/code&gt;:　启动时进行爬取的url列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parse()&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;爬虫启动的时候会把每一个start_urls里的网址下载, 生成的&lt;code&gt;Response&lt;/code&gt;对象会传入这个&lt;code&gt;parse()&lt;/code&gt;方法, 这个方法负责解析返回的&lt;code&gt;Response&lt;/code&gt;对象, 提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象等...&lt;/p&gt;
&lt;h3&gt;2. 保存抓取的信息到item&lt;/h3&gt;
&lt;p&gt;刚才只是做到了抓取需要的信息, 还没有能够保存到文件里, 下面要将抓取的信息做成一个&lt;code&gt;Item&lt;/code&gt;保存.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先定义要保存的信息:&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;修改items.py文件, 里面定义一个&lt;code&gt;scrapy.Item&lt;/code&gt;的子类:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;OnearticleItem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scrapy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Item&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c"&gt;# define the fields for your item here like:&lt;/span&gt;
    &lt;span class="n"&gt;vol&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;scrapy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;scrapy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;author&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;scrapy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;scrapy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个文件很简单, 只是说明一下要抓取的信息, 他们都是&lt;code&gt;scrapy.Field()&lt;/code&gt;, 这个东西类似一个字典.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后在爬虫里保存item:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了保存抓取的内容, 在parse()方法里, 得到需要的数据以后, 新建一个&lt;code&gt;OnearticleItem&lt;/code&gt;, 把抓到的内容放进这个item里, 然后返回这个item即可. &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;nb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;\d+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;title_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;//*[@id=&amp;quot;tab-articulo&amp;quot;]/div/h2/text()&amp;#39;&lt;/span&gt; 
    &lt;span class="n"&gt;author_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;//*[@id=&amp;quot;tab-articulo&amp;quot;]/div/p/text()&amp;#39;&lt;/span&gt; 
    &lt;span class="n"&gt;content_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;//div[@class=&amp;quot;articulo-contenido&amp;quot;]/descendant-or-self::text()&amp;#39;&lt;/span&gt; 
    &lt;span class="n"&gt;title&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xpath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;title_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extract&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;author&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xpath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;author_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extract&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xpath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;content_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extract&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;   &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;nb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;author&lt;/span&gt;
    &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;OnearticleItem&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;vol&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nb&lt;/span&gt;
    &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;title&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;
    &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;author&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;author&lt;/span&gt;
    &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;content&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3. 运行爬虫&lt;/h3&gt;
&lt;p&gt;以上的文件修改好了以后, 只需&lt;em&gt;在命令行里&lt;/em&gt;启动爬虫即可, 这时候就用到了刚才定义的spider的&lt;code&gt;name&lt;/code&gt;属性:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$scrapy crawl one_spider -o one.csv&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大约几分钟功夫, 九百多篇文章就放到了one.csv文件里~&lt;/p&gt;</summary><category term="python"></category><category term="scrapy"></category></entry><entry><title>运筹的力量: 用线性规划解决Google 2014 HashCode问题</title><link href="http://x-wei.github.io/%E8%BF%90%E7%AD%B9%E7%9A%84%E5%8A%9B%E9%87%8F:%20%E7%94%A8%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3Google%202014%20HashCode%E9%97%AE%E9%A2%98.html" rel="alternate"></link><updated>2015-02-02T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/运筹的力量: 用线性规划解决Google 2014 HashCode问题.html</id><summary type="html">&lt;p&gt;INF580(programmation par contraintes) 大概是在X学到的最有用的一门课, 它让我能够用把运筹学(MAP557)里学到的东西和计算机结合起来: 用电脑的力量解决(大规模)运筹问题. &lt;/p&gt;
&lt;p&gt;这门课的projet是去年巴黎谷歌举行的一个比赛的题目: 最优化谷歌街景拍照小车的路线. 做这个projet的三周里, 我和Manu从一开始信心满满, 到中间一筹莫展, 再到后来柳暗花明, 以及最后乘胜追击终于在今晚得到了近乎完美的解答, 非常精彩, 这里特意一记.&lt;/p&gt;
&lt;h1&gt;问题描述&lt;/h1&gt;
&lt;p&gt;谷歌那次比赛的题目在这里(我们做的是Main Round的题目): &lt;a href="https://sites.google.com/site/hashcode2014/tasks"&gt;https://sites.google.com/site/hashcode2014/tasks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单来说, 就是已知巴黎的道路信息, 设法用八辆车(每辆车的行驶时间有限)从巴黎谷歌出发, 尽可能多的走遍巴黎的所有街道, 参赛者给出这些车的路线, 他们的分数就是这八辆车走过的街道的长度之和(重复走的街道不算分). &lt;/p&gt;
&lt;p&gt;去年四月份我们也参加了这个比赛, 不过当时纠结于如何设计每辆车的路线, 最后只是用了贪心算法, 再加上一点点的随机, 得到的结果并不好... 当时ENS的人包揽了前三名, 而且比赛后进一步把分数刷到了满分: 他们的路线可以把所有街道都跑遍. &lt;/p&gt;
&lt;p&gt;这学期学了INF580以后, 手里有了&lt;strong&gt;JaCoP&lt;/strong&gt;以及&lt;strong&gt;AMPL&lt;/strong&gt;等"重型武器", 我们经过一番努力也得到了满分, 而且用了几乎最少的时间. 代码放在了: &lt;a href="https://github.com/X-Wei/INF580_HashCode2014"&gt;https://github.com/X-Wei/INF580_HashCode2014&lt;/a&gt; (里面还有个pdf的报告, 比这篇博客里说的精炼).&lt;/p&gt;
&lt;h1&gt;I. 初步建模&lt;/h1&gt;
&lt;h2&gt;线性规划(LP)模型&lt;/h2&gt;
&lt;p&gt;站在一个更高的角度上考虑这个问题, 从一个线性规划的角度看, 给定一个图&lt;code&gt;G(V,E)&lt;/code&gt;, 目标是最大化走过的街道长度, 如果用对每条街道&lt;code&gt;e&lt;/code&gt;, 定义一个&lt;code&gt;x_e&lt;/code&gt;,: 当一条街被经过的时候使它为1, 否则为0, 那么目标函数就是一个x的线性组合(系数就是对应街道的长度). &lt;/p&gt;
&lt;p&gt;但是如果一条街被经过了大于一次, &lt;code&gt;x_e&lt;/code&gt;也只能是1, 所以再引入一个变量&lt;code&gt;y_e&lt;/code&gt;: 用来表示一条街被经过的&lt;strong&gt;次数&lt;/strong&gt;. 所以&lt;code&gt;x_e&lt;/code&gt;可以看成是&lt;code&gt;y_e&lt;/code&gt;的indicatrice函数: &lt;img alt="" src="./运筹的力量_用LP解决Google_2014_Hashcode/equation.png" /&gt;, 这一点可以通过增加线性约束: &lt;code&gt;x_e&amp;lt;=y_e&lt;/code&gt; 即可实现, 因为&lt;code&gt;x_e&lt;/code&gt;的取值范围是{0,1}. &lt;/p&gt;
&lt;p&gt;不过一条街可能从两个方向被经过(&lt;code&gt;G&lt;/code&gt;里面的边是有向的), 如果&lt;code&gt;e&lt;/code&gt;'代表反方向的&lt;code&gt;e&lt;/code&gt;, 那么还应该增加约束:  &lt;code&gt;x_e+x_e'&amp;lt;=1&lt;/code&gt; 就好了. &lt;/p&gt;
&lt;p&gt;接下来&lt;code&gt;y&lt;/code&gt;要满足的就是所有的&lt;code&gt;y&lt;/code&gt;要组成一个&lt;em&gt;路径(path)&lt;/em&gt;, 对于既不是起点又不是终点的一个节点&lt;code&gt;v&lt;/code&gt;, 还是很好写的, 类似flot: &lt;code&gt;sum(进入v的y_e) = sum(从v流出的y_e)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;对于起点&lt;code&gt;v_start&lt;/code&gt;来说, 其实也不难: &lt;code&gt;sum(进入v_start的y_e) = sum(从v-start流出的y_e)+1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;但是对于终点的话, 有个问题是我们不知道车会停在哪里! Manu太聪明了, 对每一个节点&lt;code&gt;v&lt;/code&gt;引入了另一个变量&lt;code&gt;f_v&lt;/code&gt;,取值范围也是{0,1}, 如果在节点&lt;code&gt;v&lt;/code&gt;停下来, 那么&lt;code&gt;f_v&lt;/code&gt;等于1, 否则就是0. 所以上面的约束可以写成: &lt;code&gt;sum(进入v的y) = sum(从v流出的y_e)+f_v&lt;/code&gt;. 另外别忘了只能停在一个节点, 所以再加约束: &lt;code&gt;sum(所有的f_v)=1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;以上的目标函数以及约束, 虽然数目庞大, 但是都是线性的, 所以是一个整数线性规划问题, 写成数学形式就是: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./运筹的力量_用LP解决Google_2014_Hashcode/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;h2&gt;从solution得到路径&lt;/h2&gt;
&lt;p&gt;一旦上面那个线性规划问题解决了, 我们得到的将会是那些变量&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;y&lt;/code&gt;,以及&lt;code&gt;f&lt;/code&gt;, 但是需要从中提取一条路径最后才能作为solution!! &lt;/p&gt;
&lt;p&gt;这个问题实际上可以归结为: 给定一个一笔画的曲线(其实就是那些&lt;code&gt;y&lt;/code&gt;: 可以想象把每条边都复制&lt;code&gt;y&lt;/code&gt;次, 得到的就是这么一个曲线了), 找出一个可以将其一笔画出来的路径(这条路径也叫"欧拉路径", 没"汉密尔顿路径"有名). 聪明的Manu很快想出来一个算法(我们叫它"Orsini算法"): 大意是当走到底没有走完的时候, 把那些错过的路径夹在原路径的中间就好了. &lt;/p&gt;
&lt;p&gt;算法描述如下: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;i) 从起点开始出发走, 把走过的边涂上颜色(以后不能再走), 只要还可以继续走(还有没有着色的边可走)就一直走下去, 一直到无路可走. (应该会停在&lt;code&gt;f=1&lt;/code&gt;的地方), 得到路径&lt;code&gt;p0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;ii)  如果所有边已经被走过了: &lt;strong&gt;over&lt;/strong&gt;. 如果没有: 找一个没有走过的边与&lt;code&gt;p0&lt;/code&gt;的交叉点: &lt;code&gt;v&lt;/code&gt;(如果找不到的话说明有问题: 后面就遇到这个问题了), 然后执行(iii)&lt;/p&gt;
&lt;p&gt;iii) 从&lt;code&gt;v&lt;/code&gt;出发, 在进行类似(i)的操作得到一条路径(应该是一个环), 然后把&lt;code&gt;p0&lt;/code&gt;从&lt;code&gt;v&lt;/code&gt;那里劈开, 把这个环塞到中间组成新的&lt;code&gt;p0&lt;/code&gt;, 然后再执行(ii).  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样就可以得到对应的路径了. &lt;/p&gt;
&lt;h2&gt;一开始的想法&lt;/h2&gt;
&lt;p&gt;以上的建模是针对一辆车的, 我们一开始的想法是: 对一辆车进行这个操作, 得到结果以后更新一下&lt;code&gt;G&lt;/code&gt;(把那些已经走过的街道的长度设为0, 然后再走下一辆车... 这样跑8次就能得到最优解了. &lt;/p&gt;
&lt;p&gt;一切看起来&lt;em&gt;似乎&lt;/em&gt;都非常完美......&lt;/p&gt;
&lt;h1&gt;II.遇到的问题&lt;/h1&gt;
&lt;h2&gt;计算能力问题&lt;/h2&gt;
&lt;p&gt;写好了AMPL的程序以后, 我们遇到的第一个问题是: 这么大的问题, 一般电脑算不出来(曾经用glpk让电脑跑了一夜, 还是没有得到结果). &lt;/p&gt;
&lt;p&gt;后来问老师, 老师说glpk并不是非常高效的求解器, 然后推荐给了我们一个非常给力的网站: &lt;a href="http://neos-server.org/neos/"&gt;NEOS&lt;/a&gt; ! 这个网站可以让人上传AMPL程序, 然后用它们的服务器跑, 而且使用的求解器也是商用的, 比开源求解器快的不是一个数量级(我们发现最快的求解器是&lt;em&gt;Gurobi&lt;/em&gt;, 十分给力). &lt;/p&gt;
&lt;p&gt;这样一来计算的问题就解决了, 但是我们很快发现一个更严重的问题, 是我们的建模里的一个严重缺陷...&lt;/p&gt;
&lt;h2&gt;subtour问题&lt;/h2&gt;
&lt;p&gt;我们兴冲冲的拿NEOS的结果跑Orsini算法的时候, 发现总是报错: 也就是在第二步, 程序无法找到一个和&lt;code&gt;p0&lt;/code&gt;有交叉点的边: &lt;em&gt;也就意味着我们的模型得到的路径并不是只有一个connected component!!! &lt;/em&gt;也就是说, 我们得到的解其实是一条从起点到某个终点的路径, 外加很多和这个路径没有交点的圈圈(subtour)!&lt;/p&gt;
&lt;p&gt;是啊, 这个问题很类似旅行商问题(TSP), 而TSP的困难之一 就是要解决subtour的话需要加入2^n个新的约束.... 2^10000个约束? impossible...&lt;/p&gt;
&lt;h1&gt;III. subtour问题的"解决"&lt;/h1&gt;
&lt;h2&gt;各种纠结&lt;/h2&gt;
&lt;p&gt;在一次PC上有一道题目介绍了TSP subtour问题的一种建模方式, "potentiel"建模, 可以防止加入2^n个约束: 为每个节点&lt;code&gt;v&lt;/code&gt;引入新的变量&lt;code&gt;u_v&lt;/code&gt;,&lt;code&gt;u_v&lt;/code&gt;代表了节点&lt;code&gt;v&lt;/code&gt;被访问的顺序, 约束做的非常巧妙, 是这样的: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./运筹的力量_用LP解决Google_2014_Hashcode/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;p&gt;这样, 当&lt;code&gt;x_ij&lt;/code&gt;是1的时候, 就保证&lt;code&gt;u_j&lt;/code&gt;比&lt;code&gt;u_i&lt;/code&gt;大1, 而当&lt;code&gt;x_ij&lt;/code&gt;是0的时候, 这个约束则非常松弛, 几乎相当于没有. &lt;/p&gt;
&lt;p&gt;不过这个方法套到我们这个projet的话也有问题: 那就是每个节点只能有一个&lt;code&gt;u_v&lt;/code&gt;, 所以每个节点只能最多访问一次.... 不过我们很快想到了办法: 把所有节点复制一个(复制"一层"), 然后每条边的话也进行复制, 同时加上那些连接各层的边. &lt;/p&gt;
&lt;p&gt;举个例子, 原来的一条边是: &lt;code&gt;(u, v)&lt;/code&gt;, 我们复制了一层, 这些新节点叫它们&lt;code&gt;u',v&lt;/code&gt;',... 那么在这个两层的图里, 我们要把原来的这条边变成4条: &lt;code&gt;(u, v)&lt;/code&gt;, &lt;code&gt;(u, v')&lt;/code&gt;, &lt;code&gt;(u', v)&lt;/code&gt; 和 &lt;code&gt;(u', v')&lt;/code&gt;. 这样就可以保证路径可以经过一个点两次了, 如果想要保证可以经过一个点K次, 只要做K层就好了(每条边变成K^2条). &lt;/p&gt;
&lt;p&gt;然后, &lt;code&gt;x&lt;/code&gt;也不需要了, 因为每条边的&lt;code&gt;y&lt;/code&gt;最大就是1. 但是还有一个问题是目标函数, 由于一条边变成了四条, 如果走四遍的话就多算了四次这条边的长度... 有两种解决办法: 一是类似前面的方法, 给每条边指定定一个indicatrice, 这样就不会重复了, 还有一种更简单的办法是, 在四条边里, 只取一条边的长度保持不变, 其他长度都设成0, 算法自然会优先走那条长度不是0的边(这个没有仔细证明, 不过貌似是这样的). 我们采用了第二个办法.... &lt;/p&gt;
&lt;p&gt;就这样废了好大功夫, 写好了两层节点的程序, 送去NEOS一跑.... 超时了(超过8h后NEOS会自动停止求解过程)... 后来我们发现即使是不多加新一层的程序, 也会超时. 那节PC里也说, 这种建模方法实际上计算效率比加入2^N个约束的建模还要差... &lt;/p&gt;
&lt;p&gt;所以总结一下就是: 问题还是没有解决...&lt;/p&gt;
&lt;h2&gt;绕过subtour问题&lt;/h2&gt;
&lt;p&gt;就在一筹莫展之际, Manu提议把搜索的范围缩小: 不用整个巴黎的数据, 只取起点附近的区域, 这样的话, 说不定我们原先的模型得到的结果会少一点connected components... 试了一下, 果然! 虽然没有强制要求路径的连通性, 得到的结果确实(几乎)只有一个联通分支! &lt;/p&gt;
&lt;p&gt;后来就想到了一个很聪明的办法: 用八倍的T作为时间限制, 让一辆车去跑, 由于时间很充分, 我们得到的解应该不太会出现多个联通分支, 然后一旦得到了这个路径(后来我们叫它"big path"), 只需要把它分成8段, 每辆车先从起点(巴黎谷歌)跑到每一段的开头, 然后沿着这条路跑就好了啊!! 虽然从巴黎谷歌跑到每一段的起点会稍微浪费一些时间, 但是这点损失其实微不足道!! 而且也不用跑8次LP这么麻烦了 -- 要是早点想到这个就好了!!&lt;/p&gt;
&lt;p&gt;而且很神奇的是, 把时间变成了8T以后, 我们的Lp模型计算的更快了: 原先要计算30分钟左右, 现在只要差不多3分钟就出结果了!! 这一点没太想明白, 可能是搜索的空间变小了??&lt;/p&gt;
&lt;p&gt;说写就写, 最短路径用Dijkstra算法就能得到了, 不一会就写出了这个把一条big path变成8条small path的程序. 然后我们一举得到了1957596分(离满分还差了两千米左右)!!&lt;/p&gt;
&lt;h1&gt;IV. 进一步优化&lt;/h1&gt;
&lt;p&gt;优化的话有两个方向: 第一个方向是修改那个程序代码, 使得每次走到big path某段起点的时候可以少走些路, 不过这个方向应该没什么前途: 程序写起来麻烦不说, 可以改进的空间也很有限, 因为big path一共也没有剩多少时间, 所以八辆车是不可能把big path走完的. 第二个方向则是设法优化big path的时间使用, 使得它在得到最长路径的同时使用尽量少的时间. &lt;/p&gt;
&lt;h2&gt;引入时间正则项&lt;/h2&gt;
&lt;p&gt;其实8T作为时间来说非常充裕, 但是我们的解里面, big path还是把时间用的差不多了: 因为时间根本没有出现在目标函数里. 所以, 可以把时间也作为目标函数加上去, 不过要注意最优先要优化的还是路径长度, 所以时间项前面要乘以一个非常小的数(比如0.000001), 类似做regularization. &lt;/p&gt;
&lt;p&gt;所以新的目标函数是: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./运筹的力量_用LP解决Google_2014_Hashcode/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;p&gt;这样一运行, 我们的big path居然剩下了六千多秒的时间!!! 这些时间足够八辆车跑到各段的起点了!! 我们这样, 八辆车走完了big path所有的路程得到的结果离满分只差了7米, 而最后一辆车还有两千多秒没有走! &lt;/p&gt;
&lt;p&gt;检查了一下, 发现有一个7米长的路是唯一剩下没走过的路: 于是只要再让最后一辆车去走一下就好了(因为时间够用), 最终我们的方案走完了整个巴黎:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./运筹的力量_用LP解决Google_2014_Hashcode/pasted_image005.png" /&gt;&lt;/p&gt;
&lt;p&gt;等一下, 这里有点奇怪: 为什么优化得到的结果并不是最优的(没有走完所有的路程)? 我们通过后来手动走那条剩下的路都没有超时, 所以说其实肯定可以在8T的时间走遍所有街道的! 后来查了一下才发现, 原来Gurobi并不是返回最优解, 而是当当前可行解与最优解足够接近的时候就直接停止, 这个参数的名字叫mipgap, 更多参数可以参考这里: &lt;a href="http://www.gurobi.com/documentation/6.0/ampl-gurobi-guide/parameters"&gt;http://www.gurobi.com/documentation/6.0/ampl-gurobi-guide/parameters&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;这也就解释了为什么NEOS得到的解不是最优的, 不过还好, 通过最后手动添加那条没走的边, 还是走完了所有的街道. &lt;/p&gt;
&lt;p&gt;............&lt;/p&gt;
&lt;p&gt;只是作为强迫症的话觉得还是有点......不够完美.&lt;/p&gt;
&lt;h2&gt;直接优化时间&lt;/h2&gt;
&lt;p&gt;今晚, 机智的Manu想到了解决办法: 既然知道所有的街道都会被走遍, 直接不把它看成目标, 而是直接作为约束好了, 然后约束直接改成优化时间! &lt;/p&gt;
&lt;p&gt;要就经过所有街道的约束很简单, 那就是对任何街道&lt;code&gt;e&lt;/code&gt;, 都有: &lt;code&gt;y_e+y_e'&amp;gt;=1&lt;/code&gt;. 另外肯定所有街道都会经过, &lt;code&gt;x&lt;/code&gt;就没有必要存在了. &lt;/p&gt;
&lt;p&gt;LP模型表达为: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./运筹的力量_用LP解决Google_2014_Hashcode/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;p&gt;用这样的模型, 我们的big path 省下了一万两千多秒, 所以我们的最终结果里, 最后的一辆车跑完以后还有9596秒没有用!!&lt;/p&gt;
&lt;p&gt;到这一步, 真的可以算是完美解决这个问题了, 而且强迫症也得救了. &lt;/p&gt;
&lt;p&gt;Yeah!  : )&lt;/p&gt;</summary><category term="LP"></category><category term="算法"></category></entry><entry><title>Linux下pdf文件的压缩与合并</title><link href="http://x-wei.github.io/Linux%E4%B8%8Bpdf%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%90%88%E5%B9%B6.html" rel="alternate"></link><updated>2014-10-29T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/Linux下pdf文件的压缩与合并.html</id><summary type="html">&lt;h2&gt;压缩pdf&lt;/h2&gt;
&lt;p&gt;用&lt;code&gt;convert&lt;/code&gt; 只简单指定resize好像不太好使: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;convert -resize 50% input.pdf out.pdf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;gs&lt;/code&gt;(&lt;a href="http://blog.sciencenet.cn/blog-467089-773990.html"&gt;http://blog.sciencenet.cn/blog-467089-773990.html&lt;/a&gt;):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -dNOPAUSE -dQUIET -dBATCH -sOutputFile=out.pdf input.pdf&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;后来发现老是compress以后的结果不好, 看到&lt;a href="http://superuser.com/questions/427851/batch-resize-and-compress-pdf-files"&gt;这篇帖子&lt;/a&gt;发现&lt;strong&gt;convert有好多选项&lt;/strong&gt;. 最后实验下来这样convert的效果很好, 既能压缩文件, 又保证了压缩后还足够清楚:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;convert -density 200 -compress jpeg input.pdf out.pdf&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;合并pdf&lt;/h2&gt;
&lt;p&gt;之前&lt;a href="http://x-wei.github.io/%E5%9B%BE%E7%89%87%E5%90%88%E5%B9%B6%E4%B8%BApdf,%20%E5%90%88%E5%B9%B6mp3,%20%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87.html"&gt;博客&lt;/a&gt;写过, 用pdfjoin: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;pdfjoin $(ls *.pdf|sort -n) --outfile out.pdf&lt;/code&gt;&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>一个简单的python进度条</title><link href="http://x-wei.github.io/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84python%E8%BF%9B%E5%BA%A6%E6%9D%A1.html" rel="alternate"></link><updated>2014-08-14T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/一个简单的python进度条.html</id><summary type="html">&lt;p&gt;在处理大量数的时候, 如果输出类似 "process i out of n files..." 这样的内容来指示进度的话, 虽然可以显示目前的进度(用来安慰等待的心情...)但有个问题是, 如果输出了太多行(比如一万行...), 就看不到前面的内容了... &lt;/p&gt;
&lt;p&gt;所以想找一个命令行下面的进度条, 其实python已经有了(不止一个)进度条的包了, 比如&lt;a href="https://pypi.python.org/pypi/progressbar/2.3-dev"&gt;progressbar&lt;/a&gt;, 但是不知为什么这个包在windows下面没有能做到刷新显示 -- 就是刷新进度的时候, 没有把原先那一行去掉, 而是在下面再输出了一行... (不过后来在linux下面使用这个包是没问题的, 好奇怪...)&lt;/p&gt;
&lt;p&gt;所以想办法自己写了一个, 发现要实现一个简单的进度条还是很简单的, 关键就是使用&lt;code&gt;\r&lt;/code&gt;, 这样会把光标移动到当前行的开头: 这样下次输出的时候就会把原先的内容冲掉了. &lt;/p&gt;
&lt;p&gt;代码只有不到二十行: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SimpleProgressBar&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;last_x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="c"&gt;# `x`: progress in percent ( between 0 and 100)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;last_x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;last_x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;pointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mf"&gt;100.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\r&lt;/span&gt;&lt;span class="si"&gt;%d%%&lt;/span&gt;&lt;span class="s"&gt; [&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;]&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;#&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pointer&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;.&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;pointer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flush&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用法也很简单, 先新建一个SimpleProgressBar对象, 在要更新进度条的时候, 调用update方法即可...&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;# An example of usage...&lt;/span&gt;
&lt;span class="n"&gt;pb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SimpleProgressBar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;301&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mf"&gt;100.0&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再吐槽一下windows, 不仅那个progressbar的包不好使, multiprocessing的包也不好使, 郁闷... &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[08-15补充]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后来想到, 既然用&lt;code&gt;\r&lt;/code&gt;就可以实现刷新当前行, 还要用毛的进度条啊.... 直接这样写就好了:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;301&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;processing &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt; out od &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt; items...&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;301&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\r&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意print最后要加逗号 否则就换行了...&lt;/p&gt;</summary><category term="python"></category></entry><entry><title>正则表达式入门简介</title><link href="http://x-wei.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B.html" rel="alternate"></link><updated>2014-08-01T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/正则表达式入门简介.html</id><summary type="html">&lt;p&gt;以前虽然也用过正则表达式(比如那个饮水思源的&lt;a href="http://x-wei.github.io/%E6%B0%B4%E6%BA%90PPP%E6%9D%BF%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E5%99%A8.html"&gt;PPP版图片下载器&lt;/a&gt;...)但是那时候基本上是网上到处搜 然后把代码拿过来改, 没有系统的学过这个东西. 前一段实习一开始的时候要处理很大量的文本, 从文本里提取出需要的信息, 所以用到了不少的正则表达式, 也好好的学了一下, 现在回来进行一下总结. &lt;/p&gt;
&lt;h2&gt;什么是正则表达式&lt;/h2&gt;
&lt;p&gt;很多时候,我们需要在文本里寻找满足一种&lt;strong&gt;模式&lt;/strong&gt;(&lt;em&gt;pattern&lt;/em&gt;)的一段子字符串(substring), 注意是一种模式而不是某一个具体的字符串. 举个例子, 在一段文本里寻找这里面出现的所有的网址, 那么对应的模式就是: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"以&lt;code&gt;www.&lt;/code&gt;开头, 中间有一些东西(可以是字母也可以是数字等), 最后以 &lt;code&gt;.com/.org/.edu...&lt;/code&gt; 结尾的所有的字符串"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再比如, 要查找文本中出现的电话号码, 电话号码的格式是区号加横线再加号码, 那么模式就应该是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"以3个或4个数字开头, 三个或四个数字之后跟一个横线, 横线后再跟7个或8个数字"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再再比如, 要查找出现的电子邮件地址, 那么模式大概是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"以字母或数字或下划线开头, 之后跟着一个@符号, @符号以后一些用点分隔的字母或数字, 最后应该以.com/.org/.edu等结束"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以想象实际应用中会有描述起来更加罗嗦的模式, 而&lt;strong&gt;正则表达式就是用来描述这种"模式"的语法&lt;/strong&gt;, 使用正则表达式, 可以用很简短的代码表达很复杂的模式. 有人给正则表达式起了个别名叫"&lt;em&gt;字符串模板&lt;/em&gt;", 其实更贴切... &lt;/p&gt;
&lt;p&gt;还有, 后面总是会提到"某个正则表达式&lt;em&gt;exp&lt;/em&gt;匹配(match)了某个字符串&lt;em&gt;str&lt;/em&gt;", 这里说&lt;strong&gt;"匹配"&lt;/strong&gt;的意思其实是&lt;em&gt;"字符串str满足了正则表达式exp描述的那种模式"&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;关于正则表达式, &lt;a href="http://deerchao.net/tutorials/regex/regex.htm"&gt;这篇博客&lt;/a&gt;可以说是经典之作, 搜索"正则表达式"这篇文章几乎都是第一个被找到的. 每次我有问题都要再翻出来看一下这篇, 讲的非常好. &lt;/p&gt;
&lt;p&gt;另外强烈推荐一个非常赞的在线测试正则表达式的网站: &lt;a href="http://regex101.com/"&gt;http://regex101.com/&lt;/a&gt; 做得超级棒(具体怎么棒见后文).&lt;/p&gt;
&lt;h2&gt;匹配单个字符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;匹配某个&lt;em&gt;特定的&lt;/em&gt;字符:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只需要写出来就好了, 类似于记事本的查找功能. 
ex. 查找"abc"这个字符串, 正则表达式就是: &lt;code&gt;abc&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配&lt;em&gt;某一类&lt;/em&gt;字符:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如匹配数字, 只需要把候选的字符放进&lt;strong&gt;中括号&lt;/strong&gt;, 而且可以用横线表示一系列的字符:&lt;/p&gt;
&lt;p&gt;ex. 匹配一个数字: &lt;code&gt;[0-9]&lt;/code&gt;
ex. 匹配大写的一个字母: &lt;code&gt;[A-Z]&lt;/code&gt;
ex. 匹配一个数字或字母(大小写都可以): &lt;code&gt;[A-Za-z0-9]&lt;/code&gt;
ex. 匹配一个元音字母(aeiou中的一个): [aeiou]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配某一类以外的字符:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这一类字符前面加上&lt;code&gt;^&lt;/code&gt;, 起到的作用就是取这些字符的补集(&lt;strong&gt;"反义"&lt;/strong&gt;).
ex. 匹配一个不是数字的字符: &lt;code&gt;[^0-9]&lt;/code&gt;
ex. 匹配任意一个不是元音字母的字符: &lt;code&gt;[^aeiou]&lt;/code&gt;
ex. 匹配以b开头, 以d结尾的三个字母长的单词: &lt;code&gt;b[a-z]d&lt;/code&gt;, "bed", "bad"都满足这个条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配正则表达式中用到的的特殊字符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如要匹配'^'这个字符, 由于这个字符是正则表达式里使用的有特殊含义的字符, 需要在前面加&lt;strong&gt;反斜杠转义&lt;/strong&gt;: &lt;code&gt;\^&lt;/code&gt;
类似的特殊字符还有不少:  &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;)&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt;,......&lt;/p&gt;
&lt;h2&gt;匹配任意字符&lt;/h2&gt;
&lt;p&gt;用的最多的是这一个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配除了换行符以外的任意字符: &lt;code&gt;.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(在开启"单行模式"的时候, 可以连换行符一起匹配, 见后文.)&lt;/p&gt;
&lt;p&gt;然后, 在反斜杠后面加某些字母的时候有特殊含义(&lt;strong&gt;"元字符"&lt;/strong&gt;): &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配字母或数字或下划线或汉字: &lt;code&gt;\w&lt;/code&gt;(用前面的&lt;code&gt;[A-Za-z0-9]&lt;/code&gt;之类的方法也可以做到)&lt;/li&gt;
&lt;li&gt;匹配任意空白字符(空格或TAB): &lt;code&gt;\s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;匹配任意数字: &lt;code&gt;\d&lt;/code&gt;(用前面的&lt;code&gt;[0-9]&lt;/code&gt;也可以做到)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把上面这些反斜杠加小写字母变成反斜杠加&lt;em&gt;大写字母&lt;/em&gt;的话, 成了取补集(类似前面那个&lt;code&gt;^&lt;/code&gt;的作用)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配任意不是字母，数字，下划线，汉字的字符: &lt;code&gt;\W&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;匹配任意不是空白符的字符: &lt;code&gt;\S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;匹配任意非数字的字符: &lt;code&gt;\D&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以如果要匹配, 包括换行符的话, 只需要把&lt;code&gt;\s \S&lt;/code&gt;一起用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配所有字符, 包括换行符: &lt;code&gt;[\s\S]&lt;/code&gt; &lt;a href="http://bbs.csdn.net/topics/300041987"&gt;http://bbs.csdn.net/topics/300041987&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;匹配位置&lt;/h2&gt;
&lt;p&gt;有时候还要指定某些位置, 比如说: 要匹配网址, 网址要以"www."开头, 所以如果有个网址是: "www.abcwww.com" 的话, 有可能匹配成了中间那个"www.", 那么就有问题了. 所以要指定"www."要在一个字符的开头出现, 而不能是在中间(前面不能有字符). &lt;/p&gt;
&lt;p&gt;这种情况下我们就不是要匹配某个具体的字符串, 而是&lt;strong&gt;匹配一个位置&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配单词的开始或结束(&lt;em&gt;word boundary&lt;/em&gt;): &lt;code&gt;\b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是我们前面说的情况, 只需要加上\b, 就不会匹配在某个单词中间出现的"www."了.
ex. 匹配网址开头的"www.": &lt;code&gt;\bwww\.&lt;/code&gt; &lt;a href="http://regex101.com/r/oZ6aK1/1"&gt;例子链接&lt;/a&gt; ⇐ 可以把最开始那个&lt;code&gt;\b&lt;/code&gt;去掉, 看看结果有什么区别. &lt;/p&gt;
&lt;p&gt;注意这个&lt;code&gt;\b&lt;/code&gt;可以是单词的开始, 也可以是单词的结束. 还是网址的例子, 如果一个网址是:"www.abcwww.qwert.coming.com"的话, 我们说"匹配以.com"结尾的字符串, 就有可能是匹配到了&lt;strong&gt;qwert.com&lt;/strong&gt;ing, 也会有问题, 所以我们应该在"com"后面加上一个&lt;code&gt;\b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;ex. 匹配网址结束处的".com": &lt;code&gt;\.com\b&lt;/code&gt;&lt;a href="http://regex101.com/r/oZ6aK1/2"&gt;例子链接&lt;/a&gt; ⇐ 同理可以看看去掉&lt;code&gt;\b&lt;/code&gt;以后有什么不同.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;然后这个元字符&lt;code&gt;\b&lt;/code&gt;变成大写以后也是反义, &lt;code&gt;\B&lt;/code&gt;匹配所有不是单词开头或结束的位置.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;匹配整个字符串的开头: &lt;code&gt;^&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意是整个字符串的开头, 而不是指每一行的开头! (但是在"多行模式"时可以代表每一行的开头, 见后面冠以正则表达式选项的讨论)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匹配字符串的结束: &lt;code&gt;$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样是指整个字符串的结束. &lt;/p&gt;
&lt;h2&gt;重复次数&lt;/h2&gt;
&lt;p&gt;这个和前面介绍的匹配字符配合起来(指定要匹配的字符, 再指定字符重复的次数), 就可以完成大部分的工作了.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符重复&lt;em&gt;(exactly)n次&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只需要把数字n放进&lt;strong&gt;大括号&lt;/strong&gt;里就可以了. 
ex. 找一个六位的数字, 那么就是0-9的数字重复6次: &lt;code&gt;[0-9]{6}&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重复&lt;em&gt;m到n次&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只需要在大括号里把m和n用逗号进行分隔.
ex. 找一个6到8位的数字: &lt;code&gt;[0-9]{6,8}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是要重复m&lt;strong&gt;或&lt;/strong&gt;n次的话, 我没有找到好的写法, 可以用后面介绍的分支条件实现, 不过比较繁琐...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重复&lt;em&gt;大于等于n次&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(重复小于等于n次等价于0到m次)
大括号里面n后面加一个逗号:
ex. 找6位以上的数字: [0-9]{6,}&lt;/p&gt;
&lt;p&gt;平时用到的比较多的是要求&lt;em&gt;"重复大于等于1次"&lt;/em&gt;或者&lt;em&gt;"重复大于等于0次"&lt;/em&gt;, 由于上面这样的写法有的时候比较罗嗦, 所以有了下面的简写:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重复&lt;em&gt;大于等于1次&lt;/em&gt;: &lt;code&gt;+&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等价于 &lt;code&gt;{1,}&lt;/code&gt;
ex. &lt;code&gt;goo+gle&lt;/code&gt;, 可以匹配"google", "gooogle", "goooogle"等, 因为第二个o可以出现大于等于1次. 
(当然上面这个例子也可以在前后加上单词边界&lt;code&gt;\b&lt;/code&gt;, 以防止匹配到某个长单词的中间)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重复&lt;em&gt;大于等于0次&lt;/em&gt;: &lt;code&gt;*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等价于 &lt;code&gt;{0,}&lt;/code&gt;
ex. 匹配以a开头以t结尾的单词: &lt;code&gt;a[a-z]*t&lt;/code&gt; , "at", "attachment", "act"等都符合条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重复一次或0次: &lt;code&gt;?&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等价于 &lt;code&gt;{0,1}&lt;/code&gt;
ex. 匹配"color"或者"colour": &lt;code&gt;colou?r&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;贪婪(greedy)模式/懒惰(lazy)模式&lt;/h2&gt;
&lt;p&gt;前面介绍的那些指定重复次数的部分, 由于有时是指定一个重复次数的范围, 而经常匹配到的重复的次数也是一个范围, 所以有"贪婪"和"懒惰"的区别.&lt;/p&gt;
&lt;p&gt;好像上一句话没有说清楚... 举个例子, 要匹配大于六位的数字, 我们的正则表达式是&lt;code&gt;[0-9]{6,}&lt;/code&gt;, 意思是要有六个或更多的重复次数. 那么对于一个字符串: "123456789", 一共有9位, 它既可以看作重复6次(取前6位), 也可以看作重复7次, 8次, 9次... 那么岂不是含义上出现歧义(ambiguous)了??&lt;/p&gt;
&lt;p&gt;而实际上, 我们写的表达式&lt;code&gt;[0-9]{6,}&lt;/code&gt;在这个例子里最终会匹配所有的9位, 这是因为我们写的这个表达式默认上是&lt;strong&gt;贪婪模式&lt;/strong&gt;的, 意思是匹配重复&amp;gt;=6次的的重复, 但是会&lt;em&gt;尽可能多重复&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;与之相反, &lt;strong&gt;懒惰模式&lt;/strong&gt;的意思是&lt;em&gt;尽可能少重复&lt;/em&gt;. &lt;strong&gt;正则表达式默认是贪婪模式&lt;/strong&gt;, 要开启懒惰模式只需要在重复次数的后面加上一个问号"&lt;code&gt;?&lt;/code&gt;".&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+?&lt;/code&gt; : 重复&amp;gt;=1次, 但是尽量少重复&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*?&lt;/code&gt; : 重复&amp;gt;=0次, 但是尽量少重复&lt;/li&gt;
&lt;li&gt;&lt;code&gt;??&lt;/code&gt; : 重复0或1次, 但是尽量少重复&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,}?&lt;/code&gt;: 重复&amp;gt;=n次, 但是尽量少重复&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{m,n}?&lt;/code&gt;: 重复m到n次, 但是尽量少重复&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再插一句, 这个"贪婪模式的开启标志"&lt;code&gt;?&lt;/code&gt; 和"重复次数的符号"&lt;code&gt;?&lt;/code&gt; 虽然都是问号, 但是由于放的位置不一样, 所以不会造成歧义, 因为"重复次数的符号"的问号是出现在"匹配字符"(比如&lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;[0-9]&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt;)的后面的, 而"贪婪模式的开启标志"的问号是出现在"重复次数"(如&lt;code&gt;{m,n}&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;)的后面的...&lt;/p&gt;
&lt;h2&gt;分支条件(alternative)&lt;/h2&gt;
&lt;p&gt;意思就是可以匹配两种模式的任意一种, 看例子:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ex1. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中国的电话号码有的城市是三位区号加横线加八位号码(比如"021-54749110" ⇐ 这是上海一所学校的保卫处号码), 有的是四位区号加横线加七位或八位号码的(比如"0635-8238080" ⇐ 这是山东一所大学的保卫处, 以及"0531-88881234" ⇐ 这是山东台小么哥的号码==...). 要匹配这样的号码, 如果这样写:
&lt;code&gt;\d{3,4}-\d{7,8}&lt;/code&gt;
(别忘了&lt;code&gt;\d&lt;/code&gt;等价于&lt;code&gt;[0-9]&lt;/code&gt;)
那么其实是不对的, 因为我们不允许出现3位区号后面跟7位号码的情况出现, 所以这里其实是两种模式, 所以我们是要&lt;strong&gt;匹配这两种模式其中的任意一种&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;这种情况下, 只需要把两种情况分别写出来, 中间用&lt;code&gt;|&lt;/code&gt;分割即可:
&lt;code&gt;\d{3}-\d{8}|\d{4}-\d{7,8}&lt;/code&gt;
不过看起来有点乱了... 可以加上小括号这样显得更清楚一些: 
&lt;code&gt;(\d{3}-\d{8})|(\d{4}-\d{7,8})&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不过小括号在正则表达式里面除了让正则表达式(稍微)更容易读以外, 还有一个作用是后面提到的"分组"或者"捕获", 这个后面再说...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ex2.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面说到过怎么匹配重复m&lt;strong&gt;或&lt;/strong&gt;n次的数字, 我没有找到更方便的方法, 只好用分支条件实现了:
&lt;code&gt;\d{m}|\d{n}&lt;/code&gt;
但是要注意, 这个时候会有和前面贪婪/懒惰类似的问题: 如果一串数字有9位长, 我要匹配6位或9位的数字, 那么应该匹配到哪里呢? &lt;/p&gt;
&lt;p&gt;其实这个时候取决于我们是写&lt;code&gt;\d{9}|\d{6}&lt;/code&gt;还是&lt;code&gt;\d{6}|\d{9}&lt;/code&gt;, 正则表达式有类似于编程语言里的"&lt;strong&gt;条件短路&lt;/strong&gt;"(shortcut)性质, 一旦第一个模式满足了, 就不会去寻找竖线后面的第二个模式了...&lt;/p&gt;
&lt;h2&gt;小括号: 对结果进行分组(group), "捕获"&lt;/h2&gt;
&lt;p&gt;先说一句别的, 前面介绍重复次数的部分, 介绍了怎么指定某个类型的&lt;em&gt;单个字符&lt;/em&gt;重复的次数, 要是想寻找某个特定字符组合的重复次数该怎么办呢? 只需要把要重复的部分用小括号括起来, 然后后面指定重复的次数就可以了...&lt;/p&gt;
&lt;p&gt;ex. 寻找好几个"bla"连着的字符串: &lt;code&gt;(bla)+&lt;/code&gt;, 这样"blablabla"之类的字符串就可以被匹配了. &lt;/p&gt;
&lt;p&gt;所以小括号的这种作用类似于小括号在一般编程语言的作用, 就是把一部分内容放在一起. 但是与此同时, 每一个小括号其实还"&lt;strong&gt;捕获&lt;/strong&gt;"了一个"&lt;strong&gt;分组&lt;/strong&gt;"(group). 意思就是在匹配到的字符串里(叫做一个"match"), 我们还可以得到它的一个子字符串. &lt;/p&gt;
&lt;p&gt;还是举电话号码的例子, 前面的方法我们可以得到一个类似"021-54749110"这样的匹配结果, 但是如果我们想&lt;em&gt;把区号和区号后的号码分别保存&lt;/em&gt;的话, 还需要再&lt;em&gt;在程序里&lt;/em&gt;对这个字符串做个处理: 比如把字符串的前三个截取出来保存为区号, 把第五个字符到最后的子字符串截取出来保存为号码... 这样会有问题, 因为我们也可能得到"0531-8881234"这样的结果... 于是我们只能先在得到的字符串里寻找"-", 然后再从"-出现的位置那里把字符串截成两段...... 总之这样的话在程序里还要进行很麻烦的后期处理, 非常不爽(c'est trop lourd!)......&lt;/p&gt;
&lt;p&gt;幸好我们可以使用正则表达式的分组功能, 在得到结果的字符串的同时, 还在不同的分组里放了对应的的子字符串,&lt;em&gt;这样在程序里只要得到每一个分组就可以了&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;而给字符串分组的方法也很简单, 就是简单的&lt;em&gt;给要分组的地方加上小括号括起来就好了&lt;/em&gt;. (当然, 可能你只是为了看得清楚才给表达式加小括号, 但是在正则表达式匹配字符串的时候也会帮你把它捕获到一个分组里.) 所以没加一对小括号就会在结果中增加一个分组, 分组的顺序是按照小括号出现的顺序排列的. &lt;/p&gt;
&lt;p&gt;所以在电话号码这个例子里, 我们可以写:
&lt;code&gt;(\d{3})-(\d{8})|(\d{4})-(\d{7,8})&lt;/code&gt;
&lt;a href="http://regex101.com/r/bS1uP4/3"&gt;例子链接&lt;/a&gt;
我喜欢reg101这个网站的原因就是它可以显示非常丰富的信息. 
在网站的右上角,有关于表达式的解释:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="正则表达式入门简介/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;在右下角会显示捕获到的分组(groups):&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="正则表达式入门简介/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;(这里的分组编号可能有点问题, 后两个分组的编号应该是1和2的... 这是由于我们使用了分支条件造成的, 不知是bug还是feature...)&lt;/p&gt;
&lt;p&gt;然后关于怎么在程序里获得正则表达式的分组, 可以去看每一种编程语言的相关文档...... &lt;/p&gt;
&lt;h2&gt;正则表达式选项("模式")&lt;/h2&gt;
&lt;p&gt;使用正则表达式的时候, 还可以指定一些"模式"选项, 比如在reg101网站上, 表达式右边有一个选项窗口:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="正则表达式入门简介/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;p&gt;当开启某些"模式"的时候, 正则表达式的匹配行为稍有不同. 其实上面的截图已经讲的很清楚了, 下面捡比较常用的说一下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局模式global, "g": 就是不止匹配第一个, 而是把所有的匹配都显示出来.&lt;/li&gt;
&lt;li&gt;扩展模式(或者"注释模式")extended, "x": 使用后正则表达式也可以换行, 可以随便加空格(将被忽略), 也可以使用注释(使用&lt;code&gt;#&lt;/code&gt;开始注释)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个是我经常用的选项, 有时候表达式写的很长很乱, 如果不能换行或者加注释的话, 下次看得时候就不知道是怎么回事了...
比如刚才那个电话的例子, 我们在开启了扩展模式以后, 可以写成这样:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;(\d{3}) - (\d{8}) #region code, -, phone number
| #alternative
(\d{4}) - (\d{7,8})#region code, -, phone number
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://regex101.com/r/bS1uP4/4"&gt;例子链接&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多行模式multiline, "m": 前面"匹配位置"那一节提到了, 就是改变&lt;code&gt;^&lt;/code&gt;和&lt;code&gt;$&lt;/code&gt;的意思, 不让它们匹配整个字符串的开始和结束, 而是每一行的开始和结束.&lt;/li&gt;
&lt;li&gt;单行模式singleline, "s": 前面也提到了, 作用是让&lt;code&gt;.&lt;/code&gt;也匹配换行符...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(所以可见, &lt;em&gt;单行模式和多行模式根本不是相互排斥的关系&lt;/em&gt;....... 这名字起的不好...)&lt;/p&gt;
&lt;p&gt;关于怎么开启这些选项, 还是要看不同语言的文档... 
比如在python里, 只要在&lt;code&gt;re.compile()&lt;/code&gt;函数使用加入&lt;code&gt;re.X&lt;/code&gt;等参数, 见&lt;a href="https://docs.python.org/2/library/re.html#module-contents"&gt;文档&lt;/a&gt;...&lt;/p&gt;
&lt;h2&gt;其他内容&lt;/h2&gt;
&lt;p&gt;这里我只写了我用到的一些东西, 关于正则表达式还有很多没有提到的内容(所谓的"高级议题"?), 比如"零宽断言"以及"平衡组"等内容, 这些都在deerchao的那篇&lt;a href="http://deerchao.net/tutorials/regex/regex.htm"&gt;经典博客&lt;/a&gt;里提到了...&lt;/p&gt;
&lt;h2&gt;实际例子&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;例子1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要分析很长的文本, 文本的一部分包含了一趟航班的信息, 比如出发和到达的时间, 出发和到达的机场, 以及航班号等... 这些信息中间都包含在一长串字符中间. &lt;/p&gt;
&lt;p&gt;我们用正则表达式处理, 并且把不同的信息放在不同的分组里, 这样就方便了程序的处理. &lt;a href="http://regex101.com/r/bS1uP4/5"&gt;这里&lt;/a&gt;是我写的正则表达式.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例子2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再举个例子, 我想要现在&lt;a href="http://www.cs.waikato.ac.nz/ml/weka/mooc/dataminingwithweka/"&gt;这个页面&lt;/a&gt;的所有的东西, 可是用鼠标一个一个点击实在是太麻烦了, 所以可以写一个程序把这些链接都提取出来, 然后自动进行下载. &lt;/p&gt;
&lt;p&gt;所以需要分析这个页面的html文件, 右键 → 显示网页源代码就可以看到了, 虽然我不懂html的语法, 但是可以发现, 下载的链接都是这样的片段:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class="download_link" href="https://drive.google.com/uc?export=download&amp;amp;id=0B-f7ZbfsS9-xUjhLaURQbWsxbjg" target="_blank"&gt;en&lt;/a&gt;&lt;/td&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是说在&lt;code&gt;class="download_link"&lt;/code&gt;之后, &lt;code&gt;href=&lt;/code&gt;后面的用引号引起来的内容就是我们想要的下载链接了, 于是可以很快用正则表达式来提取它, 我写的表达式见&lt;a href="http://regex101.com/r/hN1lH1/1"&gt;这里&lt;/a&gt;.&lt;/p&gt;</summary><category term="regex"></category></entry><entry><title>putty使用备忘</title><link href="http://x-wei.github.io/putty%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98.html" rel="alternate"></link><updated>2014-07-28T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/putty使用备忘.html</id><summary type="html">&lt;p&gt;最近要用SSH连接服务器, Windows下面当然就是用putty了, 遇到的问题总结一下. &lt;/p&gt;
&lt;h2&gt;保存session&lt;/h2&gt;
&lt;p&gt;打开putty.exe以后, 输入服务器ip, 之后先别点击登录, 先保存一下session下一次就不用再输入了: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="putty使用备忘/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;之后点击登录就好了. &lt;/p&gt;
&lt;h2&gt;本地和服务器之间传输文件&lt;/h2&gt;
&lt;p&gt;传输的时候貌似不能用linux里的scp命令, 而需要使用另一个putty的工具: &lt;code&gt;psftp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下载的时候那个putty.zip压缩包里有一个&lt;code&gt;psftp.exe&lt;/code&gt;, 点击它就打开了. psftp也是一个命令行的工具, 和ssh类似, 用&lt;code&gt;pwd/ls/cd&lt;/code&gt;等在&lt;strong&gt;服务器的&lt;/strong&gt;文件系统里进行移动. &lt;/p&gt;
&lt;p&gt;而在&lt;strong&gt;本地的&lt;/strong&gt;文件系统里移动的话, 用&lt;code&gt;lpwd/lcd/lls.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;移动到了想要传输文件的目录以后(本地和服务器都移动好了以后), 使用&lt;code&gt;put filename&lt;/code&gt;上传本地文件到服务器, 使用 &lt;code&gt;get filename&lt;/code&gt; 下载服务器文件到本地. &lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.lellansin.com/putty%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6.html"&gt;http://www.lellansin.com/putty%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后这个put和get的命令在文件传输比较慢的时候也没有什么进度提示, 不过可以再开一个putty登录进服务器, 然后用 &lt;code&gt;ls -lh&lt;/code&gt; 看看已经传输了多少了...&lt;/p&gt;</summary><category term="ssh"></category></entry><entry><title>IPython上手学习笔记</title><link href="http://x-wei.github.io/IPython%E4%B8%8A%E6%89%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate"></link><updated>2014-07-22T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/IPython上手学习笔记.html</id><summary type="html">&lt;p&gt;&lt;a href="http://www.packtpub.com/learning-ipython-for-interactive-computing-and-data-visualization/book"&gt;Learning IPython for Interactive Computing and Data Visualization&lt;/a&gt;这本书的前两章的笔记, 这本书还被放在了IPython官网上, 虽然只有一百页多一点点, 但是讲的内容却很丰富, 介绍了IPython, numpy, pandas以及并行计算等方面. &lt;/p&gt;
&lt;p&gt;(在开始系统学IPython之前简单使用过IPython, 那时候我还是更喜欢bpython的代码提示功能...)&lt;/p&gt;
&lt;h1&gt;ch1: 10 IPython essentials&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;在任何变量后面加问号&lt;code&gt;?&lt;/code&gt;或者双问号&lt;code&gt;??&lt;/code&gt;, 将会输出详细的信息(按&lt;code&gt;q&lt;/code&gt;退出), &lt;code&gt;??&lt;/code&gt;的信息更加详细些&lt;/li&gt;
&lt;li&gt;Tab Completion: 没啥好说的 没有bpython做的好 也凑合吧...&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_, __, ___&lt;/code&gt;保存最近三次的输出;  &lt;code&gt;_i, __i, ___i&lt;/code&gt;保存最近三次的输入(作为字符串保存)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;magic commands&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在IPython里面可以使用一些标准unix命令, 比如&lt;code&gt;cd&lt;/code&gt;, &lt;code&gt;pwd,ls&lt;/code&gt;等... &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个太好了 否则还要&lt;code&gt;import os&lt;/code&gt;, 然后再什么&lt;code&gt;os.chdir('...')&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其实这些unix命令是IPython的&lt;strong&gt;magic commands&lt;/strong&gt;, 这些magic commands一般用&lt;code&gt;%&lt;/code&gt;作为前缀.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是由于默认IPython开启了&lt;strong&gt;automagic system&lt;/strong&gt;, 上面那些命令可以不用加前缀了(或者使用Tab自动给加上前缀)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%run&lt;/code&gt; 命令, 运行一个.py脚本, 但是好处是, 与运行完了以后这个.py文件里的变量都可以在Ipython里继续访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%timeit&lt;/code&gt; 命令, 可以用来做基准测试(&lt;em&gt;benchmarking&lt;/em&gt;), 测试一个命令(或者一个函数)的运行时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex. &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nf"&gt;%timeit&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="mi"&gt;10000&lt;/span&gt; &lt;span class="n"&gt;loops&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;56.5&lt;/span&gt; &lt;span class="err"&gt;µ&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;per&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt;

&lt;span class="nf"&gt;%timeit&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="mi"&gt;10000&lt;/span&gt; &lt;span class="n"&gt;loops&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;51.7&lt;/span&gt; &lt;span class="err"&gt;µ&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;per&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%debug&lt;/code&gt; 命令: 当有exception的时候, 在console里输入&lt;code&gt;%debug&lt;/code&gt;即可打开debugger. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在debugger里, 输入&lt;code&gt;u,d&lt;/code&gt;(up, down)查看stack, 输入&lt;code&gt;q&lt;/code&gt;退出debugger&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nf"&gt;%debug&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ipython&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;34&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="n"&gt;c374156862&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;----&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;     &lt;span class="n"&gt;raise&lt;/span&gt; &lt;span class="n"&gt;Exception&lt;/span&gt;
      &lt;span class="mi"&gt;3&lt;/span&gt; 
&lt;span class="n"&gt;ipdb&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;
&lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="n"&gt;Oldest&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;
&lt;span class="n"&gt;ipdb&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="n"&gt;Newest&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;
&lt;span class="n"&gt;ipdb&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用%pdb开启自动pdb模式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;%pdb&lt;br /&gt;
Automatic pdb calling has been turned ON&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;%pylab&lt;/code&gt; 命令, 大杀器, 看一下都import了什么:&lt;/p&gt;
&lt;p&gt;%pylab makes the following imports::
    import numpy
    import matplotlib
    from matplotlib import pylab, mlab, pyplot
    np = numpy
    plt = pyplot
    from IPython.display import display
    from IPython.core.pylabtools import figsize, getfigs
    from pylab import *
    from numpy import *&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;画图的时候可以不用非要加&lt;code&gt;plt.&lt;/code&gt;前缀了, 直接&lt;code&gt;plot()&lt;/code&gt;即可. 图像化出来的时候, 画图窗口并没有block, 可以动态(&lt;em&gt;interactively&lt;/em&gt;)画图.&lt;/p&gt;
&lt;p&gt;另外, qtconsole和notebook一样, 指定了&lt;code&gt;inline&lt;/code&gt;选项以后可以直接在窗口里画图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="IPython上手学习笔记/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;p&gt;后来发现inline的图片貌似不能放大看, 所以有时候还是单独一个窗口比较好, 换到非inline模式只需要再输入以下%pylab, 加上选项qt:
&lt;code&gt;%pylab qt&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;IPython Notebook&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(重头戏)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个可以在浏览器里(!!)使用IPython, 并且可以使用多行编辑后再一并执行. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The Notebook brings the functionality of IPython into the browser for multiline textediting features, interactive session reproducibility, and so on.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在shell/cmd窗口里启动ipython的时候加上notebook:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ipython notebook&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看到浏览器打开了, 很神奇: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="IPython上手学习笔记/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;新建一个notebook, 用用看: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="IPython上手学习笔记/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;使用的过程中渐渐理解了为什么书里说可以用来做"&lt;em&gt;multiline textediting features, interactive session reproducibility&lt;/em&gt;"... 因为这不只是个编程的东西, 还可以作为一个笔记本 — 而且是一个交互式的笔记本! &lt;/p&gt;
&lt;p&gt;(&lt;em&gt;注: 更多关于notebook的介绍在下面第二章的内容里.&lt;/em&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码,或者段落, 按照cell(格子)进行组织, 一个cell里面的内容可以是code, 但是也同样可以是markdown的段落, 或者是一个标题(heading).&lt;/li&gt;
&lt;li&gt;在一个代码的cell里, 写入多行代码, 就像在编辑器里写python程序一样, 按回车只会换行, 不会运行程序.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;写了一段程序代码以后, 按&lt;code&gt;ctrl+Enter&lt;/code&gt;运行程序, 运行结果也是一个作为cell. 
(&lt;strong&gt;注&lt;/strong&gt;: 在qtconsole里面相反, 如果要输入多行程序的话, 按&lt;code&gt;Ctrl+Enter&lt;/code&gt;换行(按一一次ctrl+enter即可进入多行编辑模式), 写了几行代码以后要运行的话, 就按两次回车, 或者按&lt;code&gt;Shift+Enter&lt;/code&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;...还有好多快捷键, 按Esc以后再按h就可以看到... 这个还分编辑模式和命令模式呢... 真不能小看了IPython了!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="IPython上手学习笔记/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;h2&gt;customizing IPython&lt;/h2&gt;
&lt;p&gt;保存自己的IPython配置文件, 只需要在shell/cmd里输入ipython profile create&lt;code&gt;,&lt;/code&gt; 配置文件存储在 &lt;code&gt;~.ipython&lt;/code&gt; 或者 &lt;code&gt;~/.config/ipython&lt;/code&gt;目录里.&lt;/p&gt;
&lt;h1&gt;ch2: Interavtive Work with IPython&lt;/h1&gt;
&lt;p&gt;IPython可以实现&lt;strong&gt;shell(OS)和python的交互&lt;/strong&gt;. 这样做一些unix shell的操作的时候可以不必退出console了.&lt;/p&gt;
&lt;h2&gt;navigating the file system&lt;/h2&gt;
&lt;p&gt;例子: 完成下载压缩包, 解压缩, 以及打开解压后的文件这些操作...&lt;/p&gt;
&lt;p&gt;在py变量前面加入$, 可以把这个变量共享给OS或者magic command:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;folder&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="nf"&gt;%mkdir&lt;/span&gt; &lt;span class="n"&gt;$folder&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就在当前目录下建立一个'data'文件夹 — 这可比py的命令好记多了啊... &lt;code&gt;%mkdir&lt;/code&gt;的原理其实是给了shell命令一个别名(&lt;code&gt;alias&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;然后, &lt;code&gt;%bookmark&lt;/code&gt;可以把当前的目录加入收藏夹 下次cd的时候方便直接跳到这里来:&lt;/p&gt;
&lt;p&gt;ex.
&lt;code&gt;%bookmark bm&lt;/code&gt;
那么以后可以直接用 &lt;code&gt;cd bm&lt;/code&gt; 跳到这个目录下. &lt;code&gt;%bookmark -l&lt;/code&gt; 可以列出收藏夹的目录内容.&lt;/p&gt;
&lt;p&gt;然后发现原来IPython连文件名都是可以提示的啊!... &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;with open(&amp;#39;0&amp;lt;TAB&amp;gt;
0.circles 0.edges
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Accessing system shell with IPython&lt;/h2&gt;
&lt;p&gt;在IPython里调用系统的命令, 不用再使用&lt;code&gt;sys.exec('...')&lt;/code&gt;之类冗长的方式了, 只需要在系统的命令前面加上一个感叹号&lt;code&gt;!&lt;/code&gt;即可...&lt;/p&gt;
&lt;p&gt;shell返回的结果可以作为一个string的列表保存在一个python variable里.&lt;/p&gt;
&lt;p&gt;ex. &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;In [2]: files = !ls -1 -S | grep edges
In [3]: files
Out[3]: [&amp;#39;1912.edges&amp;#39;,
    &amp;#39;107.edges&amp;#39;,
    [...]
    &amp;#39;3980.edges&amp;#39;]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(当然 上面这一行只能在unix系统下运行, 因为Windows的cmd没有ls 和 grep命令)&lt;/p&gt;
&lt;p&gt;还可以把一条比较长的命令作为alias保存起来, 用&lt;code&gt;%alias&lt;/code&gt;命令... (这个应该一般用不到)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%alias largest ls -1sSh | grep %s&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;The Extended Python Console&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%history&lt;/code&gt; 或者 &lt;code&gt;%hist&lt;/code&gt; , 显示之前的记录, 有一些参数可用...&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%store&lt;/code&gt; 把python变量的内容保存下来, 以后的session可以用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%paste&lt;/code&gt; 导入并执行剪贴板里面的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%run&lt;/code&gt; 之前讲过了, 运行py文件, 运行后py文件里的变量可以在console里访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%edit&lt;/code&gt; 打开系统的文件编辑器, 并且在关闭这个编辑器时自动运行程序&lt;/li&gt;
&lt;li&gt;介绍了一个包 networkx, 可以用来分析复杂网络(graph)的....&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;debug&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;debug加入断点: &lt;code&gt;%run -d -b29 script.py&lt;/code&gt; 运行script.py 并且在29行的时候暂停, 当输入&lt;code&gt;c&lt;/code&gt;的时候再继续运行.&lt;/li&gt;
&lt;li&gt;一些pdb(debugging环境)里常用的命令:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;u/d&lt;/code&gt; for going up/down into the call stack&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; to step into the next statement&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; to continue execution until the next line in the current function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; to continue execution until the current function returns&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; to continue execution until the next breakpoint or exception&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; to evaluate and print any expression&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; to obtain the arguments of the current functions&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;!&lt;/code&gt; prefix to execute any Python command within the debugger&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;benchmarking("基准测试")&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%timeit fun()&lt;/code&gt; 测试一个&lt;strong&gt;函数&lt;/strong&gt;的执行速度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%run -t&lt;/code&gt;和&lt;code&gt;%timeit&lt;/code&gt;效果类似, 作用是测试一个py脚本&lt;strong&gt;文件&lt;/strong&gt;的执行速度&lt;/li&gt;
&lt;li&gt;更精细的运行时间测试, 可以用&lt;strong&gt;profile模块&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The profiler outputs details about calls of every Python function used directly or indirectly in this script.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;@@...好高级!!! 这样的话就更容易发现程序运行的瓶颈在哪里了!
方法是使用 &lt;code&gt;%run -p&lt;/code&gt; 或者 &lt;code&gt;%prun&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Using the IPython notebook&lt;/h2&gt;
&lt;p&gt;这个notebook的功能实在是很NB... 不仅可以加入代码/markdown段落, 还可以加入图片和视频... notebook的格式为.ipybn文件, 用JSON存储数据.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;输入 &lt;code&gt;ipython notebook&lt;/code&gt;(或者在ipython里输入&lt;code&gt;!ipython notebook&lt;/code&gt;)以后, 会在8888端口建立一个web server, 访问 &lt;a href="http://localhost:8888/"&gt;http://localhost:8888/&lt;/a&gt; 就可以看到上面的那个截图, 或者称之为&lt;strong&gt;notebook dashboard.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;cell magics&lt;/strong&gt;的作用域是整个cell(多行), 而magic command的作用域是一行, cell magics的前缀是两个百分号&lt;code&gt;%%&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从一个py文件直接建立一个notebook, 只需要把文件拖入dashboard即可, 然后notebook也可以保存为文件. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编辑了Markdown以后, 还是&lt;code&gt;Ctrl+Enter/Shift+Enter&lt;/code&gt; , 即可成为格式化的文本, 再双击就可以编辑!!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;让plot的图片直接嵌入在notebook里面: 使用&lt;code&gt;ipython notebook --pylab inline&lt;/code&gt;, 或者在notebook里面输入&lt;code&gt;%pylab inline&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="IPython上手学习笔记/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;h3&gt;notebook的一些快捷键&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Esc从编辑模式(edit mode)退出到命令模式(command mode)&lt;/li&gt;
&lt;li&gt;Enter从命令模式到编辑模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;(编辑模式下)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ctrl+Enter: 运行程序/markdown代码&lt;/li&gt;
&lt;li&gt;shift+Enter: 运行程序, 并自动跳到下一个cell&lt;/li&gt;
&lt;li&gt;alt+Enter: 运行程序, 并自动在后面新建一个cell在&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;(命令模式下)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;c: 复制一个cell&lt;/li&gt;
&lt;li&gt;x: 剪切一个cell&lt;/li&gt;
&lt;li&gt;v: 粘贴cell&lt;/li&gt;
&lt;li&gt;a: 在当前cell上面(&lt;strong&gt;a&lt;/strong&gt;bove)新建一个cell&lt;/li&gt;
&lt;li&gt;b: 在当前cell下面(&lt;strong&gt;b&lt;/strong&gt;elow)新建一个cell&lt;/li&gt;
&lt;li&gt;m: 让当前cell变成一个markdown的cell&lt;/li&gt;
&lt;li&gt;y: 让当前cell变成code的cell&lt;/li&gt;
&lt;li&gt;1,2,3...: n级标题&lt;/li&gt;
&lt;li&gt;j,k: 上下移动选中的cell, vim风格..&lt;/li&gt;
&lt;li&gt;dd(d按两下): 删除一个cell(vim 风格...)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;......爽到爆!!&lt;/p&gt;</summary><category term="python"></category></entry><entry><title>pandas学习笔记</title><link href="http://x-wei.github.io/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate"></link><updated>2014-07-22T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/pandas学习笔记.html</id><summary type="html">&lt;p&gt;首先, 导入pandas
&lt;code&gt;import pandas as pd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以及开启pylab: IPython里输入&lt;code&gt;%pylab&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.bearrelroll.com/2013/05/python-pandas-tutorial/"&gt;http://www.bearrelroll.com/2013/05/python-pandas-tutorial/&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;基本操作&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://cloga.info/python/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/2013/09/17/pandas_intro/"&gt;http://cloga.info/python/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/2013/09/17/pandas_intro/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pandas和numpy的关系&lt;/strong&gt;: pandas是建立在numpy上面的, pandas可以处理不同类型的数据集合(heterogeneous data set: &lt;strong&gt;DataFrame&lt;/strong&gt;), numpy处理的是相同类型的数据集合(homogeneous data set: &lt;strong&gt;ndarray&lt;/strong&gt;)&lt;/p&gt;
&lt;h2&gt;读写csv文件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;read_csv()&lt;/strong&gt;
&lt;code&gt;df=pd.read_csv('data.csv')&lt;/code&gt;
说一下数据类型的问题: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回类型数据帧(&lt;strong&gt;DataFrame&lt;/strong&gt;): &lt;code&gt;type(df) = pandas.core.frame.DataFrame&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;df.columns&lt;/code&gt;包含了所有列的标签(&lt;em&gt;字段名&lt;/em&gt;)
&lt;code&gt;df.index&lt;/code&gt;包含了所有行的标签(可能没有的话, 就是一系列递增的数字了)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但是其中的每一列是&lt;strong&gt;Series&lt;/strong&gt;类型: &lt;code&gt;type(df.dep)=pandas.core.series.Series&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后可以将Series转换为numpy的ndarray: &lt;code&gt;array(df.dep)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;to_csv()&lt;/strong&gt;
没啥好说的..
&lt;code&gt;df.to_csv('csvfilename')&lt;/code&gt;
要是不希望把index也作为一列写进csv文件的话, 就选择参数&lt;code&gt;index=False&lt;/code&gt;
&lt;a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_csv.html?highlight=to_csv#pandas.DataFrame.to_csv"&gt;http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_csv.html?highlight=to_csv#pandas.DataFrame.to_csv&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;indexing &amp;amp; slicing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;选择一列: &lt;code&gt;df['dep']&lt;/code&gt; 或者&lt;code&gt;df.dep&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选择前3行(前三条记录): &lt;code&gt;df[:2]&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用标签选取数据&lt;/strong&gt;: &lt;code&gt;df.loc[行标签, 列标签]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选择前两列:
&lt;code&gt;df.loc[:,('one','two')]&lt;/code&gt;
或者用
&lt;code&gt;df.loc[:,df.columns[:2]]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用位置选取数据&lt;/strong&gt;: &lt;code&gt;df.iloc[行位置, 列位置]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;df.iloc[:,:2]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自动判断的切片&lt;/strong&gt;: &lt;code&gt;df.ix[行位置或行标签, 列位置或列标签]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以前面俩基本用不着了...&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;df.ix[:,(&amp;#39;one&amp;#39;,&amp;#39;two&amp;#39;)]
df.ix[:,:2]
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;boolean indexing&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex. 选择dep是'PAR'的记录
&lt;code&gt;hk[hk.dep == 'PAR'].head()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ex. 多个条件, 比如dep是'PAR', dst是'BHM':
&lt;code&gt;hk[(hk.dep == 'PAR')&amp;amp;(hk.dst=='BHM')].head()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 中括号里面的表达式, 每一个条件需要括号括起来, 中间的&lt;code&gt;&amp;amp;&lt;/code&gt;不能用&lt;code&gt;and&lt;/code&gt;, 等于号&lt;code&gt;==&lt;/code&gt;不能用&lt;code&gt;is&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;文档里的一个表格:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置小数精度&lt;/strong&gt;
&lt;a href="http://pandas.pydata.org/pandas-docs/stable/options.html?highlight=precision"&gt;http://pandas.pydata.org/pandas-docs/stable/options.html?highlight=precision&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设置小数点后六位的精度: 
&lt;code&gt;pd.set_option('precision',7)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意六位精度的话要设置precision为7=6+1.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调整某一列的次序&lt;/strong&gt;
&lt;code&gt;df.reindex(columns=pd.Index(['x', 'y']).append(df.columns - ['x', 'y']))&lt;/code&gt;
&lt;a href="http://stackoverflow.com/questions/12329853/how-to-rearrange-pandas-column-sequence"&gt;http://stackoverflow.com/questions/12329853/how-to-rearrange-pandas-column-sequence&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随机抽取几行&lt;/strong&gt;
    rand_idx = random.choice(df.index,9, replace=False) #要设置replace = False以防止重复!
    df.ix[rand_idx]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两个df相merge&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个df的column都一样, index不重复(增加行):&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;pd.concat([df1,df2])&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个df的index一样, column不同(增加列)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;pd.concat([df1,df2], axis = 1)&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;adding/deleting columns&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://pandas.pydata.org/pandas-docs/stable/dsintro.html#column-selection-addition-deletion"&gt;http://pandas.pydata.org/pandas-docs/stable/dsintro.html#column-selection-addition-deletion&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建一列, 加到最后面:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;df['new_col']=xxx&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想要把一列插进中间某一处, 使用df.insert:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;df.insert(1, 'bar', df['one'])&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除一列, 只需用 &lt;code&gt;del&lt;/code&gt; 关键字:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;del df['one_col']&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个Series组成一个dataframe:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;pd.concat([s1, s2], axis=1)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重命名一列:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;df=df.rename(columns = {'old_name':'new_name'})&lt;/code&gt;
或者:
&lt;code&gt;df.rename(columns = {'old_name':'new_name'}, inplace=True)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/20868394/changing-a-specific-column-name-in-pandas-dataframe"&gt;http://stackoverflow.com/questions/20868394/changing-a-specific-column-name-in-pandas-dataframe&lt;/a&gt;
&lt;a href="http://www.bearrelroll.com/2013/05/python-pandas-tutorial/"&gt;http://www.bearrelroll.com/2013/05/python-pandas-tutorial/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;apply() &amp;amp; map() &amp;amp; agg()&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;apply()&lt;/strong&gt;
对dataframe的内容进行批量处理, 这样要比循环来得快. 
&lt;code&gt;df.apply(func, axis=0,...)&lt;/code&gt;
&lt;code&gt;func&lt;/code&gt;: 定义的函数
&lt;code&gt;axis&lt;/code&gt;: =0的时候对列操作, =1的时候对行操作
ex.
&lt;code&gt;df.apply(self, func, axis=0,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;map()&lt;/strong&gt;
和python内建的没啥区别
&lt;code&gt;df['one'].map(sqrt)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;groupby()&lt;/strong&gt;
按照某一列(&lt;em&gt;字段&lt;/em&gt;)分组, 得到一个&lt;code&gt;DataFrameGroupBy&lt;/code&gt;对象. 之后再对这个对象进行分组操作, 如:
    df.groupby(['A','B']).sum()##按照A、B两列的值分组求和
    groups = df.groupby('A')#按照A列的值分组求和
    groups['B'].sum()##按照A列的值分组求B组和
    groups['B'].count()##按照A列的值分组B组计数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;agg()&lt;/strong&gt;
对分组的结果再分别进行不同的操作... 参数是一个dict, 把每个字段映射到一个函数上来...... 说的不清楚, 直接看例子: 
    In [82]: df
    Out[82]: 
           one  two  three
    index               &lt;br /&gt;
    a        1    1      2
    b        2    2      4
    c        3    3      6
    d      NaN    4    NaN&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;In [83]: g=df.groupby(&amp;#39;one&amp;#39;)

In [84]: g.agg({&amp;#39;two&amp;#39;: sum,&amp;#39;three&amp;#39;: sqrt})
Out[84]: 
     two     three
one               
1      1  1.414214
2      2  2.000000
3      3  2.449490
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;甚至还可以对每一列进行多个处理操作:
    In [100]: g.agg({'two': [sum],'three': [sqrt,exp]})
    Out[100]: 
         two     three          &lt;br /&gt;
         sum      sqrt         exp
    one                         &lt;br /&gt;
    1      1  1.414214    7.389056
    2      2  2.000000   54.598150
    3      3  2.449490  403.428793&lt;/p&gt;
&lt;p&gt;具体见: &lt;a href="http://stackoverflow.com/questions/14529838/apply-multiple-functions-to-multiple-groupby-columns"&gt;http://stackoverflow.com/questions/14529838/apply-multiple-functions-to-multiple-groupby-columns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;统计出现频率&lt;/strong&gt;
方法1: 
&lt;code&gt;_hkhist=hk.groupby(groups).count().ix[:,0]#count of groupes&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;方法2:
&lt;code&gt;hk.groupby('dep').size()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法3:
(只适用于一列的情况)
&lt;code&gt;hk.dep.value_counts()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;把一列index转为column(不再作为index使用)&lt;/strong&gt;
&lt;a href="http://stackoverflow.com/questions/20461165/how-to-convert-pandas-index-in-a-dataframe-to-a-column"&gt;http://stackoverflow.com/questions/20461165/how-to-convert-pandas-index-in-a-dataframe-to-a-column&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比如, 原来的dataframe是三层index的, column只有一列(名字叫做'0'):&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;df.reset_index(level=2,inplace=True)&lt;/code&gt;
这样就可以把第三层的内容作为使用, 而不是作为index, 现在column有两列了, 再给两列命名一下:
&lt;code&gt;hist_hub.columns = ['hub','occurrence']&lt;/code&gt;
就得到了:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;p&gt;关于level这个参数:
level : int, str, tuple, or list, default None
Only remove the given levels from the index. Removes all levels by default&lt;/p&gt;
&lt;h2&gt;Plotting&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://cloga.info/python/2014/02/23/Plotting_with_Pandas/"&gt;http://cloga.info/python/2014/02/23/Plotting_with_Pandas/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;统计出现次数, 画柱状图:&lt;/strong&gt;
    g=hk.groupby('dep')
    dd=g['dst'].count()
    dd.plot(kind='bar')&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/pasted_image.png" /&gt;
或者用pandas提供的:
&lt;a href="http://pandas.pydata.org/pandas-docs/stable/basics.html#value-counts-histogramming-mode"&gt;http://pandas.pydata.org/pandas-docs/stable/basics.html#value-counts-histogramming-mode&lt;/a&gt;
nb=hk['#vol_hacker']
hist=nb.value_counts()*100.0/len(hk)
hist=hist.sort_index()
hist.plot(kind='bar')&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;积累分布曲线&lt;/strong&gt;
&lt;a href="http://stackoverflow.com/questions/6326360/python-matplotlib-probability-plot-for-several-data-set"&gt;http://stackoverflow.com/questions/6326360/python-matplotlib-probability-plot-for-several-data-set&lt;/a&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;counts, start, dx, _ = scipy.stats.cumfreq(data, numbins=20)
x = np.arange(counts.size) * dx + start
plt.plot(x, counts, &amp;#39;ro&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者用pandas提供的东西也能做吧:
&lt;a href="http://pandas.pydata.org/pandas-docs/stable/basics.html#discretization-and-quantiling"&gt;http://pandas.pydata.org/pandas-docs/stable/basics.html#discretization-and-quantiling&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hist2d&lt;/strong&gt;
用pcolormesh
&lt;a href="http://www.physicsforums.com/showthread.php?t=653864"&gt;http://www.physicsforums.com/showthread.php?t=653864&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;貌似要转置!!
&lt;a href="http://stackoverflow.com/questions/24791614/numpy-pcolormesh-typeerror-dimensions-of-c-are-incompatible-with-x-and-or-y"&gt;http://stackoverflow.com/questions/24791614/numpy-pcolormesh-typeerror-dimensions-of-c-are-incompatible-with-x-and-or-y&lt;/a&gt;&lt;/p&gt;</summary><category term="pandas"></category><category term="python"></category></entry><entry><title>Eclipse快捷键总结</title><link href="http://x-wei.github.io/Eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93.html" rel="alternate"></link><updated>2014-07-15T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/Eclipse快捷键总结.html</id><summary type="html">&lt;p&gt;Eclipse让我很喜欢的最大原因大概就是它的好用的快捷键了, 这里进行一下总结, 掌握这些快捷键可以让编辑代码变得更加高效. &lt;/p&gt;
&lt;h2&gt;基本快捷键&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;格式化代码: &lt;code&gt;ctrl+alt+F&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非常实用的快捷键, 暂时还不知道别的编辑器还没有发现有同样功能的. 按一下代码就自动缩进得非常整齐了! &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注释/反注释: &lt;code&gt;ctrl+alt+C&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;pydev下面的注释/反注释: &lt;code&gt;ctrl+/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;另外一些有用的快捷键&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;显示提示: &lt;code&gt;alt+/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个可以说是eclipse快捷键里面最有用的一个. 可以显示代码提示的窗口, 这也是我喜欢eclipse的原因之一. 虽然编写代码的时候eclipse的提示框也会在适当的时候出来, 比如按下了&lt;code&gt;.&lt;/code&gt;的时候, 但是当它没有出现的时候我们总可以按下&lt;code&gt;alt+/&lt;/code&gt;让提示框弹出来. 尤其在使用Java的时候, eclipse的提示相当智能, 也就是说会根据上下文以及函数的定义等东西来提示那些可能出现的项目. 另外, 有时候可能定义了一个超长名字的变量(这样代码可能比较清楚一些), 然后用这个快捷键, 就只需要打一下这个很长名字的前几个字母就可以自动补全了(如果补全的不是想要的, 只需要多按几次这个快捷键就会显示其他可能了)! &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开函数/变量的声明: &lt;code&gt;F3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比方说在程序的某一段看到了调用一个函数, 然后想看看这个函数的内容, 这是不需要拿着鼠标上下滚动着找(有时候定义的函数可能在另一个文件里, 那就更难找了), 只需要按下&lt;code&gt;F3&lt;/code&gt;, 就会自动跳转到函数的声明的代码片段里. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行程序: &lt;code&gt;ctrl+F11&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;显示eclipse提供的解决方案: &lt;code&gt;ctrl+1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如说, 有时候可能一个变量的名字拼错了, 或者是忘记了导入相应的一个package, 所以在变量下面有红线. 而这时其实eclipse可以提供一些解决方案, 比如修改拼写或者import package, 要查看eclipse提供的解决方案, 只需要把光标移动到画红线的部分, 然后按一下&lt;code&gt;ctrl+1&lt;/code&gt;就好了. &lt;/p&gt;
&lt;h2&gt;其他一些快捷键&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;复制上一行代码: &lt;code&gt;ctrl+alt+down&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在写那些好几行比较相似的代码时有点用处. 不过linux的用户有些可能不能用 — 和那个跳到下一个工作区的快捷键重复了...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跳转到下一个/上一个函数/类: &lt;code&gt;ctrl+shift+down/up&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在光标在某一个函数里, 想跳到下一个函数的时候, 按半天的向下按钮不如这个来得快~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动导入package: &lt;code&gt;ctrl+shift+o&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如写Java代码的时候, 开始没有import &lt;code&gt;LinkedList&lt;/code&gt;这个包, 写到一半突然要用到了, 那么先写上, 然后不用再回到开头加上导入LinkedList的语句, 而只要按一下这个组合键就可以了. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示outline: &lt;code&gt;ctrl+o&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按下以后, 显示outline视图, 这个视图上看类的成员和函数很一目了然&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重命名: &lt;code&gt;shift+alt+r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eclipse的重命名和简单的查找替换还是不一样的, 它可以在替换正确的那些命名而不是全部查找替换. 比如重命名一个函数内部的变量的话, 外部即使有重名的也不会影响到. 
要是这个快捷键记不住, 就用menu(键盘右边的ctrl的左边)==&amp;gt; refactoring...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找下一处出现的地方: &lt;code&gt;ctrl+k&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有时候也用得着.&lt;/p&gt;</summary><category term="eclipse"></category></entry><entry><title>Eclipse插件推荐</title><link href="http://x-wei.github.io/Eclipse%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90.html" rel="alternate"></link><updated>2014-07-15T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/Eclipse插件推荐.html</id><summary type="html">&lt;p&gt;Eclipse被称为编程的瑞士军刀, 意思就是只用一个eclipse就可以做很多事情. &lt;/p&gt;
&lt;p&gt;最近越来越喜欢eclipse了, 因为作为编辑器而言, eclipse的编辑器让我用起来最舒服的一个(配合一些&lt;a href="x-wei.github.com/Eclipse快捷键总结.html"&gt;快捷键&lt;/a&gt;以后更是非常爽). 这半年多来发现了一些非常好用的eclipse的插件, 有了这些插件, eclipse可以做更多的事情... 接下来简单介绍一下:&lt;/p&gt;
&lt;h2&gt;插件安装的方法&lt;/h2&gt;
&lt;p&gt;先简单说一下eclipse的插件安装方法, 在eclispe界面上, 点击: Help-&amp;gt;Install New Software:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./Eclipse插件推荐/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;之后添加对应的URL就可以了... &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./Eclipse插件推荐/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;h1&gt;ADT&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://developer.android.com/sdk/installing/installing-adt.html"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;eclipse里添加的URL: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://dl-ssl.google.com/android/eclipse/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个不用说了吧, Eclipse已经基本上是android开发的御用IDE了. &lt;/p&gt;
&lt;h2&gt;PyDev&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://pydev.org/"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;URL:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;http://pydev.org/updates&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;python的开发更需要有一个提示的东东(好像叫pyLint, 就是可以发现代码里的一些显然的错误), 这个插件装好以后我就很少用geany写python程序了, 尤其是当程序超过100行以后... &lt;/p&gt;
&lt;p&gt;但是让人不爽的是, 他需要新建一个project才能运行. 这也是Eclipse的一个让人不爽的方面. 如果是一个小的python程序的话我还是会用geany. 另外, 强烈推荐&lt;a href="http://bpython-interpreter.org/"&gt;bpython&lt;/a&gt;作为python的terminal, 非常爽快!!&lt;/p&gt;
&lt;h2&gt;color theme&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.07net01.com/linux/Eclipsexiapeizhizhutiyanse_Eclipse_jiqiao_9354_1344993754.html"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;URL:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;http://eclipse-color-theme.github.com/update&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改配色的一个插件, 非常喜欢, 因为默认的配色看的时间长了眼睛就不舒服... 有多种配色方案可选. &lt;/p&gt;
&lt;h2&gt;jigloo&lt;/h2&gt;
&lt;p&gt;这是当年学java GUI编程的时候用到的, 可以拖放着来写Swing/AWT的GUI代码... 有点像现在ADT设计界面的东西... &lt;/p&gt;
&lt;p&gt;不过我不喜欢写java的GUI... 乱糟糟的...&lt;/p&gt;
&lt;p&gt;做这个的机构已经很久没有更新了... 不过2010年的版本现在用还是没有问题的. &lt;/p&gt;
&lt;h2&gt;greenUML&lt;/h2&gt;
&lt;p&gt;这个之前的&lt;a href="http://x-wei.github.io/%E4%BD%BF%E7%94%A8Eclipse%E7%9A%84UML%E6%8F%92%E4%BB%B6%E7%94%9F%E6%88%90%E7%B1%BB%E5%9B%BE.html"&gt;帖子&lt;/a&gt;已经介绍了, 写报告的时候可以用一用...&lt;/p&gt;
&lt;h2&gt;xmind&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://jeljo.wordpress.com/2012/02/11/xmind-on-eclipse/"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个"插件"已经作为一个独立的软件了... 用来画思维导图的工具, 蛮好用的.&lt;/p&gt;
&lt;p&gt;作为一个独立的软件下载的话, 去&lt;a href="http://www.xmind.net/"&gt;这里&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;TeXlipse&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://texlipse.sourceforge.net/index.php"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;URL:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;http://texlipse.sourceforge.net/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没错! Eclipse也可以写tex的...&lt;/p&gt;
&lt;p&gt;不过这个我装了但是没有用(因为发现它的时候报告已经写好了...). 貌似也可以实时预览的, 再加上eclipse的编辑器的提示功能, 应该不错!&lt;/p&gt;
&lt;h2&gt;设置代理&lt;/h2&gt;
&lt;p&gt;X是个神奇的学校, 所以上网要设置代理..... 关于设置代理的问题在之前一篇帖子里提到了, 粘过来:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;window → preference → General → Network Connections&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="" src="./eclipse的UML插件/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;h2&gt;插件卸载的方法&lt;/h2&gt;
&lt;p&gt;说不定哪一天也会需要卸载插件, 卸载的方法是 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Help--&amp;gt; About Eclipse Platform--&amp;gt; Installation Details&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后再补充一句, Eclipse的最大优势是编辑器非常讨我喜欢, 但是缺点是在老机器上运行比较卡, 而且不管写什么都要先指定workspace以及建立一个project. 如果想要一把轻量级的"瑞士军刀"的话, geany是个不错的选择.&lt;/p&gt;</summary><category term="eclipse"></category></entry><entry><title>python pickle 的一个小问题</title><link href="http://x-wei.github.io/python%20pickle%20%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98.html" rel="alternate"></link><updated>2014-07-15T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/python pickle 的一个小问题.html</id><summary type="html">&lt;p&gt;python的pickle/unpickle机制可以非常方便的保存一些计算的中间结果, 这一点java虽然也可以做到, 但是java里面的包的名字实在是长的让人记不住...&lt;/p&gt;
&lt;p&gt;不过今天在使用pickle的时候遇到了一个很奇怪的问题. &lt;/p&gt;
&lt;p&gt;是这样的, 原本写了一个程序&lt;code&gt;main.py&lt;/code&gt;, 这个程序里进行了一些计算并且pickle下了这些内容, 后来我觉得一个程序main.py写这么多实在太长了, 于是就把那些辅助函数以及class的定义通通放进了一个&lt;code&gt;util.py&lt;/code&gt;文件里. 并且在main.py的第一行写上: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;from util import *&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按理说这应该没有问题, 和一个main文件时运行的效果相同的, 但是当我运行的时候却显示util.py里面这行unpickle的语句有错误:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="n"&gt;airport_info&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pk&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;airport_info.dict&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; 
    &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="ne"&gt;AttributeError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;module&amp;#39;&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt; &lt;span class="n"&gt;has&lt;/span&gt; &lt;span class="n"&gt;no&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Airport&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;code&gt;Airport&lt;/code&gt;是我定义的一个类, 本来在main.py里面, 后来被我移动到了util.py里面...&lt;/p&gt;
&lt;p&gt;感觉很奇怪, 于是去&lt;a href="https://bbs.sjtu.edu.cn/frame2.html"&gt;水源&lt;/a&gt;求助, 果然fcfarseer学长就很快给了&lt;a href="https://bbs.sjtu.edu.cn/bbscon,board,Script,file,M.1405431916.A.html"&gt;回复&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在pickle一個對象的時候，pickle會記住這個對象的class是定義在哪個python
源文件裏，然後再unpickle的時候，pickle會自動import那個源文件以獲得class的定義。&lt;/p&gt;
&lt;p&gt;所以如果定義class的文件在這期間改過的話，就會拋出類似的錯誤。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以问题出在这里(我的理解): 原先我把数据pickle进文件的时候, &lt;code&gt;Airport这个class是定义在了main.py里面, 所以当我在util.py里面load数据的时候, pickle发现原来的main.py里面已经没有了 Airport这个class, 于是就出现了Error...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决办法也不难, 只需要在&lt;code&gt;util.py&lt;/code&gt;里面再生成一下那些要load的数据文件, 之后再次unpickle的时候就会去&lt;code&gt;util.py&lt;/code&gt;而不是&lt;code&gt;main.py&lt;/code&gt;里找class的定义, 也就没有问题了!&lt;/p&gt;
&lt;p&gt;今天碰到的这个问题不是那么evident, 所以特地记一下.&lt;/p&gt;</summary><category term="python"></category></entry><entry><title>使用Eclipse的UML插件生成类图</title><link href="http://x-wei.github.io/%E4%BD%BF%E7%94%A8Eclipse%E7%9A%84UML%E6%8F%92%E4%BB%B6%E7%94%9F%E6%88%90%E7%B1%BB%E5%9B%BE.html" rel="alternate"></link><updated>2014-05-31T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/使用Eclipse的UML插件生成类图.html</id><summary type="html">&lt;p&gt;Created samedi 31 mai 2014UML就是可以把程序的结构用图的形式表达出来的东西(好像叫类图), 虽然写程序的时候不大会用到这种东西来搞, 但是写报告的时候如果能够加上一张图的话, 就可以少费些口舌来解释代码了, 而且还有一种高大上的赶脚... 所以写完程序写报告的时候可以用一下. &lt;/p&gt;
&lt;p&gt;废话不多说, 看看我最后生成的UML图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./eclipse的UML插件/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;这张图表示一个抽象类&lt;code&gt;Operration&lt;/code&gt;有三个子类, 然后他们之间的关系... 如果用文字的话要解释半天吧...&lt;/p&gt;
&lt;p&gt;这张图是用&lt;a href="http://green.sourceforge.net/"&gt;Green UML&lt;/a&gt;做出来的, 这是一个eclipse插件, 安装方法为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在eclipse里, &lt;code&gt;Help-&amp;gt;Install New Software&lt;/code&gt; 然后Add这个URL: &lt;a href="http://www.cse.buffalo.edu/faculty/alphonce/green"&gt;http://www.cse.buffalo.edu/faculty/alphonce/green&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;然后一路Next安装就可以了...&lt;/li&gt;
&lt;li&gt;如果老师显示pending, 可能是代理的问题(在X非常不爽的一点...哎...), 不过没事, 代理的设置在: &lt;code&gt;window → preference → General → Network Connections&lt;/code&gt;, 填上就应该好了...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./eclipse的UML插件/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用Green UML生成类图的时候, 在java文件上点击右键, 选项里有Green UML的选项:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./eclipse的UML插件/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;然后就OK了...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外还在网上找到了&lt;a href="http://www.modelgoon.org/"&gt;model goon&lt;/a&gt;, 不过它生成的类图貌似没有把所有信息都标上, 而且不太好看...&lt;/p&gt;</summary><category term="java"></category><category term="eclipse"></category></entry><entry><title>A French Input Method</title><link href="http://x-wei.github.io/fr-input.html" rel="alternate"></link><updated>2014-05-23T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/fr-input.html</id><summary type="html">&lt;h2&gt;Well, to be brief...&lt;/h2&gt;
&lt;p&gt;I made a french input method, if you got annoyed by the freaking french keyboard when typing accented words (i.e.  &lt;strong&gt;é, û, ü, î,...&lt;/strong&gt; ), or you are using a QWERTY keyboard, this will be quite useful !&lt;/p&gt;
&lt;p&gt;In fact, I used &lt;a href="http://yong.dgod.net/"&gt;XiaoxiaoInput&lt;/a&gt; and &lt;a href="https://fcitx-im.org/wiki/Fcitx"&gt;Fcitx&lt;/a&gt;, which are 2 excellent Chinese input methods, I just made a french word table, and added it to the program...&lt;/p&gt;
&lt;h2&gt;screenshot:&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;linux version:&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./fr-input/sc-linux0.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;windows version:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./fr-input/sc-win.png" /&gt;&lt;/p&gt;
&lt;h2&gt;how to use&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;download the zip file (see the links below)&lt;/li&gt;
&lt;li&gt;unzip the file&lt;/li&gt;
&lt;li&gt;if you are using 32-bit system, cilck the  &lt;code&gt;/yong.exe,&lt;/code&gt; if you in 64-bit system, click  &lt;code&gt;/w64/yong.exe&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;you can see a round french flag icon in the right-bottom corner&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./fr-input/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;click the icon, or press &lt;code&gt;ctrl+space&lt;/code&gt;, you can see the icon become brighter, which means the input method is active &lt;/li&gt;
&lt;li&gt;in the meantime, you can also see a small panel appear in the right-bottom corner with a french flag at left:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./fr-input/pasted_image.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;you can type french with the input method now,  &lt;strong&gt;enjoy&lt;/strong&gt; !&lt;/li&gt;
&lt;li&gt;choose the words by pressing the corresponding &lt;code&gt;number button&lt;/code&gt;, or press &lt;code&gt;space&lt;/code&gt; key to choose the first candidate&lt;/li&gt;
&lt;li&gt;sometimes there are &amp;gt;9 candidates, to see more candidates, use &lt;code&gt;-/=&lt;/code&gt; to flip pages forward and backward&lt;/li&gt;
&lt;li&gt;if you want to input what you type instead of the candidates in the list, just press &lt;code&gt;Enter&lt;/code&gt; button&lt;/li&gt;
&lt;li&gt;if you want to change to normal keyboard, you can press &lt;code&gt;LeftShift&lt;/code&gt;, and you can see that the icon in the panel become a icon of a keyboard:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./fr-input/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;or you can just press &lt;code&gt;ctrl+space&lt;/code&gt;, to disable the input method (then the round flag icon become dark again, indicating it's not active)&lt;/li&gt;
&lt;li&gt;or you can right-click the round flag icon to totaly exit the program:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./fr-input/pasted_image005.png" /&gt;&lt;/p&gt;
&lt;h2&gt;dowload links&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;windows&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;(adapted from Xiaoxiao Input)&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sourceforge.net/projects/frinput/files/latest/download?source=files"&gt;link1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://filemarkets.com/fs/djd4dyamxb20371/"&gt;link2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;linux&lt;/strong&gt; .&lt;/p&gt;
&lt;p&gt;(adapted from Fcitx)&lt;/p&gt;
&lt;p&gt;see &lt;a href="https://github.com/X-Wei/fcitx-table-french"&gt;here&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mac&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;I haven't made the mac version yet...&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./fr-input/doge.jpg" /&gt;&lt;/p&gt;</summary><category term="fr"></category></entry><entry><title>A byte of Python 笔记</title><link href="http://x-wei.github.io/byte_of_python%E7%AC%94%E8%AE%B0.html" rel="alternate"></link><updated>2014-04-10T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/byte_of_python笔记.html</id><summary type="html">&lt;p&gt;据说这本书是最好的入门读物, 况且只有100来页 (减掉前面后面那些扯淡的 不到100页...)&lt;/p&gt;
&lt;p&gt;那就用这本书过一下py的基本知识点吧! 看完以后收获不少, 把py涉及的很大一部分都讲到了. 这本书已经是够压缩的了, 不过我还是边看边自己再压缩了一遍(写在zim笔记里). &lt;/p&gt;
&lt;p&gt;我看的是1.20版本, 2004年的, 因为这个版本针对的是py2.x, 作者主页上现在的版本针对的是py3. 另外感觉没必要看中文翻译版, 因为这里用的英语比较简单, 而且有的时候中文翻译反而不如原文表达的恰当.&lt;/p&gt;
&lt;h1&gt;preface+ch1+ch2&lt;/h1&gt;
&lt;p&gt;扯淡...&lt;/p&gt;
&lt;h1&gt;ch3. First Steps&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;There are two ways of using Python to run your program - using the interactive interpreter prompt or using a source file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Anything to the right of the # symbol is a comment.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;the shebang line&lt;/strong&gt; - whenever the first two characters of the source file are &lt;code&gt;#!&lt;/code&gt; followed by the location of a program, this tells your Linux/Unix system that this program should be run with this interpreter when you execute the program.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Note that you can always run the program on any platform by specifying the interpreter directly on the command line such as the command python helloworld.py .)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use the built-in help functionality.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;or example, run &lt;code&gt;help(str)&lt;/code&gt; - this displays the help for the str class which is used to store all text (strings) that you use in your program.&lt;/p&gt;
&lt;h1&gt;ch4. The Basics&lt;/h1&gt;
&lt;h2&gt;Literal Constants&lt;/h2&gt;
&lt;p&gt;It is called a literal because it is literal - you use its value literally. ex. number 2, or string "hello".&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;number&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Numbers in Python are of four types - integers, long integers, floating point and complex numbers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-Examples of floating point numbers (or floats for short) are 3.23 and 52.3E-4. The E notation indicates powers of 10. In this case, 52.3E-4 means 52.3 * 10-4.
-Examples of complex numbers are (-5+4j) and (2.3 - 4.6j)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;string可以用Single/Double/Triple Quotes括起来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;escape sequence&lt;/em&gt;: \', \n, \t, 以及在行末作为续行符号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;raw string&lt;/strong&gt;: to specify some strings where no special processing such as escape sequences are handled, then what you need is to specify a raw string by prefixing r or R to the string. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex. &lt;code&gt;r"Newlines are indicated by \n"&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;unicode text:  prefix u or U. For example, &lt;code&gt;u"This is a Unicode string."&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remember to use Unicode strings when you are dealing with text files, especially when you know that the file will contain text written in languages other than English.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Strings are immutable:  once you have created a string, you cannot change it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;String literal concatenation: If you place two string literals side by side, they are automatically concatenated by Python. For example, '&lt;code&gt;What\'s' 'your name?&lt;/code&gt;' is automatically converted in to &lt;code&gt;"What's your name?".&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Note for Regular Expression Users: Always use raw strings when dealing with regular expressions. Otherwise, a lot of backwhacking may be required. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Variables&lt;/h2&gt;
&lt;p&gt;顾名思义就是可以可以变的量...
Unlike literal constants, you need some method of accessing these variables &lt;em&gt;and hence you give them names&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Identifier(标示符)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Identifiers&lt;/strong&gt; are names given to identify something. 
The first character of the identifier must be a letter of the alphabet (upper or lowercase) &lt;em&gt;or an underscore ('_')&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Objects&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python refers to anything used in a program as an object.
Python is &lt;strong&gt;strongly object-oriented&lt;/strong&gt; in the sense that everything is an object &lt;em&gt;including numbers, strings and even functions&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Variables are used by just assigning them a value. No declaration or data type definition is needed/used.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Logical and Physical Lines: Implicitly, Python encourages the use of a single statement per line which makes code more readable. If you want to specify more than one logical line on a single physical line, then you have to explicitly specify this using a semicolon (;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;explicit line joining: ex. 续行符\;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;implicit line joining: ex. 括号...&lt;/p&gt;
&lt;h2&gt;Indentation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Leading whitespace (spaces and tabs) at the beginning of the logical line is used to determine the indentation level of the logical line, which in turn is used to determine the grouping of statements.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This means that statements which go together must have the same indentation. Each such set of state- ments is called a &lt;em&gt;block&lt;/em&gt;. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Do not use a mixture of tabs and spaces for the indentation as it does not work across different platforms properly. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ch5. Operators and Expressions&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;expressions&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An expression can be broken down into &lt;em&gt;operators&lt;/em&gt; and &lt;em&gt;operands&lt;/em&gt;. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一些oprators: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;**, //, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, |, ^, ~, not, and, or&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Operator Precedence: 优先级的一个表...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Associativity: &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Operators are usually associated from left to right i.e. operators with same precedence are evaluated in a left to right manner. For example, &lt;code&gt;2 + 3 + 4&lt;/code&gt; is evaluated as &lt;code&gt;(2 + 3) + 4&lt;/code&gt;. Some operators like assignment operators have right to left associativity i.e. &lt;code&gt;a = b = c&lt;/code&gt; is treated as &lt;code&gt;a = (b = c)&lt;/code&gt;.&lt;/p&gt;
&lt;h1&gt;ch6. Control Flow&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;if&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;if-elif-else&lt;/code&gt; statement: This makes the program easier and reduces the amount of indentation required. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;There is &lt;em&gt;no switch statement in Python:&lt;/em&gt; You can use an if..elif..else statement to do the same thing (and in some cases, use a dictionary to do it quickly)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;while&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remember that you can have &lt;em&gt;an &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; clause for the while loop&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-The &lt;code&gt;for..in&lt;/code&gt; statement is another looping statement which &lt;em&gt;iterates&lt;/em&gt; over a sequence of objects i.e. go
through each item in a sequence, a &lt;em&gt;sequence&lt;/em&gt; is just an ordered collection of items.
-optional &lt;strong&gt;else&lt;/strong&gt; part  also.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;break&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;to break out of a loop statement i.e. stop the execution of a looping statement, even if the loop condition has not become False or the sequence of items has been completely iterated over.
-An important note is that if you break out of a for or while loop, &lt;em&gt;any corresponding loop else block is &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; executed.&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;continue&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;used to tell Python to skip the rest of the statements in the current loop block and to continue to the &lt;em&gt;next iteration&lt;/em&gt; of the loop.&lt;/p&gt;
&lt;h1&gt;ch7. Functions&lt;/h1&gt;
&lt;p&gt;Functions are reusable pieces of programs. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;def func_name()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;parameters:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note the terminology used - the names given in the function definition are called &lt;em&gt;parameters(行参)&lt;/em&gt; whereas the values you supply in the function call are called &lt;em&gt;arguments(实参)&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;scope&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;local variables:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All variables have the &lt;strong&gt;scope&lt;/strong&gt; of the block they are declared in starting from the point of definition of the name.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;global variables&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you want to assign a value to a name defined outside the function, then you have to tell Python that the name is not local, but it is global. We do this using the &lt;code&gt;global&lt;/code&gt; statement. &lt;/p&gt;
&lt;h2&gt;Default Argument Values&lt;/h2&gt;
&lt;p&gt;Default Argument Values默认参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;You can specify default argument values for parameters by following the parameter name in the function definition with the assignment operator (=) followed by the default value.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Note that the default argument value should be &lt;em&gt;immutable.&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;you cannot have a parameter with a default argument value &lt;em&gt;before&lt;/em&gt; a parameter without a default argument value in the order of parameters declared in the function parameter list.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is because the values are &lt;em&gt;assigned to the parameters by position&lt;/em&gt;. For example, &lt;code&gt;def func(a, b=5)&lt;/code&gt; is valid, but &lt;code&gt;def func(a=5, b)&lt;/code&gt; is not valid.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Keyword Arguments&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you have some functions with many parameters and you want to specify only some of them, then you can give values for such parameters by naming them - this is called keyword arguments - we &lt;em&gt;use the name (keyword) instead of the position&lt;/em&gt; to specify the arguments to the function.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;return&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;used to &lt;em&gt;return&lt;/em&gt; from a function i.e. break out of the function. We can optionally return a value from the function as well.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;return None&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-a return statement without a value is equivalent to &lt;code&gt;return None&lt;/code&gt;. None is a special type in Python that represents nothingness. For example, it is used to indicate that a variable has no value if it has a value of None.
-Every function implicitly contains a return None statement at the end unless you have written your own return statement.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pass&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;the &lt;code&gt;pass&lt;/code&gt; statement is used in Python to indicate an empty block of statements.&lt;/p&gt;
&lt;h2&gt;DocStrings&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;A string on the first logical line of a function&lt;/em&gt; is the &lt;strong&gt;docstring&lt;/strong&gt; for that function (also apply to modules and classes). &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;func.__doc__&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The convention: a multi-line string where the first line starts with a capital letter and ends with a dot. Then the second line is blank followed by any detailed explanation starting from the third line. &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ch8. Modules&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;A module is basically &lt;strong&gt;a file&lt;/strong&gt;&lt;em&gt; containing all your functions and variables that you have defined&lt;/em&gt;. &lt;/li&gt;
&lt;li&gt;To reuse the module in other programs, the filename of the module must have a .py extension.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;ex. sys module&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;When Python executes the &lt;code&gt;import sys&lt;/code&gt; statement, it looks for the sys.py module in one of the directores listed in its &lt;code&gt;sys.path&lt;/code&gt; variable. If the file is found, then the statements in the main block of that module is run and then the module is made available for you to use.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;sys.argv&lt;/code&gt; variable is a list of strings, contains the list of command line arguments i.e. the arguments passed to your program using the command line. 即程序执行时传给的参数列表.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;sys.path&lt;/code&gt; contains &lt;em&gt;the list of directory names where modules are imported&lt;/em&gt; from. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Observe that the first string in sys.path is empty - this empty string indicates that &lt;em&gt;the current directory&lt;/em&gt; is also part of the sys.path which is same as the &lt;code&gt;PYTHONPATH&lt;/code&gt; environment variable. This means that you can directly import modules located in the current directory. Otherwise, you will have to place your module in one of the directories listed in sys.path .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Byte-compiled .pyc files&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Importing a module is a relatively costly affair.
This .pyc file is useful when you import the module the next time from a different program - it will be much faster since part of the processing required in importing a module is already done. Also, these byte-compiled files are platform-independent. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;from..import &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you want to directly import the &lt;code&gt;argv&lt;/code&gt; variable into your program (to avoid typing the &lt;code&gt;sys.&lt;/code&gt; everytime for it), then you can use the &lt;code&gt;from sys import argv&lt;/code&gt; statement.
not recommended...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__name__&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Every Python module has it's &lt;code&gt;__name__&lt;/code&gt; defined and if this is '&lt;code&gt;__main__&lt;/code&gt;', it implies that the module is being run standalone by the user and we can do corresponding appropriate actions.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every Python program is also a module. You just have to make sure it has a .py extension. &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;dir() function&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;You can use the built-in dir function to &lt;em&gt;list the identifiers&lt;/em&gt; that a module defines. The identifiers are the &lt;strong&gt;functions, classes, variables and imported modules&lt;/strong&gt; defined in that module.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When you supply a module name to the dir() function, it returns the list of the names defined in that module. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;When no argument is applied to it, it returns the list of names defined in the current module.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ch9. Data Structures&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Data structures are structures which can hold some data together. In other words, they are used to store a collection of related data.&lt;/li&gt;
&lt;li&gt;3 built-in data structures in Python - &lt;strong&gt;list, tuple and dictionary&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;List [a,b,c]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;a data structure that holds an ordered collection of items. &lt;/li&gt;
&lt;li&gt;a &lt;em&gt;mutable&lt;/em&gt; data type&lt;/li&gt;
&lt;li&gt;you can add any kind of object to a list including numbers and even other lists.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;indexing &lt;/em&gt;operator: &lt;code&gt;a_list[1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len(a_list)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a_list.append()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for..in&lt;/code&gt; loop to iterate through the items of the list&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a_list.sort()&lt;/code&gt;: this method affects the list itself and does not return a modified list&lt;/li&gt;
&lt;li&gt;&lt;code&gt;del a_list[0]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Tuple (a,b,c)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Tuples are just like lists except that they are &lt;strong&gt;immutable&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Tuples are usually used in cases where a statement or a user-defined function can safely assume that the collection of values (i.e. the tuple of values) used will not change.&lt;/li&gt;
&lt;li&gt;can contain another tuple, another list......&lt;/li&gt;
&lt;li&gt;singleton: &lt;code&gt;t=(2,)&lt;/code&gt;(comma is necessary!)&lt;/li&gt;
&lt;li&gt;empth: t=()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;indexing: a_touple[0]&lt;/li&gt;
&lt;li&gt;len(a_tuple)&lt;/li&gt;
&lt;li&gt;used for output format:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;print '%s is %d years old' % (name, age)&lt;/code&gt;&lt;/p&gt;
&lt;h2 k1:v1_="k1:v1," k2:v2="k2:v2"&gt;Dictionary&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;key-value mapping&lt;/li&gt;
&lt;li&gt;you can use only immutable objects (like strings) for the keys of a dictionary but you can use either immutable or mutable objects for the values of the dictionary. (This basically translates to say that you should use only simple objects for keys.)&lt;/li&gt;
&lt;li&gt;一个dict中的keys不必同样type, values也是! &lt;/li&gt;
&lt;li&gt;key/value pairs in a dictionary are &lt;em&gt;not ordered&lt;/em&gt; in any manner.&lt;/li&gt;
&lt;li&gt;instances/objects of the dict class.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;adding key-value pair by indexing: &lt;code&gt;dic[key]=val&lt;/code&gt;&lt;em&gt;(overwrite if key already exists!)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;deleting: &lt;code&gt;del dic[key]&lt;/code&gt;&lt;em&gt;(KeyError if key doesn't exist!)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dic.items()&lt;/code&gt;&lt;em&gt;返回一个list of tuples&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;dic.items()
[(k1,v1), (k2,v2)]
for k,v in dic.items:
    print k, v&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dic.keys()&lt;/code&gt;&lt;em&gt;返回keys的list&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;test: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;the &lt;code&gt;in&lt;/code&gt; operator: &lt;code&gt;if akey in dic&lt;/code&gt;
or even the &lt;code&gt;has_key&lt;/code&gt; method of the dict class: &lt;code&gt;if dic.has_key(k)&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Sequences&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lists, tuples and strings are examples of sequences&lt;/li&gt;
&lt;li&gt;Two of the main features of a sequence is the &lt;strong&gt;indexing&lt;/strong&gt; operation which allows us to fetch a particular item in the sequence directly and the &lt;strong&gt;slicing&lt;/strong&gt; operation which allows us to retrieve a slice of the sequence i.e. a part of the sequence.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The great thing about sequences is that you can access tuples, lists and strings all in the same way!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;indexing(seq can be List or Tuple or String):&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;seq&lt;code&gt;[2], seq[-1]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slicing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;seq&lt;code&gt;[1:3]&lt;/code&gt; &lt;em&gt;(from 1 to 2!)&lt;/em&gt;
&lt;code&gt;seq[:]&lt;/code&gt; &lt;em&gt;(a whole copy of the list)&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;What you need to remember is that if you want to make a copy of a list or such kinds of sequences or complex objects (not simple objects such as integers), then you have to use the slicing operation(&lt;code&gt;list[:]&lt;/code&gt;) to make a copy.&lt;/li&gt;
&lt;li&gt;If you just assign the variable name to another name, both of them will refer to the same object and this could lead to all sorts of trouble if you are not careful.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;String&lt;/h2&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;str.startswith('a')&lt;/code&gt; &lt;em&gt;return boolean&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str.find(substr)&lt;/code&gt; &lt;em&gt;return index of subster or -1 if not found&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;substr in str&lt;/code&gt; &lt;em&gt;return boolean&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str.join(strseq)&lt;/code&gt; &lt;em&gt;use str as delimiter to joint the items in strseq&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ch10. Problem Solving - Writing a Python Script&lt;/h1&gt;
&lt;p&gt;"a program which creates a backup of all my important files"&lt;/p&gt;
&lt;h2&gt;1st version&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Run the command using the &lt;code&gt;os.system&lt;/code&gt; function which runs the command as if it was run from the system i.e. in the shell - it returns 0 if the command was successfully, else it returns an error number.&lt;div class="codehilite"&gt;&lt;pre&gt;source = [&amp;#39;/home/swaroop/byte&amp;#39;, &amp;#39;/home/swaroop/bin&amp;#39;]
target_dir = &amp;#39;/mnt/e/backup/&amp;#39;
target = target_dir + time.strftime(&amp;#39;%Y%m%d%H%M%S&amp;#39;) + &amp;#39;.zip&amp;#39;
zip_command = &amp;quot;zip -qr &amp;#39;%s&amp;#39; %s&amp;quot; % (target, &amp;#39; &amp;#39;.join(source))
if os.system(zip_command) == 0:
    print &amp;#39;Successful backup to&amp;#39;, target
else:
    print &amp;#39;Backup FAILED&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2nd version&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;using the time as the name of the file within a directory with the current date as a directory within the main backup directory.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;if not os.path.exists(today):
    os.mkdir(today) # make directory
...
target = today + os.sep + now + &amp;#39;.zip&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;os.sep&lt;/code&gt; variable - this gives the directory separator according to your operating system i.e. it will be '/' in Linux, Unix, it will be '\' in Windows and ':' in Mac OS.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3rd version&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;attaching a user-supplied comment to the name of the zip archive.&lt;div class="codehilite"&gt;&lt;pre&gt;comment = raw_input(&amp;#39;Enter a comment --&amp;gt; &amp;#39;)
if len(comment) == 0: # check if a comment was entered
    target = today + os.sep + now + &amp;#39;.zip&amp;#39;
else:
    target = today + os.sep + now + &amp;#39;_&amp;#39; + \
    comment.replace(&amp;#39; &amp;#39;, &amp;#39;_&amp;#39;) + &amp;#39;.zip&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;More Refinements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;allow extra files and directories to be passed to the script at the command line. We will get these from the sys.argv list and we can add them to our source list using the extend method provided by the list class.&lt;/li&gt;
&lt;li&gt;use of the tar command instead of the zip command. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One advantage is that when you use the tar command along with gzip, the backup is much faster and the backup created is also much smaller. If I need to use this archive in Windows, then WinZip handles such .tar.gz files easily as well.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tar = 'tar -cvzf %s %s -X /home/swaroop/excludes.txt' % (target, ' '.join(srcdir))&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The most preferred way of creating such kind of archives would be using the zipfile or tarfile module respectively.&lt;/li&gt;
&lt;li&gt;"Software is grown, not built"&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ch11. Object-Oriented Programming&lt;/h1&gt;
&lt;h2&gt;fields, methods&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;class: &lt;strong&gt;fields&lt;/strong&gt;, &lt;strong&gt;methods&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Fields are of two types - they can belong to each instance/object of the class or they can belong to the class itself. They are called &lt;strong&gt;instance variables&lt;/strong&gt; and &lt;strong&gt;class variables&lt;/strong&gt; respectively.&lt;/li&gt;
&lt;li&gt;ou must refer to the variables and methods of the same object using the &lt;code&gt;self&lt;/code&gt; variable only. This is called an &lt;em&gt;attribute reference&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;we refer to the class variable as &lt;code&gt;ClassName.var&lt;/code&gt; and not as &lt;code&gt;self.var&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;self&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Class methods have only one specific difference from ordinary functions - &lt;em&gt;they must have an extra first name that has to be added to the beginning of the parameter list&lt;/em&gt;, but you do do not give a value for this parameter when you call the method, Python will provide it. &lt;/li&gt;
&lt;li&gt;create an object/instance of this class using the name of the class followed by a pair of parentheses.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;The &lt;strong&gt;init&lt;/strong&gt; method&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;__init__()&lt;/code&gt; method is run as soon as an object of a class is instantiated. The method is useful to do any initialization you want to do with your object. &lt;/li&gt;
&lt;li&gt;analogous to a constructor in C++, C# or Java.&lt;/li&gt;
&lt;li&gt;the same, __&lt;code&gt;del__()&lt;/code&gt; method: run when the object is no longer in use and there is no guarantee when that method will be run. If you want to explicitly do this, you just have to use the del statement.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;All class members (including the data members) are &lt;strong&gt;&lt;em&gt;public&lt;/em&gt;&lt;/strong&gt; and all the methods are &lt;strong&gt;&lt;em&gt;virtual&lt;/em&gt;&lt;/strong&gt; in Python.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;One exception: If you use data members with names using the double underscore prefix such as &lt;code&gt;__privatevar&lt;/code&gt;, Python uses name-mangling to effectively make it a private variable.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Inheritance&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ex:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Teacher&lt;/span&gt;(&lt;span class="n"&gt;SchoolMember&lt;/span&gt;)://
    &lt;span class="s"&gt;&amp;#39;&amp;#39;&amp;#39;Represents a teacher.&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;__init__&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="nb"&gt;name&lt;/span&gt;, &lt;span class="n"&gt;age&lt;/span&gt;, &lt;span class="n"&gt;salary&lt;/span&gt;):
        &lt;span class="n"&gt;SchoolMember&lt;/span&gt;.&lt;span class="n"&gt;__init__&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="nb"&gt;name&lt;/span&gt;, &lt;span class="n"&gt;age&lt;/span&gt;)
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;salary&lt;/span&gt; = &lt;span class="n"&gt;salary&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;(Initialized Teacher: %s)&amp;#39;&lt;/span&gt; % &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="nb"&gt;name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To use inheritance, we specify the base class names in a &lt;strong&gt;tuple&lt;/strong&gt; following the class name in the class definition. --&lt;em&gt;multiple inheritance.&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;__init__&lt;/code&gt; method of the base class is explicitly called using the &lt;code&gt;self&lt;/code&gt; variable so that we can initialize the base class part of the object. This is very important to remember - &lt;em&gt;Python does not automatically call the constructor of the base class, you have to explicitly call it yourself.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ch12. Input/Output&lt;/h1&gt;
&lt;h2&gt;Files&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;open and use files for reading or writing by creating an object of the &lt;code&gt;file&lt;/code&gt; class and using its &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;readline&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt; methods appropriately to read from or write to the file. Then finally, when you are finished with the file, you call the &lt;code&gt;close&lt;/code&gt; method to tell Python that we are done using the file.&lt;div class="codehilite"&gt;&lt;pre&gt;f = file(&amp;#39;poem.txt&amp;#39;, &amp;#39;w&amp;#39;) # open for &amp;#39;w&amp;#39;riting
f.write(poem) # write text to file
f.close() # close the file
f = file(&amp;#39;poem.txt&amp;#39;) # if no mode is specified, &amp;#39;r&amp;#39;ead mode is assumed by default
while True:
    line = f.readline()# This method returns a complete line including the newline character at the end of the line.
    if len(line) == 0: # Zero length indicates EOF
    break
    print line, # Notice comma to avoid automatic newline added by Python
f.close() # close the file
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Pickle&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Python provides a standard module called &lt;/em&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;em&gt; using which you can store any Python object in a file and then get it back later intact. This is called storing the object persistently.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;There is another module called &lt;code&gt;cPickle&lt;/code&gt; which functions exactly same as the &lt;code&gt;pickle&lt;/code&gt; module except that it is written in the C language and is (upto 1000 times) faster. &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pickling &amp;amp; unpickling:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;cPickle&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;p&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shoplistfile&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shoplist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shoplistfile&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;storedlist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;storedlist&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To store an object in a file, first we open a file object in write mode and store the object into the open file by calling the &lt;code&gt;dump&lt;/code&gt; function of the pickle module. This process is called &lt;em&gt;pickling&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Next, we retrieve the object using the &lt;code&gt;load&lt;/code&gt; function of the pickle module which returns the object. This process is called &lt;em&gt;unpickling&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ch13. Exceptions&lt;/h1&gt;
&lt;h2&gt;Try..Except&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We can handle exceptions using the &lt;code&gt;try..except&lt;/code&gt; statement. We basically put our usual statements within the try-block and put all our error handlers in the except-block.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ex&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Enter something --&amp;gt; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;EOFError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;Why did you do an EOF on me?&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;# exit the program&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;Some error/exception occurred.&amp;#39;&lt;/span&gt;
    &lt;span class="c"&gt;# here, we are not exiting the program&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Done&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;except&lt;/code&gt; clause can handle a single specified error or exception, or a parenthesized list of errors/exceptions. If no names of errors or exceptions are supplied, it will handle all errors and exceptions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;If any error or exception is not handled, then the default Python handler is called which just stops the execution of the program and prints a message.&lt;/li&gt;
&lt;li&gt;You can also have an &lt;code&gt;else&lt;/code&gt; clause associated with a &lt;code&gt;try..catch&lt;/code&gt; block. The &lt;code&gt;else&lt;/code&gt; clause is executed if no exception occurs.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Raising Exceptions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;using the &lt;code&gt;raise&lt;/code&gt; statement. &lt;/li&gt;
&lt;li&gt;You also have to specify the name of the error/exception and the exception object that is to be thrown along with the exception. &lt;/li&gt;
&lt;li&gt;The error or exception that you can arise should be class which directly or indirectly is a derived class of the &lt;code&gt;Error&lt;/code&gt; or &lt;code&gt;Exception&lt;/code&gt; class respectively.&lt;/li&gt;
&lt;li&gt;ex.&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;ShortInputException&lt;/span&gt;(&lt;span class="nb"&gt;Exception&lt;/span&gt;):
    &lt;span class="s"&gt;&amp;#39;&amp;#39;&amp;#39;A user-defined exception class.&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;__init__&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;length&lt;/span&gt;, &lt;span class="n"&gt;atleast&lt;/span&gt;):
        &lt;span class="nb"&gt;Exception&lt;/span&gt;.&lt;span class="n"&gt;__init__&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;)
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;length&lt;/span&gt; = &lt;span class="n"&gt;length&lt;/span&gt;
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;atleast&lt;/span&gt; = &lt;span class="n"&gt;atleast&lt;/span&gt;

&lt;span class="n"&gt;try:&lt;/span&gt;
    &lt;span class="o"&gt;s&lt;/span&gt; = &lt;span class="n"&gt;raw_input&lt;/span&gt;(&lt;span class="s"&gt;&amp;#39;Enter something --&amp;gt; &amp;#39;&lt;/span&gt;)
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;(&lt;span class="o"&gt;s&lt;/span&gt;) &amp;lt; &lt;span class="mi"&gt;3&lt;/span&gt;:
        &lt;span class="n"&gt;raise&lt;/span&gt; &lt;span class="n"&gt;ShortInputException&lt;/span&gt;(&lt;span class="n"&gt;len&lt;/span&gt;(&lt;span class="o"&gt;s&lt;/span&gt;), &lt;span class="mi"&gt;3&lt;/span&gt;)&lt;span class="c-Singleline"&gt;#  specify the name of the error/exception and the exception object that is to be thrown&lt;/span&gt;

&lt;span class="n"&gt;except&lt;/span&gt; &lt;span class="n"&gt;EOFError:&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;\nWhy did you do an EOF on me?&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;except&lt;/span&gt; &lt;span class="n"&gt;ShortInputException&lt;/span&gt;, &lt;span class="o"&gt;x&lt;/span&gt;:
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;ShortInputException: The input was of length %d, \&lt;/span&gt;
&lt;span class="s"&gt;                was expecting at least %d&amp;#39;&lt;/span&gt; % (&lt;span class="o"&gt;x&lt;/span&gt;.&lt;span class="n"&gt;length&lt;/span&gt;, &lt;span class="o"&gt;x&lt;/span&gt;.&lt;span class="n"&gt;atleast&lt;/span&gt;)
&lt;span class="n"&gt;else:&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;No exception was raised.&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Try..Finally&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;What if you were reading a file and you wanted to close the file &lt;em&gt;whether or not an exception was raised&lt;/em&gt;?&lt;/li&gt;
&lt;li&gt;before the program exits, the finally clause is executed and the file is closed.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ch14. The Python Standard Library&lt;/h1&gt;
&lt;h2&gt;sys module&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sys.argv&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;there is always at least one item in the &lt;code&gt;sys.argv&lt;/code&gt; list which is the name of the current program being run and is available as &lt;code&gt;sys.argv[0]&lt;/code&gt; . Other command line arguments follow this item.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sys.exit&lt;/code&gt; : to exit the running program.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;os module&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;os.getcwd()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;gets the current working directory i.e. the path of the directory from which the curent Python script is working.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;os.listdir()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.remove()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.system()&lt;/code&gt;: run a shell command.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.linesep&lt;/code&gt;: string gives the line terminator used in the current platform. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.split()&lt;/code&gt;: returns the directory name and file name of the path.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.isfile()&lt;/code&gt; and &lt;code&gt;os.path.isdir()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;ch15. More Python&lt;/h1&gt;
&lt;h2&gt;Special Methods&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generally, special methods are used to mimic certain behavior. &lt;/li&gt;
&lt;li&gt;For example, if you want to use the &lt;code&gt;x[key]&lt;/code&gt; indexing operation for your class (just like you use for lists and tuples) then just implement the &lt;code&gt;__getitem__()&lt;/code&gt; method and your job is done.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__init__(self, ...)&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;__del__(self)&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;__str__(self)&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Called when we use the &lt;code&gt;print&lt;/code&gt; statement with the object or when &lt;code&gt;str()&lt;/code&gt; is used.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__lt__(self, other)&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Called when the &lt;em&gt;less than&lt;/em&gt; operator ( &amp;lt; ) is used. Similarly, there are special methods for all the operators (+, &amp;gt;, etc.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__getitem__(self, key)&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Called when x[key] indexing operation is used.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__len__(self)&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Called when the built-in &lt;code&gt;len()&lt;/code&gt; function is used for the sequence object.&lt;/p&gt;
&lt;h2&gt;List Comprehension&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;used to derive a new list from an existing list.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ex&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;listone = [2, 3, 4]
listtwo = [2*i for i in listone if i &amp;gt; 2]
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Here, we derive a new list by specifying the manipulation to be done (2*i) when some condition is satisfied (if i &amp;gt; 2).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Receiving Tuples and Lists in Functions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;receiving parameters to a function as a &lt;em&gt;tuple&lt;/em&gt; or a &lt;em&gt;dictionary&lt;/em&gt; using the &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;**&lt;/code&gt; prefix respectively. &lt;/li&gt;
&lt;li&gt;This is useful when taking variable number of arguments in the function.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;def powersum(power, *args):...&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Due to the * prefix on the args variable, all extra arguments passed to the function are stored in args as a tuple. If a ** prefix had been used instead, the extra parameters would be considered to be key/value pairs of a dictionary.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Lambda Forms&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;lambda&lt;/code&gt; statement is used to create new function objects and then return them &lt;em&gt;at runtime&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;ex. &lt;div class="codehilite"&gt;&lt;pre&gt;def make_repeater(n):
    return lambda s: s * n
twice = make_repeater(2)
print twice(&amp;#39;word&amp;#39;)
print twice(5)
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;output:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    $ python lambda.py
    wordword
    10
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;lambda&lt;/code&gt; statement is used to create &lt;em&gt;the function object&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Essentially, &lt;em&gt;the lambda takes a parameter followed by a single expression only which becomes the body of the function and the value of this expression is returned by the new function.&lt;/em&gt; &lt;/li&gt;
&lt;li&gt;Note that even a print statement cannot be used inside a lambda form, only &lt;em&gt;expressions&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;The exec and eval statements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;exec&lt;/code&gt; statement is used to execute Python statements which are stored in a string or file.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;eval&lt;/code&gt; statement is used to evaluate valid Python expressions which are stored in a string. &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;The assert statement&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;to assert that something is true. &lt;/li&gt;
&lt;li&gt;For example, if you are very sure that you will have at least one element in a list you are using and want to check this, and raise an error if it is not true, then assert statement is ideal in this situation. &lt;/li&gt;
&lt;li&gt;When the assert statement fails, an AssertionError is raised.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;The repr function or Backticks(`)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;to obtain a canonical string representation of the object.&lt;/li&gt;
&lt;li&gt;you will have &lt;code&gt;eval(repr(object)) == object&lt;/code&gt; most of the time.&lt;/li&gt;
&lt;li&gt;Basically, the repr function or the backticks are used to obtain a printable representation of the object.&lt;/li&gt;
&lt;li&gt;can control what your objects return for the repr function by defining the __&lt;code&gt;repr__&lt;/code&gt; method in your class.&lt;/li&gt;
&lt;/ul&gt;</summary><category term="python"></category></entry><entry><title>linux下安装并使用java开发opencv的配置</title><link href="http://x-wei.github.io/linux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8java%E5%BC%80%E5%8F%91opencv%E7%9A%84%E9%85%8D%E7%BD%AE.html" rel="alternate"></link><updated>2014-02-10T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/linux下安装并使用java开发opencv的配置.html</id><summary type="html">&lt;p&gt;今天花了四个小时, 终于在linux下把eclipse下java开发opencv给搞定了... 至于为什么花这么久的时间... 且听我慢慢讲... &lt;/p&gt;
&lt;h2&gt;linux编译安装opencv&lt;/h2&gt;
&lt;p&gt;首先, linux下安装opencv其实不麻烦的, 参考文档即可完成:
&lt;a href="http://docs.opencv.org/trunk/doc/tutorials/introduction/linux_install/linux_install.html"&gt;http://docs.opencv.org/trunk/doc/tutorials/introduction/linux_install/linux_install.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大致有以下几个步骤:&lt;/p&gt;
&lt;p&gt;1) 安装gcc以及cmake等等乱七八糟的软件(不过ubuntu下默认差不多都有了吧...)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sudo apt-get install build-essential python-dev cmake
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2) 下载opencv-2.4.8.zip并解压缩&lt;/p&gt;
&lt;p&gt;3) 新建一个build文件夹&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cd ~/opencv
mkdir build
cd build
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4) 在终端里输入: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..
make
sudo make install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;make命令会花费几十分钟时间...
然后&lt;strong&gt;理论上&lt;/strong&gt;就结束了... 如果不用java开发的话 就OK了 比如 可以运行sample文件夹下的python代码...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是&lt;/strong&gt;, 如果要使用java开发的话 需要接着这样做.....&lt;/p&gt;
&lt;h2&gt;安装opencv-java&lt;/h2&gt;
&lt;p&gt;这一步非常DT, 因为官网上还有一个文档, 专门讲怎么用java开发的...
&lt;a href="http://docs.opencv.org/doc/tutorials/introduction/desktop_java/java_dev_intro.html"&gt;http://docs.opencv.org/doc/tutorials/introduction/desktop_java/java_dev_intro.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1) 首先, 需要安装ant: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sudo apt-get install ant
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2) 其次 需要运行cmake, 关键是cmake的参数, 官网给的是这样的: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;export JAVA_HOME=/usr/lib/jvm/java-6-oracle#这句不加应该也可以的
cmake -DBUILD_SHARED_LIBS=OFF ..
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意看输出的, 如果"To be built"里面有java这一项的话, 就&lt;strong&gt;应该&lt;/strong&gt;是OK的.... 接下来只要&lt;code&gt;make -j8&lt;/code&gt; 就可以了...&lt;/p&gt;
&lt;p&gt;最坑爹的地方来了, 以这样的参数运行cmake以后, 运行&lt;code&gt;make -j8&lt;/code&gt;总是不成功, 说有错误.....&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./linux下安装并使用java开发opencv的配置/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;查了半天, 发现这是一个BUG:
&lt;a href="http://code.opencv.org/issues/2859"&gt;http://code.opencv.org/issues/2859&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么试一试加上参数: &lt;code&gt;-DBUILD_TESTS=OFF&lt;/code&gt; 吧...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以cmake的参数要这样写才可以&lt;/strong&gt;: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -DBUILD_TESTS=OFF ..&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3) 用上面那样的参数运行cmake以后, 再: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;make -j8
sudo make install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就可以成功make了...&lt;/p&gt;
&lt;h2&gt;如何判断是否安装成功?&lt;/h2&gt;
&lt;p&gt;以上操作结束后, 看看build文件夹, bin目录下是不是有一个&lt;code&gt;opencv-248.jar&lt;/code&gt;文件:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./linux下安装并使用java开发opencv的配置/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;如果有的话 就说明成功安装了opencv的java组件... &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;!!注意!!&lt;/strong&gt;
&lt;strong&gt;不能用windows下opencv安装目录下的那个opencv-248.jar&lt;/strong&gt;!! 
刚才生成那个jar和windows下的jar不一样的!! (我查了MD5码... 其实看文件大小也能看出来!!)&lt;/p&gt;
&lt;h2&gt;Eclipse下的配置&lt;/h2&gt;
&lt;p&gt;这里有一篇非常好的帖子, 写的非常到位, 我就不重复了, 链接:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://exintopro.net/blog/2013/10/02/setting-up-eclipse-for-using-opencv-java-in-ubuntu/"&gt;http://exintopro.net/blog/2013/10/02/setting-up-eclipse-for-using-opencv-java-in-ubuntu/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个帖子虽然很好, 但是没有介绍编译的那一部分, 由于安装java组件时的编译过程和官网给的不一样, 所以才导致我废了半天的时间啊!......&lt;/p&gt;</summary><category term="eclipse"></category><category term="java"></category><category term="opencv"></category></entry><entry><title>java线程小结</title><link href="http://x-wei.github.io/java%E7%BA%BF%E7%A8%8B%E5%B0%8F%E7%BB%93.html" rel="alternate"></link><updated>2013-11-29T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/java线程小结.html</id><summary type="html">&lt;p&gt;INF422的TD2, 这节TD是要做一个多线程筛选质数的程序, 关于java的多线程, 以前用过但是不知道啥意思, 在这里总结下. &lt;/p&gt;
&lt;h2&gt;创建进程&lt;/h2&gt;
&lt;p&gt;为了实现多线程, 需要定义一个新的class, 有两种方法: 
&lt;strong&gt;或者继承自&lt;/strong&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;strong&gt;类, 或者实现&lt;/strong&gt;&lt;code&gt;Runnable&lt;/code&gt;&lt;strong&gt;接口&lt;/strong&gt;(关键是重载run()方法). &lt;/p&gt;
&lt;h3&gt;继承自Thread类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;写法1: 定义一个继承自Thread的内部类--&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; [&lt;span class="n"&gt;类名&lt;/span&gt;] &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;{
&lt;span class="n"&gt;方法1&lt;/span&gt;;
&lt;span class="n"&gt;方法2&lt;/span&gt;；
…
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="nb"&gt;run&lt;/span&gt;(){
// …
}
&lt;span class="n"&gt;属性1&lt;/span&gt;；
&lt;span class="n"&gt;属性2&lt;/span&gt;；
…
}
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者用下面种&lt;strong&gt;内联(inline)&lt;/strong&gt;的写法, 不用给这个类起名字了(不过还要给这个实例取名字): &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private Thread [实例名] = new Thread () {
    public void run() {
    // ...
    }
} ;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后让进程开始, 就是: 
&lt;code&gt;t.start();&lt;/code&gt;
如果用&lt;code&gt;t.run()&lt;/code&gt;的话, 则依然是并行执行的, 可能达不到多线程效果...&lt;/p&gt;
&lt;h3&gt;实现Runnable接口&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法1, 代码: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; [&lt;span class="n"&gt;类名&lt;/span&gt;] &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt;{
&lt;span class="n"&gt;方法1&lt;/span&gt;;
&lt;span class="n"&gt;方法2&lt;/span&gt;；
…
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="nb"&gt;run&lt;/span&gt;(){
    // &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;…
}
&lt;span class="n"&gt;属性1&lt;/span&gt;；
&lt;span class="n"&gt;属性2&lt;/span&gt;；
…
}
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法2, 内联写法:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private Runnable [实例名] = new Runnable() {
public void run() {
    //...
 }
};
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;android上需要注意的一点&lt;/h2&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;"Android modifies the user interface and handles input events from &lt;strong&gt;one single&lt;/strong&gt; user interface thread. This thread is also called &lt;strong&gt;the main thread&lt;/strong&gt;."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;Android collects all events in a queue and processed an instance of the Looper class.
&lt;img alt="" src="./java线程小结/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;所以注意要修改用户交互的组件(View, Toast, ect.)的时候, 需要在main Thread里面操作, 否则运行时会出错!!&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;那么, 当其他线程进行计算完成以后, 要刷新屏幕的显示时, 需要告知main Thread 进行更新显示:&lt;/p&gt;
&lt;p&gt;"Ajouter un nouvel objet comportant une méthode run() mettant à jour le nombre d'entier premiers (nouvel objet implémentant l'interface Runnable). À la fin du crible, le thread de calcul devra alors envoyer un message (ce nouvel objet) au thread principal pour mettre à jour l'affichage graphique. Cette mise à jour doit être faite via un appel à la méthode post() d'une instance de la classe Handler (l'objet Handler doit être instancié dans le thread principal)."&lt;/p&gt;
&lt;p&gt;Bref, 要做到多线程计算, 计算结果显示在屏幕上, 需要:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加一个Runnable实例("一个实现了Runnable接口的类的实例"), 重载run()方法实现calcul&lt;/li&gt;
&lt;li&gt;&lt;em&gt;一个&lt;/em&gt;&lt;a href="http://developer.android.com/reference/android/os/Handler.html"&gt;Handler&lt;/a&gt;&lt;em&gt;实例, 然后调用这个Handler的post()方法.&lt;/em&gt; &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看看文档里是咋说的: &lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;public final boolean post (Runnable r)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;Added in API level 1
Causes the Runnable r to be added to the message queue. The runnable will be run on the thread to which this handler is attached.&lt;/p&gt;
&lt;p&gt;Parameters
r   The Runnable that will be executed.
Returns
Returns true if the Runnable was successfully placed in to the message queue. Returns false on failure, usually because the looper processing the message queue is exiting.&lt;/p&gt;
&lt;p&gt;意思是&lt;code&gt;handler.post(r)&lt;/code&gt;会把r(一个Runnable实例)加入message queue中去, &lt;em&gt;这个Runnable会在这个handler关联的Thread中执行&lt;/em&gt;. 所以只要handler关联的是main Thread, 就可以在这个Runnalbe里面写graphic的代码也不会出错了. &lt;/p&gt;
&lt;p&gt;如果在Activity类的声明里声明handler为一个属性: 
&lt;code&gt;private Handler handler = new Handler();&lt;/code&gt;
这个构造函数没有参数, 根据文档, "Default constructor associates this handler with the Looper for the current thread." 所以这个handler关联到了current thread, 也就是main Thread.....&lt;/p&gt;
&lt;h2&gt;例子&lt;/h2&gt;
&lt;p&gt;所以, 多线程计算, 计算结束后修改屏幕显示的话, 需要以下__三个步骤__(比上面的俩步骤多了一个, 不知道是否还可以简化): &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在主线程里声明handler, (声明成Activity的一个属性): &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;private Handler handler = new Handler();&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;写一个用于修改屏幕显示的Runnable r(也声明成一个属性了):&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private Runnable r = new Runnable() {
public void run() {
//code to update graphic display...
}
};
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再写一个进行计算的Thread t, 在计算结束后, 用handler.post(r)实现刷新显示的效果: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;private final Thread t = new Thread() {
    public void run() {
//...code for calculating...
//结束计算以后, 刷新屏幕:
handler.post(r);
    }
};
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后在onCreate()函数里, 让Thread t 启动起来: &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;t.start();&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要让t一直循环(监视某个flag), 当flag变为true的时候, 进行计算.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了达到这个效果, Thread t里面的run()方法需要这样写:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    public void run() {
        while(true) {
            if(flag){
            //...do the calculation...
            handler.post(r);
            flag=false;
            }
        }   
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Process, Thread和Runnable的区别?&lt;/h2&gt;
&lt;p&gt;线程(Thread)是指进程(Process)中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。&lt;/p&gt;
&lt;p&gt;参考链接: 
&lt;a href="http://www.vogella.com/articles/AndroidBackgroundProcessing/article.html"&gt;http://www.vogella.com/articles/AndroidBackgroundProcessing/article.html&lt;/a&gt;
&lt;a href="http://www.cnblogs.com/rollenholt/archive/2011/08/28/2156357.html"&gt;http://www.cnblogs.com/rollenholt/archive/2011/08/28/2156357.html&lt;/a&gt;
&lt;a href="http://developer.android.com/reference/android/os/Handler.html"&gt;http://developer.android.com/reference/android/os/Handler.html&lt;/a&gt;
&lt;a href="http://lavasoft.blog.51cto.com/62575/99150"&gt;http://lavasoft.blog.51cto.com/62575/99150&lt;/a&gt;&lt;/p&gt;</summary><category term="android"></category><category term="java"></category></entry><entry><title>ADT环境搭建</title><link href="http://x-wei.github.io/ADT%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html" rel="alternate"></link><updated>2013-11-08T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/ADT环境搭建.html</id><summary type="html">&lt;p&gt;这学期INF422, 第一节课就是android安装调试环境的搭建(居然要一节课?), 这里总结一下.&lt;/p&gt;
&lt;h3&gt;第一步: 下载bundle&lt;/h3&gt;
&lt;p&gt;下载&lt;a href="http://developer.android.com/sdk/index.html"&gt;ADT-Bundle&lt;/a&gt;
解压缩以后啥都有了, 包含一个eclipse...&lt;/p&gt;
&lt;h3&gt;第二步: 修改环境变量&lt;/h3&gt;
&lt;p&gt;linux下的环境变量放在&lt;code&gt;.bashrc文件&lt;/code&gt;, 加入下面一行: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;PATH=$PATH:&amp;lt;dir&amp;gt;/sdk/tools/:&amp;lt;dir&amp;gt;/sdk/platform-tools/:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt;是放置SDK的目录地址.&lt;/p&gt;
&lt;p&gt;测试一下好不好使, 在终端中输入&lt;code&gt;android&lt;/code&gt;, 看是否会弹出SDK manager&lt;/p&gt;
&lt;h3&gt;第三步: 新建一个virtual machine&lt;/h3&gt;
&lt;p&gt;可以用eclipse的AVDmanager做, 也可以用命令行做. &lt;/p&gt;
&lt;p&gt;输入:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android list targets&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;找到想要的target(我们要4.1.2)的那个id(一个数字), 然后, 运行命令: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;android create avd -t &amp;lt;target_id&amp;gt; -n inf422 --abi armeabi-v7a&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样就生成了一个名叫"inf422"的虚拟机&lt;/p&gt;
&lt;h3&gt;第四步: 关联到自定义的镜像&lt;/h3&gt;
&lt;p&gt;inf422这门课提供了一个修改过的android镜像, 在&lt;a href="http://www.enseignement.polytechnique.fr/informatique/INF422/ramdisk.img"&gt;这里&lt;/a&gt;和&lt;a href="http://www.enseignement.polytechnique.fr/informatique/INF422/kernel-qemu"&gt;这里&lt;/a&gt;下载, 下载到本地的目录上了以后, 运行: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;emulator @inf422 -ramdisk &amp;lt;IMAGES&amp;gt;/ramdisk.img -kernel &amp;lt;IMAGES&amp;gt;/kernel-qemu&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;IMAGES&gt;是刚刚存放那俩镜像文件的目录. &lt;/p&gt;
&lt;h3&gt;第五步: telnet连接虚拟机&lt;/h3&gt;
&lt;p&gt;课程里用的emulator使用telnet服务器, 且是在虚拟机的23端口接收信息. 先重定向一下端口, 定向到localhost的4444端口:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adb forward tcp:4444 tcp:23&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样, 以后要登录模拟器emulator的时候, 只需要输入: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;telnet localhost 4444&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;(用户名是root, 不要密码)&lt;/p&gt;
&lt;h2&gt;第六步: 用两种方法进入虚拟机&lt;/h2&gt;
&lt;p&gt;刚才的4444端口是进入emulator用的, 而打开虚拟机的时候, 窗口标题是一个数字再加虚拟机的名字(我的显示的是"5554:inf422"), 这个5554是另外一个端口, 用于用shell方式登陆, 登陆后可以使用shell命令查看文件或者进行一些操作. &lt;/p&gt;
&lt;p&gt;而与之对应, 从4444端口登陆, 则是进入emulator的控制console&lt;/p&gt;
&lt;p&gt;&lt;em&gt;两种方法和AVD交流:&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;console: linux命令, 命令行&lt;/li&gt;
&lt;li&gt;emulator: 发送命令产生一些事件(电话, 短信, GPS等)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第二种方式可以模拟一些手机事件, 很有用... 使用help命令查看emulator怎么使用&lt;/p&gt;</summary><category term="android"></category><category term="inf422"></category></entry><entry><title>android开发视频教程(重制版) 第一季 课程笔记</title><link href="http://x-wei.github.io/android%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E5%AD%A3%E7%AC%94%E8%AE%B0.html" rel="alternate"></link><updated>2013-07-31T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/android开发教程第一季笔记.html</id><summary type="html">&lt;h1&gt;S01E02: 开发环境搭建&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;直接去 developer.android.com/sdk/ 下载bundle解压即可, 里面包含eclipse&lt;/li&gt;
&lt;li&gt;新建一个模拟器: 内部存储一般64MB足矣:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;h1&gt;S01E03: android项目目录结构&lt;/h1&gt;
&lt;h4&gt;第一个android程序&lt;/h4&gt;
&lt;p&gt;new--&amp;gt;android application&lt;/p&gt;
&lt;h4&gt;目录结构&lt;/h4&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;com.example.helloworld这个包名一般为网址倒着写, android是按照包名来区分不同APP的&lt;/li&gt;
&lt;li&gt;src/目录下存放java程序&lt;/li&gt;
&lt;li&gt;gen/目录下存放系统自动生成的文件, R.java里给每一个控件或变量赋予一个id, 千万__不要手动修改R,.java内容__!!&lt;/li&gt;
&lt;li&gt;assets/目录下和res/目录下都可以放各种外部文件(ex. 图片), 但是assets下的文件不会在R.java中生成id&lt;/li&gt;
&lt;li&gt;res/layout/ 存放布局文件(xml格式)&lt;/li&gt;
&lt;li&gt;AndroidManifest.xml用于统筹&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;S01E04: 技术结构&lt;/h1&gt;
&lt;h4&gt;四层结构图&lt;/h4&gt;
&lt;p&gt;开发位于最上层application
&lt;img alt="" src="./android开发教程第一季笔记/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;h4&gt;基于组件的应用程序开发&lt;/h4&gt;
&lt;p&gt;搭积木&lt;/p&gt;
&lt;h4&gt;常见组件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;activity(负责用户交互); &lt;/li&gt;
&lt;li&gt;service(后台处理数据); &lt;/li&gt;
&lt;li&gt;Content Provider(对外提供数据); &lt;/li&gt;
&lt;li&gt;BroadcastReceiver(接收broadcast)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;S01E05: activity初步&lt;/h1&gt;
&lt;h4&gt;Activity启动基本流程&lt;/h4&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image006.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AndroidManifest.xml里面指定, 程序运行后执行MainActivity.java&lt;/li&gt;
&lt;li&gt;MainActivity.java的onCreate()函数里setContentView(R.layout.activity_main); 读取activity_main.xml文件并显示&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Activity与布局文件&lt;/h4&gt;
&lt;p&gt;一一对应 (eclipse编辑器里有图形化预览界面)&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image007.png" /&gt;&lt;/p&gt;
&lt;h4&gt;在Activity当中获取代表控件对象&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先在activity_main.xml里定义控件时, 为其指定一个id: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;android&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;@+id/textView1&amp;quot;&lt;/span&gt;  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+id&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;表示新建一个&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;→ 自动在R.java里生成一个id:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;public static final class id {
        public static final int textView1=0x7f080003;
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;→ 之后在MainActivity.java里, 先声明成员变量:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;private TextView tv&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;→ 在onCreate()中, 通过id获得这个控件对象:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tv = (TextView) findViewById(R.id.textView1);//有向下转型: TextView是View的子类
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;→ 之后就可以调用tv的各种方法了,具体见SDK里的文档i(android.widget.TextView), 从而实现再java程序里动态修改控件属性.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;S01E06: View&lt;/h1&gt;
&lt;h4&gt;View的基本概念&lt;/h4&gt;
&lt;p&gt;View是一个控件?...&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image008.png" /&gt;&lt;/p&gt;
&lt;h4&gt;为一个View绑定监听器&lt;/h4&gt;
&lt;p&gt;(我就认为View是一个控件了)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;java程序里获取控件代表的对象: findViewById()方法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;bt = (Button) findViewById(R.id.button1);
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义一个&lt;strong&gt;内部类&lt;/strong&gt; 实现监听器接口:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;// **使用一个内部类定义监听器**
// Button的监听器 实现OnClickListener接口, OnClickListener接口是处理点击事件的
class ButtonListener implements OnClickListener {
@Override
// 实现该接口的抽象方法onClick
public void onClick(View v) {
//do something......
}
}// end 内部类ButtonListener
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;onCreate()里生成一个监听器对象, 并为控件绑定该监听器&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ButtonListener bl = new ButtonListener();// 生成一个监听器对象
bt.setOnClickListener(bl);// **这句话把监听器和事件联系在一起了** 点击这个按钮 就会执行它的onclick方法
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个监听器可以绑定给多个控件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;另法&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以直接写在setOnClickListener参数里, 不用给内部类起名字: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    bt.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick(View v) {
    //do something......
    }
    });
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;S01E07: 布局&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;所谓的控件布局方法,就是指控制控件在Activity当中的位置、大小、颜色以及其他控件样式属性的方法。&lt;/li&gt;
&lt;li&gt;布局可以用xml布局文件(ex. /res/layout/activity_main.xml) 也可以在java文件里完成控件布局&lt;/li&gt;
&lt;li&gt;最常用: 线性布局LinearLayout, 相对布局RelativeLayout&lt;/li&gt;
&lt;li&gt;先暂时用线性布局LinearLayout, 最简单&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;S01E08: 距离单位; 边距&lt;/h1&gt;
&lt;h4&gt;距离单位: px, dp, sp&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;px&lt;/strong&gt;=像素点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用px指定控件大小, 则不同分辨率手机显示结果不同, 非常麻烦.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dpi计算公式:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image009.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dp&lt;/strong&gt;=dip(Device Independent pixels) 是设备无关的像素单位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;换算公式&lt;code&gt;px = dp * (dpi / 160)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;在320*480的屏幕上, dp与px相等 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总之一般指定控件大小就用dp&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;sp&lt;/strong&gt;=scaled pixels 可改变大小的像素单位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当用户修改手机显示字体时,sp会随之改变&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sp单位通常用于指定字体的大小&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;内外边距: margin, padding&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;margin: 控件离其他控件的距离&lt;/li&gt;
&lt;li&gt;padding: 控件内容离控件边框的距离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image010.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置内边距与外边距:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;layout_margin, layout_marginTop, ...
padding, paddingTop, ...&lt;/p&gt;
&lt;h2&gt;S01E09: CheckBox多选框&lt;/h2&gt;
&lt;p&gt;效果: 
&lt;img alt="" src="./android开发教程第一季笔记/pasted_image011.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;布局文件里使用&lt;CheckBox/&gt;标签&lt;/li&gt;
&lt;li&gt;OnClickListener与OnCheckedChangeListener监听器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 这俩监听器是有一定区别的, OnClickListener必须是用户点击才能触发, OnCheckedChangeListener则是只要状态改变了(即使是由程序里改变的)就会触发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以几个CheckBox绑定上同一个监听器&lt;/li&gt;
&lt;li&gt;OnClickListener接口的方法: public void onClick(View v) 有一个&lt;strong&gt;参数View v&lt;/strong&gt;, 指的是是哪个控件被点击了, &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在onClick()中要处理这个控件时, 使用:&lt;code&gt;CheckBox cb = (CheckBox) v;&lt;/code&gt;
得到这个控件对象, 或者通过其&lt;code&gt;id: v.getId()&lt;/code&gt;也可以&lt;/p&gt;
&lt;h2&gt;S01E10: 单选框RadioButton&lt;/h2&gt;
&lt;p&gt;效果: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image013.png" /&gt;&lt;/p&gt;
&lt;h4&gt;RadioGroup&lt;/h4&gt;
&lt;p&gt;单选按钮RadioButton需要放在一个RadioGroup中&lt;/p&gt;
&lt;p&gt;xml代码:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt; &lt;span class="nt"&gt;&amp;lt;RadioGroup&lt;/span&gt;
    &lt;span class="na"&gt;android:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@+id/radioGroupId&amp;quot;&lt;/span&gt;
    &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0dp&amp;quot;&lt;/span&gt;
    &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
    &lt;span class="na"&gt;android:layout_gravity=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;center&amp;quot;&lt;/span&gt;
    &lt;span class="na"&gt;android:orientation=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;vertical&amp;quot;&lt;/span&gt; 
    &lt;span class="na"&gt;android:layout_weight=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

    &lt;span class="nt"&gt;&amp;lt;RadioButton&lt;/span&gt;
        &lt;span class="na"&gt;android:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@+id/radioButton_h&amp;quot;&lt;/span&gt;
        &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
        &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
        &lt;span class="na"&gt;android:text=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;homme&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class="nt"&gt;&amp;lt;RadioButton&lt;/span&gt;
        &lt;span class="na"&gt;android:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@+id/radioButton_f&amp;quot;&lt;/span&gt;
        &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
        &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
        &lt;span class="na"&gt;android:text=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;femmee&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/RadioGroup&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!-- 像RadioGroup这样写的xml标签可以拥有子标签, 而像RadioButton这种则不能 →&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;RadioGroup的OnCheckedChangeListener&lt;/h4&gt;
&lt;p&gt;有俩参数... (RadioGroup group, int checkedId)&lt;/p&gt;
&lt;p&gt;直接上代码吧: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;RadioGroupListener&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt;
&lt;span class="n"&gt;android&lt;/span&gt;.&lt;span class="n"&gt;widget&lt;/span&gt;.&lt;span class="n"&gt;RadioGroup&lt;/span&gt;.&lt;span class="n"&gt;OnCheckedChangeListener&lt;/span&gt; {

&lt;span class="nv"&gt;@Override&lt;/span&gt;
// &lt;span class="n"&gt;注意看这俩参数&lt;/span&gt;!
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="n"&gt;onCheckedChanged&lt;/span&gt;(&lt;span class="n"&gt;RadioGroup&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt;, &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;checkedId&lt;/span&gt;) {// &lt;span class="n"&gt;checkedId是被选择的哪个RadioButton的Id&lt;/span&gt; (&lt;span class="n"&gt;而不是什么序号&lt;/span&gt;)
&lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;checkedId&lt;/span&gt; == &lt;span class="n"&gt;R&lt;/span&gt;.&lt;span class="n"&gt;id&lt;/span&gt;.&lt;span class="n"&gt;radioButton_h&lt;/span&gt;)// &lt;span class="n"&gt;用两种方法得到想要的id:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;. &lt;span class="n"&gt;使用R中定义的&lt;/span&gt;
{
&lt;span class="n"&gt;tv3&lt;/span&gt;.&lt;span class="n"&gt;setText&lt;/span&gt;(&lt;span class="s"&gt;&amp;quot;Homme!&amp;quot;&lt;/span&gt;);
&lt;span class="n"&gt;rb_h2&lt;/span&gt;.&lt;span class="n"&gt;setChecked&lt;/span&gt;(&lt;span class="nb"&gt;true&lt;/span&gt;);
} &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;checkedId&lt;/span&gt; == &lt;span class="n"&gt;rb_f&lt;/span&gt;.&lt;span class="n"&gt;getId&lt;/span&gt;())// &lt;span class="mi"&gt;2&lt;/span&gt;. &lt;span class="n"&gt;使用getid&lt;/span&gt;()&lt;span class="n"&gt;方法&lt;/span&gt;
{
&lt;span class="n"&gt;tv3&lt;/span&gt;.&lt;span class="n"&gt;setText&lt;/span&gt;(&lt;span class="s"&gt;&amp;quot;Femme!&amp;quot;&lt;/span&gt;);
&lt;span class="n"&gt;rb_f2&lt;/span&gt;.&lt;span class="n"&gt;setChecked&lt;/span&gt;(&lt;span class="nb"&gt;true&lt;/span&gt;);
}

}

}
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;S01E11: 显示图片ImageView&lt;/h1&gt;
&lt;h4&gt;插图的方法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;把图片放在./res/drawable 里面(有好几个分辨率的drawable, 随便一个...), ex. 放在了./res/drawable-hdpi/pic.jpg&lt;/li&gt;
&lt;li&gt;→ 会在R.java里生成其&lt;code&gt;id: pic&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在xml中使用&lt;ImageView/&gt;标签&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引用放好的图: 
&lt;code&gt;android:src="@drawable/pic"&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;ScaleType&lt;/h4&gt;
&lt;p&gt;ScaleType属性控制图片缩放的尺寸, 有几个可选: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fitcenter等比例缩放并居中显示; &lt;/li&gt;
&lt;li&gt;fitstart靠上显示; &lt;/li&gt;
&lt;li&gt;center 若图片较大则把中央部分截取出来显示,不缩放若图片小则直接居中显示, 也不缩放 &lt;/li&gt;
&lt;li&gt;centerCrop 缩放并进行裁剪以适应ImiageView&lt;/li&gt;
&lt;li&gt;centerInside 要是图片大就缩放放进去, 图片小就不缩放直接放进去&lt;/li&gt;
&lt;li&gt;Fit_XY缩放成和ImageView一样大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码片段: &lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&amp;lt;ImageView
    android:id=&amp;quot;@+id/imageView1Id&amp;quot;
    android:layout_width=&amp;quot;60dp&amp;quot;
    android:layout_height=&amp;quot;70dp&amp;quot;
    android:background=&amp;quot;#FF0000&amp;quot;
    android:scaleType=&amp;quot;fitCenter&amp;quot;
    android:layout_weight=&amp;quot;1&amp;quot;
    android:src=&amp;quot;@drawable/pic&amp;quot; /&amp;gt;
&amp;lt;!-- &amp;quot;@drawable/pic&amp;quot;是对应于R.drawable.pic, 实际上图片也可以放在assets文件夹 或者网络上 或者SD卡上 都可以, 不过以后再用 --&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;S01E12: 线性布局深入&lt;/h1&gt;
&lt;h4&gt;线性布局嵌套&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在LinearLayout里面再加入LinearLayout&lt;/li&gt;
&lt;li&gt;"直接父/子控件"&lt;/li&gt;
&lt;li&gt;嵌套层数没有限制&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;layout_weight&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;子控件并未占满父控件的所有空间时才有用&lt;/li&gt;
&lt;li&gt;layout_weight的值用于指定&lt;strong&gt;空闲空间的&lt;/strong&gt;分配__比例__: weight都是1的话--是按比例平分父控件的__剩余(!!!)__空间, 而不是整个父控件被按比例分配!&lt;/li&gt;
&lt;li&gt;如果想让父控件按比例分配: 很简单, __把宽度改为0dp__即可(那么父控件剩余空间=父控件总空间!)&lt;/li&gt;
&lt;li&gt;使用了线性布局嵌套以及weight属性, 已经可以制作一些相对较复杂的布局了&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;S01E13: 相对布局-I&lt;/h1&gt;
&lt;h4&gt;相对布局def&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;相对布局是通过指定当前控件__与兄弟控件或者是父控件之间的相对位置__,从而达到控制控件位置的目的  &lt;/li&gt;
&lt;li&gt;实现同样界面, 用相对布局比用线性布局简单--&lt;strong&gt;UI性能&lt;/strong&gt;更好些&lt;/li&gt;
&lt;li&gt;UI性能: 布局嵌套越多, 性能越差!!...&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;基本思路&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;未指定位置时: 默认往左上角放(可能会重叠!)&lt;/li&gt;
&lt;li&gt;可以先放一个控件, 然后第二个控件指定其相对位置&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;实现方法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;android:layout_below/layout_above等等等等... 放置在其左(右)边; 属性的值都是其他控件的id&lt;/li&gt;
&lt;li&gt;android:id="@+id/tvv1"是创建一个新id; android:layout_toRightOf="@id/tvv1"则是引用已有的id(没有加号)&lt;/li&gt;
&lt;li&gt;android:layout_alignLeft/Right等等等等..... 左(右)对齐; 属性的值都是其他控件的id  &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;S01E14: 相对布局II&lt;/h1&gt;
&lt;h4&gt;对齐到基准线&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;基准线:为了保证印刷字母的整齐而划定的线 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;第三条线就是所谓的基准线(baseline)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ex. 两个TextView__的基准线__相互对齐&lt;/li&gt;
&lt;li&gt;作用: 当俩TextView的字体大小不相同时...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;h4&gt;和父控件对齐&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;android:layout_alignParentLeft/Right等等... 属性的值为true/false(因为只有一个直接父控件)&lt;/li&gt;
&lt;li&gt;android:layout_centerInParent/layout_centerHorizontal等等...&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;S01E15: 相对布局III&lt;/h1&gt;
&lt;h4&gt;RelativeLayout布局的新属性(Android 4.2)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;android:layout_alignStart/End等 值是其他控件的id, 头部和尾部对齐&lt;/li&gt;
&lt;li&gt;android:layout_alignParentStart/End, 值是true/false&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;相对布局小练习&lt;/h4&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image014.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码片段:&lt;/strong&gt; &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt; &lt;span class="nt"&gt;&amp;lt;RelativeLayout&lt;/span&gt;
            &lt;span class="na"&gt;android:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@+id/RL0&amp;quot;&lt;/span&gt;
            &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;fill_parent&amp;quot;&lt;/span&gt;
            &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;fill_parent&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

            &lt;span class="nt"&gt;&amp;lt;TextView&lt;/span&gt;
                &lt;span class="na"&gt;android:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@+id/tv1&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_centerHorizontal=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:gravity=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;center&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:text=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;login...&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:textSize=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;16sp&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

            &lt;span class="nt"&gt;&amp;lt;EditText&lt;/span&gt;
                &lt;span class="na"&gt;android:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@+id/editText1&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_below=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@id/tv1&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_centerHorizontal=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:ems=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;10&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:hint=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;username&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

                &lt;span class="nt"&gt;&amp;lt;requestFocus&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/EditText&amp;gt;&lt;/span&gt;

            &lt;span class="nt"&gt;&amp;lt;EditText&lt;/span&gt;
                &lt;span class="na"&gt;android:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@+id/editText2&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_below=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@id/editText1&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_centerHorizontal=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:ems=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;10&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:hint=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;password&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:inputType=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;textPassword&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

            &lt;span class="nt"&gt;&amp;lt;Button&lt;/span&gt;
                &lt;span class="na"&gt;android:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@+id/button1&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_alignParentRight=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_below=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@+id/editText2&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:text=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;login&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

            &lt;span class="nt"&gt;&amp;lt;Button&lt;/span&gt;
                &lt;span class="na"&gt;android:id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@+id/button2&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_below=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@+id/editText2&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:layout_toLeftOf=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;@+id/button1&amp;quot;&lt;/span&gt;
                &lt;span class="na"&gt;android:text=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;cancel&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;](file:///%3E)
 &lt;span class="nt"&gt;&amp;lt;/RelativeLayout&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;S01E16: 时间和日期 TimePicker/DatePicker&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;TimePicker/&gt; &lt;DatePicker/&gt;标签&lt;/li&gt;
&lt;li&gt;文档: android.widget.TimePicker/android.widget.DatePicker&lt;/li&gt;
&lt;li&gt;OnTimeChangedListener的onTimeChanged函数: public void onTimeChanged(TimePicker view, int hourOfDay, int minute) 仨参数&lt;/li&gt;
&lt;li&gt;getCurrentHour(); getCurrentMinute(); getMonth(); getDayOfMonth()等函数, 同理有set函数......&lt;/li&gt;
&lt;li&gt;注意月份是从零算起!!&lt;/li&gt;
&lt;li&gt;setIs24HourView() 切换24小时显示&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;S01E17: 进度条ProgressBar&lt;/h1&gt;
&lt;h4&gt;各种进度条&lt;/h4&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image015.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image016.png" /&gt;&lt;/p&gt;
&lt;h4&gt;进度条的属性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;风格Style: 转圈圈: 垂直风格(默认); 一条线的进度条: Horizontal&lt;/li&gt;
&lt;li&gt;最大值: max&lt;/li&gt;
&lt;li&gt;当前进度:progress&lt;/li&gt;
&lt;li&gt;次要进度的值:SecondaryProgress (ex.次要进度: 解压缩文件时, 在线看视频时...)&lt;/li&gt;
&lt;li&gt;isIndeterminate()断进度条时不时不明确的(打酱油的, 比如转圈圈), 同理有set方法, 不过只能对水平风格适用.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;S01E18: SeekBar和RatingBar&lt;/h1&gt;
&lt;h4&gt;SeekBar&lt;/h4&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image017.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性: max/progress/&lt;/li&gt;
&lt;li&gt;监听器接口OnSeekBarChangeListener有三个函数要重写: &lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;class&lt;/span&gt; &lt;span class="nt"&gt;SeekBarListener&lt;/span&gt; &lt;span class="nt"&gt;implements&lt;/span&gt; &lt;span class="nt"&gt;OnSeekBarChangeListener&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="c"&gt;/**&lt;/span&gt;

&lt;span class="c"&gt;* seekBar 该对象指的是触发了监听器的SeekBar对象&lt;/span&gt;
&lt;span class="c"&gt;* progress 指的是当前SeekBar的进度&lt;/span&gt;
&lt;span class="c"&gt;* fromUser 指是不是用户手动改变的进度&lt;/span&gt;

&lt;span class="c"&gt; */&lt;/span&gt;
&lt;span class="cp"&gt;@Override&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;onProgressChanged&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SeekBar&lt;/span&gt; &lt;span class="n"&gt;SeekBar&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;progress&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;fromUser&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;progress:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;progress&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;,fromUser:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fromUser&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;@Override&lt;/span&gt;
&lt;span class="nt"&gt;public&lt;/span&gt; &lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;onStartTrackingTouch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;SeekBar&lt;/span&gt; &lt;span class="nt"&gt;seekBar&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nt"&gt;System&lt;/span&gt;&lt;span class="nc"&gt;.out.println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;onStart&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;@Override&lt;/span&gt;
&lt;span class="nt"&gt;public&lt;/span&gt; &lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;onStopTrackingTouch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;SeekBar&lt;/span&gt; &lt;span class="nt"&gt;seekBar&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nt"&gt;System&lt;/span&gt;&lt;span class="nc"&gt;.out.println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;onStop&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;RatingBar&lt;/h4&gt;
&lt;p&gt;&lt;img alt="" src="./android开发教程第一季笔记/pasted_image018.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性: numStars(星星个数), progress, stepSize(步进)&lt;/li&gt;
&lt;li&gt;监听器代码:&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;class&lt;/span&gt; &lt;span class="nt"&gt;RatingBarListener&lt;/span&gt; &lt;span class="nt"&gt;implements&lt;/span&gt; &lt;span class="nt"&gt;OnRatingBarChangeListener&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="cp"&gt;@Override&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;onRatingChanged&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RatingBar&lt;/span&gt; &lt;span class="n"&gt;ratingBar&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;rating&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;fromUser&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;rating:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;rating&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;,fromUser:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fromUser&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;</summary><category term="android"></category></entry><entry><title>我的ubuntu10.04配置总结</title><link href="http://x-wei.github.io/%E6%88%91%E7%9A%84ubuntu10.04%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93.html" rel="alternate"></link><updated>2013-07-20T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/我的ubuntu10.04配置总结.html</id><summary type="html">&lt;p&gt;ubuntu已经出到了13.04, 我之所以坚持使用ubuntu10.04的版本(到现在已经三年了, 现在10.04已经过了支持周期而我还在继续用它), 主要是因为ubuntu出的unity界面以及gnome3的界面实在是用起来不爽(吐槽不已!!)... &lt;/p&gt;
&lt;p&gt;目前我的lucid(ubuntu 10.04)经过我的配置, 在我用来已经十分顺手了.. 不过长久这么下去也不是办法...... 在换新的主力系统之前, 把我目前这个系统的配置写下来.&lt;/p&gt;
&lt;h2&gt;安装的软件&lt;/h2&gt;
&lt;p&gt;写一下用起来特别爽的一些软件: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;geany&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;万能IDE&lt;/strong&gt;, java/python/Cpp/matlab(octave)... 甚至tex都是用它写的, 轻巧强大. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zim桌面维基&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;神器&lt;/strong&gt;, 用来写笔记整理思路, 这篇就是在zim下写的. 自从2012年发现zim这个东西以后, 到现在写了上百条笔记了, 确实方便.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GNU octave&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;matlab的开源替代, 语法和matlab完全兼容, 毕设就是用它做的, 如果不用matlab工具箱的话, 这个是很好的选择, 而且比较小巧, 启动很快.
......不过法国人貌似比较喜欢他们自己搞出来的scilab.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;音乐播放器audacious&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;界面和简洁, 用起来蛮好, 不过可能其他播放器也差不到哪里去...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;词典goldendict&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个还不是最新的版本(我用的是0.9.0), 已经相当顺手了. 可以自己加stardict的词典文件, 从网上可以找到很多(包括法语的词典), 用起来比stardict方便, 屏幕取词什么的也很好用.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GNOME Mplayer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;感觉这个界面简洁些, 可能其他播放器(VLC之类)也差不到哪里去.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QQ: wine-TM2009&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;地址在&lt;a href="http://www.mintos.org/network/wineqq.html"&gt;这里&lt;/a&gt;, 根据我的经验, 别再折腾了, 这个就是最好的解决方案...&lt;/p&gt;
&lt;h2&gt;配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;zip乱码解决&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前&lt;a href="http://x-wei.github.io/zip%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3.html"&gt;介绍过&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;外观&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;globalmenu+windowbuttons&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装这两个插件以后, 可以真的&lt;strong&gt;最大化&lt;/strong&gt;利用屏幕空间, 很科学...(貌似是跟苹果学的?)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义的主题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Faenza图标主题; elementary窗口主题; ComixCursors鼠标主题; clearlooks控件...
总之这大概就是我觉得最舒服的外观主题了...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;边缘触发动作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;compiz的设置, 把鼠标移动到左下角会显示桌面, 很方便...(貌似是跟苹果学的?)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;compiz特效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;立方体特效, 开四个桌面(这个其实很实用, 尤其是开十个以上窗口时......);
动画特效, "对所有事件使用随机动画"(这个开了以后效果惊艳, 而且即使老电脑开了这个一点也不会卡, 完爆win...);
其他特效还没全开...... &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;护眼背景色(gnome+chrome)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://x-wei.github.io/gnome-background.html"&gt;gnome的设置&lt;/a&gt;;
&lt;a href="http://x-wei.github.io/gnome-background.html"&gt;chrome的设置&lt;/a&gt;;&lt;/p&gt;
&lt;h3&gt;快捷键&lt;/h3&gt;
&lt;p&gt;总结一下配置的快捷键: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示桌面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;win+D&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开浏览器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;win+B (取"&lt;strong&gt;B&lt;/strong&gt;rowser"之意)
关联的命令是&lt;code&gt;google-chrome&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开文件管理器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;win+F (取"&lt;strong&gt;F&lt;/strong&gt;ile"之意)
命令: &lt;code&gt;nautilus --browser /home/your_username&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开goldendict&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ctrl+alt+D&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;截图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;win+S
命令是: &lt;code&gt;gnome-screenshot -ia&lt;/code&gt;
这个之前也&lt;a href="http://x-wei.github.io/scrshot-shortcut.html"&gt;写过&lt;/a&gt;.&lt;/p&gt;</summary><category term="ubuntu"></category><category term="外观"></category><category term="快捷键"></category></entry><entry><title>ssh远程登录学校机房电脑</title><link href="http://x-wei.github.io/ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E6%9C%BA%E6%88%BF%E7%94%B5%E8%84%91.html" rel="alternate"></link><updated>2013-07-02T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/ssh远程登录学校机房电脑.html</id><summary type="html">&lt;p&gt;X&lt;a href="http://www.enseignement.polytechnique.fr/profs/informatique/Philippe.Chassignet/MOYENS/stations.html"&gt;机房的电脑&lt;/a&gt;配置还是很高的, 所以...&lt;/p&gt;
&lt;p&gt;远程登录的命令是: 
    ssh -X nom.prenom@truite.polytechnique.fr&lt;/p&gt;
&lt;p&gt;(-X命令表示允许使用X程序.)&lt;/p&gt;
&lt;p&gt;登录进去以后, 可以在终端里输入命令, 比如查看系统板本: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt; lsb_release -a
LSB Version:    :core-4.0-ia32:core-4.0-noarch:graphics-4.0-ia32:graphics-4.0-noarch:printing-4.0-ia32:printing-4.0-noarch
Distributor ID: n/a
Description:    CentOS
Release:    n/a
Codename:   n/a
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;机房是centOS, 高效稳定. &lt;/p&gt;
&lt;p&gt;然后可以在终端输入命令来启动程序, 比如&lt;code&gt;eclipse &amp;amp;,&lt;/code&gt;就会在你这边的电脑显示出来eclipse的窗口 (加"&amp;amp;"是可以使多个程序同时启动).&lt;/p&gt;
&lt;p&gt;另外, 远程拷贝到本地:
    scp xing.wei@france.polytechnique.fr:/users/eleves-b/x2012/xing.wei/  /home/wx
几个常用的程序: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;eclipse &amp;amp;
scilab &amp;amp; 
firefox &amp;amp;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可惜不知道咋能显示远程的桌面, 不过这也差不多够了, 以后用eclipse或者scilab这类比较"大"的程序, 直接用机房的工作站做好了...&lt;/p&gt;</summary><category term="shell"></category></entry><entry><title>网页图片自动适应浏览器宽度</title><link href="http://x-wei.github.io/%E7%BD%91%E9%A1%B5%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E9%80%82%E5%BA%94%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%BD%E5%BA%A6.html" rel="alternate"></link><updated>2013-03-28T20:36:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/网页图片自动适应浏览器宽度.html</id><summary type="html">&lt;p&gt;眼看三月又要结束了, blog还没有更新, 拿来以前写在zim里的一条笔记充数... &lt;/p&gt;
&lt;p&gt;有了zim以后, 几乎不再用office了, 常用它编辑一些富文本, 比如加粗, 下划线, 斜体什么的, 有快捷键操作, 很方便, 插图也很简单. zim是我认为的神器(神器=小巧+强大)之一. &lt;/p&gt;
&lt;p&gt;有时候用zim写好的笔记给别人看时, 直接按"ctrl+p"就可以打印成网页的格式了, 非常方便(而且得承认, 单论富文本的显示效果, 网页格式 &amp;gt; pdf格式 &amp;gt; doc格式). 只是有一点不太好, 就是有时插入的照片很大, 在浏览器里查看的时候显示的还是原尺寸图像, 非常方便...&lt;/p&gt;
&lt;p&gt;查了一下, 其实只要在html文件关于插入图片那一行加入&lt;code&gt;width="100%" height="100%" style="z-index:-100"&lt;/code&gt;就可以了.&lt;/p&gt;
&lt;p&gt;比如, 在zim生成的html文件里, 这样替换就可以了: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;img src="./xxx网页_files/IMG_1186.JPG" alt="" &amp;gt;&amp;lt;br&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;⇒&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;img src="./xxx网页_files/IMG_1186.JPG" alt="" width="100%" height="100%" style="z-index:-100"&amp;gt;&amp;lt;br&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即进行替换:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;" alt=""&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;⇒&lt;/p&gt;
&lt;p&gt;&lt;code&gt;" alt="" width="100%" height="100%" style="z-index:-100"&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个我倒是时常用到, 比如给家人发最近活动的照片时 , 可以用zim写上一些文字作为照片的注释, 然后生成网页文件然后打包发掉...&lt;/p&gt;
&lt;p&gt;OK, 水文结束...&lt;/p&gt;</summary></entry><entry><title>passé simple时态变位总结</title><link href="http://x-wei.github.io/passesimple%E6%97%B6%E6%80%81%E5%8F%98%E4%BD%8D%E6%80%BB%E7%BB%93.html" rel="alternate"></link><updated>2013-02-19T20:35:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/passesimple时态变位总结.html</id><summary type="html">&lt;p&gt;passé simple 其实一点也不simple... 在Cherbourg时老师直接就没讲, 一是因为这个时态的变位很复杂; 二是现在这个时态几乎不用了, 除了出现在童话故事或人物传记中, 替代passé composé的位置... &lt;/p&gt;
&lt;p&gt;可是回到X之后的法语课上却学了... 这周一还有针对passé simple的考试... 这是上周末总结的passé simple 的一些变位规则, 发现其实这个时态的变位也不是很难(原因见下文), 只不过一般不用, 所以容易忘吧~&lt;/p&gt;
&lt;h2&gt;I. 词尾&lt;/h2&gt;
&lt;p&gt;passé simple 的变位词尾可以分为种四类型, 我把它们叫做"A型", "I型", "U型", 和"IN型", 别看四种类型, 其实很容易记的. &lt;/p&gt;
&lt;h3&gt;四种"类型"&lt;/h3&gt;
&lt;p&gt;先把这四种类型的词尾写下来: &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A型&lt;/strong&gt; &lt;u&gt;ai&lt;/u&gt;-&lt;u&gt;as&lt;/u&gt;-&lt;u&gt;a&lt;/u&gt;-â&lt;strong&gt;mes&lt;/strong&gt;-â&lt;strong&gt;tes&lt;/strong&gt;-&lt;u&gt;è&lt;/u&gt;&lt;strong&gt;rent&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I型&lt;/strong&gt; i&lt;strong&gt;s&lt;/strong&gt;-i&lt;strong&gt;s&lt;/strong&gt;-i&lt;strong&gt;t&lt;/strong&gt;-î&lt;strong&gt;mes&lt;/strong&gt;-î&lt;strong&gt;tes&lt;/strong&gt;-i&lt;strong&gt;rent&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;U型&lt;/strong&gt; u&lt;strong&gt;s&lt;/strong&gt;-u&lt;strong&gt;s&lt;/strong&gt;-u&lt;strong&gt;t&lt;/strong&gt;-û&lt;strong&gt;mes&lt;/strong&gt;-û&lt;strong&gt;tes&lt;/strong&gt;-u&lt;strong&gt;rent&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IN型&lt;/strong&gt; in&lt;strong&gt;s&lt;/strong&gt;-in&lt;strong&gt;s&lt;/strong&gt;-in&lt;strong&gt;t&lt;/strong&gt;-în&lt;strong&gt;mes&lt;/strong&gt;-în&lt;strong&gt;tes&lt;/strong&gt;-in&lt;strong&gt;rent&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;看看还是很有规律的嘛, 用X代表"&lt;strong&gt;X类型&lt;/strong&gt;"的词尾的话, 那么词尾可以统一写成: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;X&lt;strong&gt;s&lt;/strong&gt;-X&lt;strong&gt;s&lt;/strong&gt;-X&lt;strong&gt;t&lt;/strong&gt;-X(加^)&lt;strong&gt;mes&lt;/strong&gt;-X(加^)&lt;strong&gt;tes&lt;/strong&gt;-X&lt;strong&gt;rent&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;简记法:&lt;/h3&gt;
&lt;p&gt;s-s-t是第二组动词的présent变位词尾, 对于nous的变位, 正好是"som&lt;strong&gt;mes&lt;/strong&gt;"的词尾, vous正好是"ê&lt;strong&gt;tes&lt;/strong&gt;"的词尾, ils的话... 没找到记忆的办法, 就记住吧, 是"rent"&lt;/p&gt;
&lt;p&gt;而对于A型词尾, 有一些特例, 比如前三个人称是-ai-as-a, 这个其实好记, 因为是动词"avoir"的présent变位词尾(与future simple一样), 另外得记住A型的ils变位时不是-Xrent而是-èrent.&lt;/p&gt;
&lt;h2&gt;II. 四种词尾对应的单词&lt;/h2&gt;
&lt;p&gt;如果能把这四种词尾记住, &lt;strong&gt;而且已经记住了这个单词的过去分词形式(p.p.)&lt;/strong&gt;, 那么记忆哪个单词对应哪一种词尾其实蛮简单的. 
下面看看这四种词尾都对应那些动词:&lt;/p&gt;
&lt;h3&gt;一). A型(ai-as-a-âmes-âtes-èrent)&lt;/h3&gt;
&lt;p&gt;对应于:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TOUS les verbes au p.p. en -é (sauf être).&lt;/strong&gt; // 所有过去分词以-é结尾的动词(être除外).&lt;/p&gt;
&lt;p&gt;语法书里忘记了naître了... 不过这个应该属于特殊情况...&lt;/p&gt;
&lt;p&gt;即对应1er groupe的单词, c'est le plus normal. 例子太多了不列了...&lt;/p&gt;
&lt;h3&gt;二). I型(is-is-it-îmes-îtes-irent)&lt;/h3&gt;
&lt;p&gt;对应于以下四类(其实可以说是三类... 其实很好记的...)...&lt;/p&gt;
&lt;h5&gt;1. la majorité des verbes au p.p. en -i. // 大部分p.p.以-i结尾的动词.&lt;/h5&gt;
&lt;p&gt;这就是我叫它"I型"的另外一个原因!!! 下面的"U型"也是同样的! 所以只要记住动词的p.p.(过去分词形式), 改写成passé simple也不麻烦的!~&lt;/p&gt;
&lt;p&gt;这里, 语法书里说的是"la majorité ", 但是我觉得把它改成"TOUS"也没有问题...&lt;/p&gt;
&lt;h5&gt;2. certain nombre de verbes au p.p. en -u // 一些p.p.以-u结尾的动词&lt;/h5&gt;
&lt;p&gt;语法书里举出的这些动词有： &lt;/p&gt;
&lt;p&gt;1) verbes en -endre, -ondre, -ompre, -ordre, -erdre&lt;/p&gt;
&lt;p&gt;总之就是一些&lt;strong&gt;-re&lt;/strong&gt;结尾的... 例如:
    répondre , entendre, éteindre...
2) voir&lt;/p&gt;
&lt;p&gt;其实是不规则动词, 在后面还会提到&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vis-vis-vit-vîmes-vîtes-virent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3) vaincre&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vainquis-vainquis-vainquit-vainquîmes-vainquîtes-vainquirent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个不常用, 干脆可以不记住... 倒不如记一下naître也是I型的:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;naquis-naquis-naquit-naquîmes-naquîtes-naquirent&lt;/code&gt;&lt;/p&gt;
&lt;h5&gt;3. offrir, ouvrir&lt;/h5&gt;
&lt;p&gt;offrir和ouvrir在p.p.里也属于比较特殊的... 它们的p.p.分别是offert, ouvert:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;offris-offris-offrit-offrîmes-offrîtes-offrirent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;还有特例是-(a)indre, -oindre的, 比如eteindre, 但是这个词变位的词根也变了, 是&lt;strong&gt;eteign-&lt;/strong&gt;... 太特殊了又不常用, 所以干脆别记了...&lt;/p&gt;
&lt;h5&gt;4. p.p.以-is/it结尾的动词&lt;/h5&gt;
&lt;p&gt;(这一条是我总结的 不一定对)&lt;/p&gt;
&lt;p&gt;我发现如果这个动词的p.p.含有-&lt;strong&gt;i&lt;/strong&gt;t/-&lt;strong&gt;i&lt;/strong&gt;s词尾的话, 那么它的passé simple变位就是&lt;strong&gt;I&lt;/strong&gt;型的了(所以"I型" "U型"这个名字起的好啊....).&lt;/p&gt;
&lt;p&gt;例子: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;dire, mettre, prendre&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实第四条可以和第一条合并&lt;/strong&gt;: 如果p.p.结尾是-i或-is或-it的话, 词尾就是I型的了~&lt;/p&gt;
&lt;p&gt;唉, 又发现例子的这些单词也都是-re结尾的, 不过它们的p.p.的词尾不是-u, 所以第二条不能合并进来...&lt;/p&gt;
&lt;h3&gt;三). U型(us-us-ut-ûmes-ûtes-urent)&lt;/h3&gt;
&lt;h5&gt;1. la majorité des verbes au p.p. en -u// 大部分p.p.以-u结尾的动词&lt;/h5&gt;
&lt;p&gt;这里的"la majorité "不能改成"tous"了, 在I型里就有几个动词的p.p.是-u结尾的(-re的,以及voir). 
见到p.p.是-u结尾的, 然后原型又不是那几个-re结尾的动词, 就是U型了!&lt;/p&gt;
&lt;p&gt;例子: 
 &lt;code&gt;courir, connaître, recevoir&lt;/code&gt;&lt;/p&gt;
&lt;h5&gt;2. 再加一个特例: mourir&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;mourus-mourus-mourut-mourûmes-mourûtes-moururent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其实还有个特例是être, 后面不规则动词里讲...&lt;/p&gt;
&lt;h3&gt;四). IN型(ins-ins-int-înmes-întes-inrent)&lt;/h3&gt;
&lt;p&gt;这个可以当作特例记了, 只有俩: venir, tenir(当然还有它们的派生词...), 这俩词的p.p.是-u结尾的... 好吧U型又多了俩特例...&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vins- vins-vint-vînmes-vîntes-vinrent&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;III. 一些不规则动词&lt;/h2&gt;
&lt;p&gt;虽然词尾只有那四种, 比较有规律, 但是有时候一些不规则动词的&lt;strong&gt;词根&lt;/strong&gt;不是很有规律(&lt;strong&gt;一般来说, 词根是是p.p.的词根&lt;/strong&gt;). 这些常用的不规则动词有: &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;être: &lt;code&gt;p.p.=été&lt;/code&gt;; &lt;code&gt;词根f-; 词尾U型&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;faire: &lt;code&gt;p.p.=fait&lt;/code&gt;; &lt;code&gt;词根f-&lt;/code&gt;; &lt;code&gt;词尾I型&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;voir: &lt;code&gt;p.p.=vu&lt;/code&gt;; &lt;code&gt;词根v-&lt;/code&gt;; &lt;code&gt;词尾I型&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;naître: &lt;code&gt;p.p.= né&lt;/code&gt;; &lt;code&gt;词根naiqu-&lt;/code&gt;; &lt;code&gt;词尾I型&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;avoir: &lt;code&gt;p.p.=eu&lt;/code&gt;; &lt;code&gt;词根e-&lt;/code&gt;; &lt;code&gt;词尾U型&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;mourir: &lt;code&gt;p.p.=mort&lt;/code&gt;; &lt;code&gt;词根mour-&lt;/code&gt; ; &lt;code&gt;词尾U型&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;offrir, ouvrir: &lt;code&gt;p.p.=offert, ouvert&lt;/code&gt;; &lt;code&gt;词根 offr-, ouvr-&lt;/code&gt;; &lt;code&gt;词尾I型&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;venir, tenir: &lt;code&gt;p.p.=venu, tenu&lt;/code&gt;; &lt;code&gt;词根 v-&lt;/code&gt;, &lt;code&gt;t-; 词尾IN型&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些词比较常用, 所以最好记一下. &lt;/p&gt;
&lt;p&gt;我发现passé simple也不是很麻烦的另一个原因是: &lt;strong&gt;这些词都是1base的!! &lt;/strong&gt; 变位只有一个词根, 和那有两三个词根的présent时态相比, 确实是simple多了... &lt;/p&gt;
&lt;h2&gt;IV. 小结&lt;/h2&gt;
&lt;p&gt;这样总结下来, passé simple也不是特别困难, 有不少规律可循... 不过话又说回来了, 这个时态用得实在是很少... &lt;/p&gt;
&lt;p&gt;另外, linux下用goldendict查法语单词+verbiste查动词变位效果蛮好的! :)&lt;/p&gt;</summary><category term="french"></category></entry><entry><title>Au revoir, Cherbourg</title><link href="http://x-wei.github.io/aurevoir-cherbourg.html" rel="alternate"></link><updated>2013-01-29T21:41:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/aurevoir-cherbourg.html</id><summary type="html">&lt;p&gt;&lt;img alt="" src="./aurevoir-cherbourg/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;任何一种环境或一个人, 初次见面就预感到离别的隐痛时, 你必定爱上他了.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我是在来Cherbourg的第二天突然想起这句话的. &lt;/p&gt;
&lt;p&gt;那天是29-09-2012, 在德先生和赛先生的带领下, 我们在Cherbourg市中心悠闲地溜达了一个下午, 那天阳光很好. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./aurevoir-cherbourg/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;p&gt;时间过得好快, 四个月过去了, 明天早上就是道别的时候了. 四个月留下了不尽的回忆......&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cherbourg的海风, 雨水, 长堤...&lt;/li&gt;
&lt;li&gt;centre-ville的街道, 以及停泊了许多小船的港口&lt;/li&gt;
&lt;li&gt;EFQ的海鸥&lt;/li&gt;
&lt;li&gt;Guichen &lt;/li&gt;
&lt;li&gt;喇叭里每天的通知("dans 5 minutes, appelle du personnage de service et des gens sonctionne", "attention pour la couleur...")&lt;/li&gt;
&lt;li&gt;每天在楼下等我们的Devailly先生, 我猜想年轻时一定很帅的Stricot先生&lt;/li&gt;
&lt;li&gt;les prof: 有N件毛衣的Sylvain, 漂亮的Stéphanie, 美食专家以及"动词变位女王"Brigitte, 搞怪的Lydia, 家庭美满幸福的Nolwenn......&lt;/li&gt;
&lt;li&gt;在Cherbourg的海边公路上慢跑, 一跑就是四十分钟&lt;/li&gt;
&lt;li&gt;Foule de la press长跑&lt;/li&gt;
&lt;li&gt;窗外的海滩, 悠闲的奶牛, 远处小丘上的教堂...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./aurevoir-cherbourg/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;几乎每周的体育课都不一样&lt;/li&gt;
&lt;li&gt;餐桌礼仪介绍, 葡萄酒介绍, 布列塔尼风情介绍...&lt;/li&gt;
&lt;li&gt;数不清的sorties: Mont-Saint-Michel, 出海, Manche的城堡, Hague, AREVA, 报社......&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./aurevoir-cherbourg/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Florence和她的孩子们, 圣诞和新年的美好回忆&lt;/li&gt;
&lt;li&gt;Atelier Théâtre, 以及许多的spectacle&lt;/li&gt;
&lt;li&gt;Atelier Cinéma, &amp;lt;&amp;lt;瑟堡的雨伞&amp;gt;&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./aurevoir-cherbourg/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;p&gt;AND THAT'S THE END......&lt;/p&gt;
&lt;p&gt;明天早上就要走了, 我觉得在最后几天里, 我已经很好地向Cherbourg以及这里的可爱的人们道别... 世界很大, 也许我们有一天还会再相遇...... bon courage à vous tous, et à bientôt , Cherbourg! Vous allez me manquer... 相遇又离别总是难免的, 不过我要好好的和他们道别...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AU REVOIR, CHER BOURG!...&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;下一站: Palaiseau!&lt;/p&gt;</summary><category term="fr"></category></entry><entry><title>读 &lt;&lt;当我谈跑步时我谈什么&gt;&gt;</title><link href="http://x-wei.github.io/%E8%AF%BB%E5%BD%93%E6%88%91%E8%B0%88%E8%B7%91%E6%AD%A5%E6%97%B6%E6%88%91%E8%B0%88%E4%BB%80%E4%B9%88.html" rel="alternate"></link><updated>2012-12-22T09:27:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/读当我谈跑步时我谈什么.html</id><summary type="html">&lt;p&gt;上个月读的这本书, 后来简单写了点东西(其实主要是摘抄啦...). 圣诞来到住家, blog很久没更新了, 放上来充数...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;嗯, 这本书不错, 心乱的时候读一两章蛮好.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;感觉村上春树绝对是一个精神上强大的人, 虽然他的语气平和而谦逊.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这不是一本很文艺的书(所以我很快就读完了), 都是很朴实的语言, 像坐在火炉边和你谈话一样, 喜欢.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一百千米超级马拉松太恐怖了... &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跑步时心理的变化过程: 跑前决定一定要跑个好成绩; 开始跑觉得很轻松; 跑到半成以为会是一个好成绩; 跑到最后心里只剩下厌恶--该死的路程怎么还不结束!! &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;摘抄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;下面这话颇类狡辩，更令人惶恐：尽管这是一部谈论跑步的书，却不是谈论健康方法的书。我并非要在这里高谈阔论、振臂一呼：“来呀!让我们每天跑步，永葆健康吧!”归根结底，这些都不过是思索片段，抑或自问自答——对我个人而言．坚持跑步究竟有何意味。仅此而已。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;即使不足以称为“哲学”，然而我以为，这里面含有_些类似经验法则的东西。一些无甚大不了的玩意儿，却是我通过实实在在地运动自己的躯体，通过作为选择的磨难，极其私人地感悟到的东西。也许并不值得推而广之，但无论如何，这，就是我这个人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;跑步对我来说，不独是有益的体育锻炼，还是有效的隐喻。我每日一面跑步，或者说一面积累参赛经验，一面将目标的横杆一点点地提高，通过超越这高度来提高自己。至少是立志提高自己，并为之日日付出努力。我固然不是了不起的跑步者，而是处于极为平凡的——毋宁说是凡庸的——水准。然而这个问题根本不重要。我超越了昨天的自己，哪怕只是那么一丁点儿，才更为重要。在长跑中，如果说有什么必须战胜的对手，那就是过去的自己。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;跑步时浮上脑际的思绪，很像天际的云朵，形状各异，大小不同。它们飘然而来，又飘然而去。然而天空犹自是天空，一成不变。云朵不过是匆匆过客，它穿过天空，来了去了。唯有天空留存下来。所谓天空，是既在又不在的东西，既是实体又不是实体。对于天空这种广漠容器般的存在状态，我们唯有照单收下，全盘接受。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;我基本是如此思考，并依循着这样的思考度过人生。就结果而言，在某种程度上，我也许是主动地追求孤绝。对于操我这种职业的人来说，尽管有着程度上的差异，这却是无法绕道回避的必经之路。这种孤绝之感，会像不时从瓶中溢出的酸一般，在不知不觉中腐蚀人的心灵，将之溶化。这是一把锋利的双刃剑，回护人的心灵，也细微却不间歇地损伤心灵的内壁。这种危险，我们大概有所体味，心知肚明。唯其如此，我才必须不间断地、物理性地运动身体，有时甚至穷尽体力，来排除身体内部负荷的孤绝感。说是着意如此，毋宁说凭着直觉行事。&lt;/p&gt;
&lt;p&gt;让我说得更具体一点。&lt;/p&gt;
&lt;p&gt;当受到某人无缘无故(至少我看来是如此)的非难时，抑或觉得能得到某人的接受却未必如此时，我总是比平日跑得更远一些。跑长于平日的距离，让肉体更多地消耗一些，好重新认识自己乃是能力有限的软弱人类——从最深处，物理性地认识。并且，跑的距离长于平日，便是强化了自己的肉体，哪怕是一点点。发怒的话，就将那份怒气冲着自己发好了。感到懊恼的话，就用那份懊恼来磨炼自己好了。我便是如此思考的。能够默默吞咽下去的东西，就一星不剩地吞咽进体内，在小说这一容器中，尽力改变其姿态形状，将它作为故事的一部分释放出去。我努力做到这一点。我并不认为这样一种性格讨人喜爱，恐怕有极少人赏识，却难得讨大众欢喜。对于这样一个缺乏协调性的人，一遇上事情就想独自躲进壁橱里的人，有谁会抱有好意呢?一个职业小说家讨人喜爱这种事，难道真有可能么?不得而知。或许在世界某个地方有，但恐怕很难推而广之。至少我很难想象，自己作为一个小说家，成年累月不断地写小说，同时又能为人私下里喜爱。为人嫌恶、憎恨、轻蔑，似乎倒是更为自然的事情。我也并不打算说：这样的话，我反而感到放心。即便是我，也没有赏玩他人的嫌恶的爱好。那是另外的事，还是来谈谈跑步吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;人生基本是不公平的。此乃不刊之论。即便身处不公之地，我以为亦可希求某种“公正”。许得费时耗力；甚或费了时耗了力，却仍是枉然。这样的“公平”，是否值得刻意希求，当然要靠各人自己裁量了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;时隔许久重读这篇文章，我发现一个事实：二十多年已经逝去，我也跑过了几乎与年数相等的全程马拉松赛次，可是跑四十二公里后感受到的，与最初那一次相比，似乎没有多大变化。现在依然如故，每次跑马拉松，我大体都会经历相同的心路。跑到三十公里，总觉得“这次没准儿会出好成绩呢”。过了三十五公里，体内的燃料便消耗殆尽，开始对各种事物大为光火。到了最后，则生出“揣着空空如也的汽油箱不停行驶的汽车”般的心情。然而跑完之后少顷，曾经的痛苦、可悲的念头眨眼间忘得一千二净，还下定决心：“下次我要跑得更好!”任凭积累了多少经验，增添了几岁，还是一再重复相同的旧事。 &lt;/p&gt;
&lt;p&gt;是的，这种模式无论如何都不接受改变，我以为。如若必须同这种模式和平共处，我只能通过执著的反复，改变或是扭曲自己，将它吸收进来，成为人格的一部分。 &lt;/p&gt;
&lt;p&gt;哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;倘若一连几天都不给它负荷，肌肉便会自作主张：“哦，没必要那般努力了。啊呀，太好了。”遂自行将承受极限降低。肌肉也同有血有肉的动物一般无二，它也愿意过更为舒服的日子，不继续给它负荷，它便会心安理得地将记忆除去。想再度输入的话，必得从头开始，将同样的模式重复一遍。休息是必要的。然而，比赛迫在眼前的重要时期，要严肃地给肌肉下达最后通牒，将毫不含混的信息传达给它：“这可是一丝一毫也马虎不得的!“当然不能让它超负荷，但一定得与它维持着绝不松懈的紧张关系。处理个中的勾心斗角，有经验的跑者自然得心应手。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;世上时时有人嘲笑每日坚持跑步的人：“难道就那么盼望长命百岁?”我却以为，因为希冀长命百岁而跑步的人，大概不太多。怀着“不能长命百岁不打紧，至少想在有生之年过得完美”这种心情跑步的人，只怕多得多。同样是十年，与其稀里糊涂地活过，目的明确、生气勃勃地活当然令人远为满意。跑步无疑大有魅力：在个人的局限性中，可以让自己有效地燃烧——哪怕是一丁点儿，这便是跑步一事的本质，也是活着(在我来说还有写作)一事的隐喻。这样的意见，恐怕会有很多跑者予以赞同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;跑全程马拉松时，到了最后关头，脑子里充溢的全是一个念头：赶快跑过终点，赶快结束!此外什么都无法考虑。此时此刻，我却不曾想过这一点。我觉得，所谓结束，不过是暂时告一段落，并无太大的意义。就同活着一样。并非因为有了结束，过程才具有意义。而是为了便宜地凸显过程这玩意儿的意义，抑或转弯抹角地比喻其局限性，才在某一个地点姑且设置一个结束。相当地哲学。不过当时我一点也没觉得这很哲学。这不是通过语言，而是通过身体感受到的，不妨说是整体性地感受到的。跑进了最后的漫长的半岛状原生花园跑道，这种心情变得尤其强烈。跑法近似进入冥想状态。海边的景色十分美丽，可以感受到鄂霍次克海的气息。天色已近黄昏(出发是在清晨)，空气呈现出独特的清澄来，发出夏初深深的青草气味。还看见几只狐狸在原野中结集成群。它们好奇地望着参赛者。仿佛十九世纪英国风景画一般意味深长的云朵，沉稳地遮蔽了天空。风儿一丝也无。在我的周遭，许多人只是默默向着终点奔去。身处其中，我拥抱着异常静谧的幸福感。吸气，再吐气，听不出呼吸中有丝毫紊乱。空气非常平静地进入体内，再走出体外。我那寡言的心脏按照一定的速度重复着舒张与收缩。我的肺好似勤劳的风箱，规规矩矩将新鲜的氧气摄入体内。我能够目睹它们工作的身影，能够听见它们发出的声响。一切都顺畅无误地运转着。沿道的人们对着我们大声呼唤：“加油啊!马上就到终点啦!”声音像透明的风，穿透了我的身体逝去。我感觉，人们的声音就这般穿透而过，直达身体另一面。 &lt;/p&gt;
&lt;p&gt;我是我，又不是我。这是一种异常沉稳而寂静的心情。意识之类并非多么重要的东西。固然，我是一个小说家，在工作上，意识这东西自是十分重要。没有它，主体性的故事便无缘诞生。尽管如此，我还是禁不住感到：意识之类并非大不了的玩意儿。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;我已经到了一定的年纪，时间自会拿走它那份额度，怨不得任何人。这就是游戏规则，就如同河水向着大海源源不断地流去一样。自己这种形象，我们只能当作自然光景的一部分，原封不动地接受。这也许不是令人愉快的事，从中发现的，或许也非值得欣喜若狂的东西。不过，这难道不是无可奈何的事情么?至此为止的人生，我好歹也大致——即便不能说是充分——享受了其中的乐趣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;我仰望天空。能看到一丝一毫的爱心么?不，看不到。只有太平洋上空悠然飘来浮去、无所事事的夏日云朵。云朵永远沉默无语。它们什么都不对我说。或许我不该仰望天空，应当将视线投去我的内部。我试着看向自己的内部，就如同窥视深深的井底。那里可以看到爱心么?不，看不到。看到的只有我的性格。我那个人的、顽固的、缺乏协调性的，每每任性妄为又常常怀疑自己的，哪怕遇到了痛苦也想在其中发现可笑之处的性格。我拎着它，就像拎着一个古旧的旅行包，踱过了漫长的历程。我并不是因为喜欢才拎着它。与内容相比，它显得太沉重，外观也不起眼，还到处绽开了线。我只是没有别的东西可拎，无奈才拎着它徘徊彷徨的。然而，我心中却对它怀有某种依依不舍的情感。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;不管有无效能，是否好看，对我们至关重要的东西，几乎都是肉眼无法看见，然而用心灵可以感受到的。而且，真正有价值的东西，往往通过效率甚低的营生方才获得。即便这是虚妄的行为，也绝不是愚蠢的行为。我如此认为，作为实在感受，作为经验法则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;成绩也好，名次也好，外观也好，别人如何评论也好，都不过次要的问题。对于我这样的跑者，第一重要的是用双脚实实在在地跑过一个个终点，让自己无怨无悔：应当尽的力我都尽了，应当忍耐的我都忍耐了。从那些失败和喜悦之中，具体地——如何琐细都没关系——不断汲取教训。并且投入时间投入年月，逐一地累积这样的比赛，最终到达一个自己完全接受的境界，抑或无限相近的所在。嗯，这个表达恐怕更为贴切。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;就这般，在长达四分之一个世纪里，日日都坚持跑步，各色各样的思绪从心底涌起。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这书里还有很多其他句子值得一抄...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;喜欢上了在Cherbourg的海边低头跑步的感觉...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>多张图片合并为pdf, 合并mp3, 批量压缩图片</title><link href="http://x-wei.github.io/%E5%9B%BE%E7%89%87%E5%90%88%E5%B9%B6%E4%B8%BApdf,%20%E5%90%88%E5%B9%B6mp3,%20%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87.html" rel="alternate"></link><updated>2012-11-16T19:47:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/图片合并为pdf, 合并mp3, 批量压缩图片.html</id><summary type="html">&lt;p&gt;前一阵遇到的三个小功能, linux下有简单的命令可以实现...&lt;/p&gt;
&lt;h2&gt;多张图片合并为pdf&lt;/h2&gt;
&lt;p&gt;这个在网上搜一般找到的结果是:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;convert *.jpg xx.pdf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是这么做的问题是, 运行起来超级慢, 电脑直接卡死!!!&lt;/p&gt;
&lt;p&gt;后来看了&lt;a href="http://pityonline.info/2009/12/%E7%BB%88%E4%BA%8E%E6%90%9E%E5%AE%9A%E4%BA%86%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%E4%B8%80%E4%BB%BDpdf%E6%96%87%E6%A1%A3%EF%BC%81/"&gt;这里&lt;/a&gt;, 知道了可以用pdfjam来做. 先要安装pdfjam, 然后:&lt;/p&gt;
&lt;p&gt;先将所有jpg文件重命名为pdf：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;rename &amp;#39;s/\.jpg$/\.pdf/&amp;#39; *.jpg
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;合成刚重命名的pdf文件为一份：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;pdfjoin $(ls *.pdf|sort -n) --outfile xx.pdf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;后来看到pdfjam其实是在用latex, 想到其实也可以先自动生成一个tex文件然后再调用tex生成pdf... 不过既然有现成的软件就直接用吧!!&lt;/p&gt;
&lt;h2&gt;合并mp3&lt;/h2&gt;
&lt;p&gt;超级简单的一条命令:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat *.mp3 &amp;gt; output.mp3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只要预先把文件按照想要的顺序编号即可
这个操作只是把这些文件前后连接起来, 可能是由于mp3文件格式的原因吧, 只要这么做了就和并完成了!! 而且速度快得惊人!!!&lt;/p&gt;
&lt;p&gt;不过有一点问题: 合并出来的mp3文件的信息(歌名, 艺术家之类)会是最后一个文件的信息... 当然这基本不影响使用~&lt;/p&gt;
&lt;h2&gt;批量压缩图片&lt;/h2&gt;
&lt;p&gt;使用convert命令, 好像是在ImageMagick里面.
参考&lt;a href="http://www.360doc.com/content/11/0704/16/2104556_131439876.shtml"&gt;这里&lt;/a&gt;:&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="nv"&gt;images&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;ls *.JPG&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;resize images begining...&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; image in &lt;span class="nv"&gt;$images&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
convert &lt;span class="nv"&gt;$image&lt;/span&gt; -resize 50% &lt;span class="nv"&gt;$image&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;resize &lt;/span&gt;&lt;span class="nv"&gt;$image&lt;/span&gt;&lt;span class="s2"&gt; to %50&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;span class="nb"&gt;exit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;然后就OK了... 顺便吐槽下gmail的附件大小限制!!...&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>Les fêtes chinoises en automne</title><link href="http://x-wei.github.io/Les-fetes-chinoises-en-automne.html" rel="alternate"></link><updated>2012-10-31T19:46:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/Les-fetes-chinoises-en-automne.html</id><summary type="html">&lt;p&gt;赶在十月最后一天发一篇水文...&lt;/p&gt;
&lt;p&gt;每年X新生的国际学生中会有一些人来到Cherbourg的&lt;a href="http://www.ecoledesfourriers.fr/"&gt;Ecole des Fourriers&lt;/a&gt;学习四个月的法语. 这四个月的时间也许是X四年里最轻松的一段时间了吧......&lt;/p&gt;
&lt;p&gt;今年有19名学生来Cherbourg, 历史最多. 我们每两周要自己出一份法语刊物, 算是促进写作水平吧, 基本上没啥人看...... 我们这年把杂志取名"MelangeXChange", 取各国文化交汇之意...&lt;/p&gt;
&lt;p&gt;第一期的杂志封面是这样的...&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./Les-fetes-chinoises-en-automne/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;把我和QY写的关于中秋和重阳的文章放上来吧, 很水......&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;Les Fêtes Chinoises en Automne&lt;/h1&gt;
&lt;h2&gt;La fête de la lune&lt;/h2&gt;
&lt;h2&gt;Origins&lt;/h2&gt;
&lt;p&gt;La fête de la lune procède du mythe de Chang’e(嫦娥). Chang’e est la femme de HouYi (后羿), un héros qui est très fort. HouYi obtient un élixir de longue vie de dieu. Un jour, ’un étudiant de HouYi qui voulait voler cet elixir à Chang’e quand HouYi n’était pas chez lui, pour protéger cet élixir, Chang’e prend cet elixir. Et puis elle s'exile sur la lune. On croit qu’elle habite désormais dans la lune, et donc on célébre une fête le 15 août du calendrier lunaire, car cette jour, la pleine lune est la plus ronde et la plus lumineuse de l’année, &lt;/p&gt;
&lt;h3&gt;Les festivité&lt;/h3&gt;
&lt;p&gt;Aujourd’hui, la fête de la lune est une de ces fêtes traditionnel les plus important en Chine et dans les des pays de l’est de l’Asie. La lune très ronde représente la reunion de la famille. Pendant  la fête de la lune, on se rassemble à la maison pour célèbrer la fête avec les familles. En Chine, on a des vacances pour cette fête. 
La fête de la lune est une fête de réunion , donc il y a beaucoup de poèmes sur ce thème. Quelques poèmes sont eextrêmement connus par les Chinois.
Quand la famille se réunit , on regarde la lune ronde et on prépare des gâteaux de lune. &amp;lt;&lt;Le gateau de lune&gt;&amp;gt;. C’est un gâteau spécial pour la fête de la lune, il est aussi rond que la lune, et symbolise le rassemblement de la famille. Et parce que le 15 août du calendrier lunaire est usuellement très près de la fête  nationale, il y a des vacances de 7 jours. Il y a un pic du tourisme et dans les transports public à chaque année à cette période. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./Les-fetes-chinoises-en-automne/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./Les-fetes-chinoises-en-automne/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;h2&gt;La fête du Chongyang&lt;/h2&gt;
&lt;p&gt;La fête du Chongyang a lieu le neuvième jour du neuvième mois dans le calendrier lunaire(le 23 octobre 2012 dans le calendrier grégorien). Il y a deux 9 et le 9 est un chiffre ‘yang’(solaire et positif) donc particulièrement vénéré dans la tradition chinoise. C’est pourquoi on l’appelle ‘Chongyang’(Double-Yang) ou ‘Chongjiu’(Double-Neuf).&lt;/p&gt;
&lt;h3&gt;L’ origine&lt;/h3&gt;
&lt;p&gt;La fête du Chongyang est une fête très importante pour les chinois, mais l’origine de la fête est obscure. Il y a une légende qui raconte que les habitants d’un village attrapaient une maladie et que beaucoup de personnes mouraient. Un jour, un jeune est parti consulter les sages pour trouver le remède contre la maladie. Après son retour au village, il a demandé aux villageois de monter au sommet d'une montagne, afin de collecter des plantes médicinales et boire du vin de chrysanthème. Les gens se sont rétablis peu après les soins. Donc le jeune a été considéré comme un héros.&lt;/p&gt;
&lt;h3&gt;Les festivités&lt;/h3&gt;
&lt;p&gt;Pendant la fête du Chongyang, il y a des activités diverses, comme l’ alpinisme, la dégustation du vin de chrysanthème et l’admiration des fleurs. Ces activités célèbrent la légende. D'ailleurs, on mange le gâteau de Chongyang, un dessert très sucré et délicieux.
Le respect des vieillards a été attribué aujourd’hui à la fête de Chongyang, parce que le chiffre neuf, homonyme du mot ‘longtemps’ en chinois, est un symbole de longévité. Les jeunes profitent de l’occasion pour faire une excursion avec des vieillards ou leur préparer des plats savoureux.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./Les-fetes-chinoises-en-automne/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./Les-fetes-chinoises-en-automne/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Recette de Gâteau de Lune&lt;/h2&gt;
&lt;p&gt;(&lt;a href="http://www.marmiton.org"&gt;http://www.marmiton.org&lt;/a&gt;)
Temps de préparation : 240 minutes  Temps de cuisson : 70 minutes&lt;/p&gt;
&lt;h3&gt;Ingrédients (10 Portions) :&lt;/h3&gt;
&lt;p&gt;Pour la pâte :
- 300 g de farine
- 750 g de pâte de graine de lotus
- 10 jaunes d'oeuf salés
- 7 petite cuillère d'huile d'arachide
- 1 petite cuillère de thé
- 1/2 petite cuillère de levure de boulanger
- 100 g de sucre
Pour la décoration :
- 2 jaunes d'oeuf
- 1 petite cuillère de sucre 
- 2 petites cuillères d’eau&lt;/p&gt;
&lt;h3&gt;Préparation :&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mélangez le thé avec la levure. &lt;/li&gt;
&lt;li&gt;Enveloppez les jaunes d’oeuf salé dans un papier d’aluminium huilé.&lt;/li&gt;
&lt;li&gt;Faites les cuire au four pendant 20 minutes (90°) &lt;/li&gt;
&lt;li&gt;Coupez le pain de farine de graine de lotus en 10, faites un creux au centre de chaque bloc et, placez-y un jaune d’oeuf salé. &lt;/li&gt;
&lt;li&gt;Roulez-les pour en faire une boule. &lt;/li&gt;
&lt;li&gt;Tamisez la farine et mélangez avec le thé et l’huile. &lt;/li&gt;
&lt;li&gt;Laissez reposer la pâte sous une serviette mouillée pendant 4 heures. Coupez en 10. &lt;/li&gt;
&lt;li&gt;Enveloppez chaque boule avec la pâte et mettez-la dans un moule à gâteau de lune. &lt;/li&gt;
&lt;li&gt;Aplatissez bien, puis retirez du moule et, placez les gâteaux sur un plateau huilé. &lt;/li&gt;
&lt;li&gt;Faites cuire au four à 200ºC pendant 15 minutes. &lt;/li&gt;
&lt;li&gt;Puis enlevez les gâteaux et arrosez-les d’eau. &lt;/li&gt;
&lt;li&gt;Faites cuire encore à 180ºC pendant 5 minutes. &lt;/li&gt;
&lt;li&gt;Sortez et brossez les gâteaux avec l’oeuf battu, le sucre et l’eau. &lt;/li&gt;
&lt;li&gt;Faites cuire encore 10 minutes jusqu’à ce que les gâteaux prennent une belle couleur dorée.&lt;/li&gt;
&lt;/ul&gt;</summary><category term="french"></category></entry><entry><title>2011巴黎高科(ParisTech)申请总结</title><link href="http://x-wei.github.io/PT-summery.html" rel="alternate"></link><updated>2012-10-07T17:06:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/PT-summery.html</id><summary type="html">&lt;p&gt;这个总结早就应该写了, 拖延到今天实在惭愧...... 赶在今年申请的同学还没笔试之前把它写出来吧...&lt;/p&gt;
&lt;h1&gt;一. 法国大学校&amp;amp;巴黎高科集团介绍&lt;/h1&gt;
&lt;p&gt;交大的法国项目很多, 最主要的有巴黎高科(9+9), 中央理工(4+4), 法国高旷联盟(GEM), 以及N+I项目. 但是感觉交大的同学们对于法国项目知道的很少, 我是大三考完托福后才知道有巴黎高科这个项目(感谢HY跑步时告诉我T_T......) &lt;/p&gt;
&lt;p&gt;当然也不能全怪同学们, 教务处不知为啥, 总把法国的项目放到很不显眼的位置. 今年交大刚刚和巴黎高科成立了&lt;a href="http://www.polytechnique.edu/accueil/actualites/l-ecole-paristech-shanghai-jiaotong-accueille-sa-1ere-promotion-271762.kjsp?RH=ACCUEIL-FR"&gt;联合学院&lt;/a&gt;, 按说交大应该会大力宣传下吧, 可是今年的报名通知竟然放在了一堆游学项目里!!...... OK, 吐槽完毕, 开始正题...&lt;/p&gt;
&lt;h2&gt;法国教育制度&lt;/h2&gt;
&lt;p&gt;法国的教育体系非常奇葩... 它有着世界上独一无二的教育体系(and我记得那次中央理工的校长说他们很为此骄傲==...). 法国的高等教育体系分为大学教育(普通教育)和大学校教育(精英教育), 两套体系完全并行. 见下图(盗图自QYQY): 
&lt;img alt="" src="./PT-summery/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;简单讲, 就是法国的学生高中毕业后拿到BAC文凭, 之后可以选择进入大学学习或进入预科学校学习. 进入大学的条件很宽松, 法国的大学教育强调平等接受教育的权利, 宽进严出. 而如果选择进入预科学校, 则要经历两年的密集的数学物理课程培训(难度比国内的大一大二只高不低). 预科学校学习两年后, 学生经过激烈的竞考(难度很大, 淘汰率很高), 通过的学生才可以进入法国的大学校(Grandes Écoles)学习. &lt;/p&gt;
&lt;p&gt;我记得只有不道10%(大约2%??)的法国高中毕业生有机会进入法国大学校学习. 法国的大学校主要分为工程师学校和高等商学院. 工程师学校注重于培养工业界人才, 很重视实践和与企业的合作, 在法国享有很高声望. 工程师学院毕业生拿到的是工程师文凭(Diplôme d’Ingénieur, BAC+5). 听学长说虽然法国的硕士也是BAC+5, 但是工程师学位含金量更大... 关于工程师学位可以参考&lt;a href="http://new.ingenieur.org.cn/2010/01/%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%BD%8D-diplome-dingenieur-francais%E2%80%9D%EF%BC%9F/"&gt;这里&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;巴黎高科集团及中法9+9项目简介&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="./PT-summery/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;巴黎高科集团由法国最有声望的12所大学校组成, 这些学校可以说是法国精英教育最出色的学校. 学校的规模很小, 如巴黎高等矿业学校(Mines)每年全球大概只招收120人, 规模最大的巴黎综合理工学校(École Polytechnique)每届也不过招收500人. &lt;/p&gt;
&lt;p&gt;中法9+9(50名工程师)项目是中法两国为了培养一批熟悉中法文化的工程师而建立的合作项目. 首先"9+9"不是指9年加9年(囧...)...... 之所以叫"9+9"是因为一开始巴黎高科集团是9个成员, 中国方面是9所高校(), 每年大概有50人赴巴黎高科学习. &lt;strong&gt;但是... &lt;/strong&gt;现在高科集团现在扩充为12所高校, 而在中国, 2011年浙大加入该项目, 貌似2012年武大和华科也要加入, 而且每年高科集团一共录取的人数大约为80人, 所以这项目名字该改成"12+12"或者"80名工程师"才比较靠谱...&lt;/p&gt;
&lt;p&gt;关于这个项目, 罗列一些优点和缺点:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要求GRE或toefl成绩; &lt;/li&gt;
&lt;li&gt;申请时没有法语要求, 申请流程较简单, 周期较短; &lt;/li&gt;
&lt;li&gt;掌握法语的优势; &lt;/li&gt;
&lt;li&gt;学费全免(据说学费每年2万欧??), 奖学金机会多且基本都足够生活费(他们认为"money should not be a discrimination");&lt;/li&gt;
&lt;li&gt;强调通识教育, 很容易转专业;&lt;/li&gt;
&lt;li&gt;重视实习, 上学期间会有两到三次的企业实习(对找工作很有帮助), 没有奖学金的话实习基本上也能赚回来了;&lt;/li&gt;
&lt;li&gt;工程师学位在法国认可度很高, 比较容易找工作(法国或国内法企);&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工程师学校重实践不重科研(可能EP是个例外吧...), 想搞科研的同学不要来;&lt;/li&gt;
&lt;li&gt;学校太小, 国际知名度不高(不过在欧洲还是很知名的, 高科属欧洲&lt;a href="http://zh.wikipedia.org/wiki/IDEA%E8%81%94%E7%9B%9F"&gt;IDEA联盟&lt;/a&gt;之一);&lt;/li&gt;
&lt;li&gt;通识教育, 没有很深入学习某一方面, 他们认为只要你数学物理足够好干啥都没问题...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下, 就是去高科和去北美读硕读博是两条很不一样的路. 选择高科的话未来大多成为工程师, 进入企业, 基本不会进入实验室从事科研. 所以建议大家想好以后要干什么再做出选择. 而且高科的结果出来的很早, 拿高科保底不太合适(而且很伤RP 有木有...).&lt;/p&gt;
&lt;h2&gt;巴黎综合理工学校简介&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="./PT-summery/300px-LogoX.gif" /&gt;&lt;/p&gt;
&lt;p&gt;Écoles Polytechnique (昵称X) 是法国最有名的大学校, 也是一所世界知名的学校. 
这是一所具有悠久军事传统的法国名校, 和ENS(巴黎高师)同为法国最出色的Écoles之一. 关于它的具体介绍可以见文后的附件"交大法国留学手册". &lt;/p&gt;
&lt;p&gt;我只在此列举它&lt;a href="http://zh.wikipedia.org/wiki/%E5%B7%B4%E9%BB%8E%E7%BB%BC%E5%90%88%E7%90%86%E5%B7%A5%E5%AD%A6%E9%99%A2"&gt;wiki页面&lt;/a&gt;提供的一些校友, 这些名字时常出现在物理和数学书中...&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;雪铁龙, 庞加莱, 柯西, 毕奥(毕奥-萨伐尔定律), 马吕斯, 盖-吕萨克, 泊松, 安培, 菲涅耳, 科里奥利, 卡诺, 克拉伯龙, 刘维尔,  约当, 勒沙特列, 亨利·贝克勒......
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我大概就是看了这个名单才决定把EP作为申请的第一选择的...&lt;/p&gt;
&lt;h1&gt;二. 网申&amp;amp;材料准备&lt;/h1&gt;
&lt;h2&gt;学校报名&lt;/h2&gt;
&lt;p&gt;九月份教务处会贴出来高科的报名通知, 可能放在很隐蔽的地方... 所以大家要多关注下教务处或者游学网的通知...
高科基本上不会在合作学校之外招人, 所以学校这关一定要过...... 大概每年学校会推荐50人大名单参加笔试, 学校推荐的名额基本上是看成绩排名吧. 排在TOP15%的同学基本上都可以进入学校的推荐名单. 我们那年申请的竞争有点激烈, 电院有四五个排在TOP5%的同学申请了, 可能高科项目的知名度在提高吧...&lt;/p&gt;
&lt;h2&gt;网申&lt;/h2&gt;
&lt;p&gt;学校推荐的同时, 自己还要填写高科的网申页面. 注意如果要申请巴黎综合理工(École Polytechnique, 简写EP或X)的话, 还要专门填写EP的网申页面. 这里再说一句, 不通过高科项目(比如学校不在高科的合作学校之列)也是可以申请EP的, 不过那就需要足够好的硬件才能进入EP的面试.&lt;/p&gt;
&lt;p&gt;网申可以选择多个学校, 我选择了四所学校: EP, Mines, Telecom, ENSTA. Mines差不多排名仅次于EP, 而规模超小(120人), 每年在中国招生只有3-5人; Telecom电信方面法国最强, 毕业生很好找工作, Telecom在法国大致相当于交大在中国的地位, 而且和交大关系很好; ENSTA是除了EP之外的另一所国防部直属学校, 机械电子能源啥的都很强... 巧合的是, 这四所学校恰好是2012年交大-高科联合学院的四所法国学校......&lt;/p&gt;
&lt;p&gt;网申页面需要上传一些文件和图片. 身份证复印件, 护照复印件, 照片什么的就不说了, 按照要求准备就可以. 下面说一下比较重要的SOP, CV, RL.&lt;/p&gt;
&lt;h2&gt;SOP&lt;/h2&gt;
&lt;p&gt;动机信在网申和面试中非常重要, 需要好好对待. 在动机信里, 一是要表现出你对未来的规划, 显示你是经过了深思熟虑后才选择的高科; 二是列出你选择高科的理由, 注意最好不要写自己想从事科研(而且如果你想从事科研的话高科真的不太适合你); 三是表明你对法国教育制度的了解以及对高科的向往, 让他们相信你是真的想去而不是仅仅拿高科垫底......&lt;/p&gt;
&lt;p&gt;动机信用英文写就可以(当然如果会法语的话可以严重加分...), 动机信要早写, 早早写出初稿后让多个人看, 参考他们的意见进行改写. 当时我参加了GAUnion小组, 小组同学的意见让我受益匪浅... 高科的网申页面可以重复提交的, 你可以先上传一个版本, 修改后再覆盖上传. 我最后定稿的动机信是在9月30号, 也就是高科网申结束的前一天, 这之前修改了N(N&amp;gt;10)次...... &lt;/p&gt;
&lt;h2&gt;CV&lt;/h2&gt;
&lt;p&gt;简历也是很重要的文件, 关于简历的模板我用的是一个latex模板, &lt;strong&gt;不要太花哨&lt;/strong&gt;, 把最重要的信息写出来, &lt;strong&gt;一页即可&lt;/strong&gt;, 决不可超过两页. 简历最好加上一项Objective, 写上你想申请高科的工程师, 表明这份简历是专门为高科写的. 申其他学校也是这样, 写上Objective("我想申请你们学校")比较好......&lt;/p&gt;
&lt;p&gt;在CV里罗列的内容大概有: 姓名, 专业, 联系方式; GPA和排名; 获奖情况; 所学课程; GT成绩(如果有); 科研经历; 实践经历. 科研和实践经历大家可以把那些看起来比较NB的大作业或者科创课程拿出来, 每项实践经历用两三句话进行介绍...&lt;/p&gt;
&lt;p&gt;CV也是他们参考的重要因素, 在高科的面试时他们就一直在拿着我的CV在问问题... 我的硬件条件较为突出(GPA90+, rank top 3%... 但是硬伤是基本没有科研经历), 所以后来都比较顺利的进入了笔试和面试. 如果硬件不是很突出(比如TOP10%-TOP20%之间的同学), 则需要在笔试中有较为出色的发挥才能进入面试...&lt;/p&gt;
&lt;h2&gt;RL&lt;/h2&gt;
&lt;p&gt;高科和EP的网申都要求两位老师的推荐信, 我也不知道推荐信可以起多大作用, 但是最好还是认真对待吧... 我找了自动化系两位有德国留学背景的老师(席裕庚老师和袁景淇老师, 两位大牛啊...)写推荐信. 这里赞一下自动化系的老师们, 对学生超级好的!!~ 席老师人超级和蔼, 有求必应; 袁老师是只要大三下他那门过控考得好, 就会给你推荐~&lt;/p&gt;
&lt;p&gt;推荐信一般是自己写好了一个初稿然后交给老师, 老师再进行修改后提交给高科. 一般字数二三百就可以了吧, 尤其是我这种没有跟老师做过项目的人, 更没什么可以写的. 在RL的写作中GAUnion小组也提供了很大的帮助...&lt;/p&gt;
&lt;p&gt;还要注意的一点是, 高科面试时&lt;strong&gt;需要提交纸质推荐信&lt;/strong&gt;. 你需要把推荐信打印后放在信封里, 然后封口, 让老师们在信封上签字. &lt;/p&gt;
&lt;h2&gt;其他东西&lt;/h2&gt;
&lt;p&gt;EP的申请除了网申还需要邮寄, 具体的材料清单可以看&lt;a href="http://www.admission.polytechnique.edu/home/ingenieur-polytechnicien-program/"&gt;EP的网站&lt;/a&gt;, 有个checklist. 我们那年还要出生证明, 今年好像不要求了. EP的网申填写很繁琐, 还要写每年的排名, 不过这些东西自己估着填一下就可以了. EP还要求动机信和简历, 可以从高科的PS/CV修改. 另外如果提供奖学金证明(奖学金复印件即可吧)可以免除申请费. &lt;/p&gt;
&lt;p&gt;托福成绩可以提供(作用不大), 不必让ETS送分, 把纸质的托福成绩单复印下即可. 不建议提供GRE成绩, 这会让他们怀疑你有心申请美国... 我的GRE算是白考了...&lt;/p&gt;
&lt;p&gt;有一样&lt;strong&gt;比较纠结的东西是排名证明&lt;/strong&gt;...... 我当时在学院和学校的教务处跑了N次后, 学院终于给开了一个证明. 不过后来教务处又给每人开了一份排名证明...... 总之这个事情虽然纠结但是一届届大家还都能够最后搞定......&lt;/p&gt;
&lt;h1&gt;三. 笔试&lt;/h1&gt;
&lt;p&gt;巴黎高科的笔试一般在十月中旬. 会收到邮件通知, 以及&lt;a href="http://www.paristech-china.com/writtentest/instructions.html"&gt;网上通知&lt;/a&gt;. 我是10月10号收到通知, 10月15号考试...... 所以需要提前复习一下啊否则来不及复习都不会就囧了...&lt;/p&gt;
&lt;p&gt;关于高科的笔试, 我觉得他们还是比较看重CV和SOP, 如果排名较高的话, 只要笔试成绩中等水平就应该可以进入高科的面试. 如果GPA不高, 则需要在笔试中表现得出色一点, 以进入面试. &lt;/p&gt;
&lt;p&gt;高科的笔试安排在同济的瑞安楼, 交大同学过去要俩小时...... 所以打好提前量...... 笔试的内容是数学物理以及专业课, 全部是选择题, 对一道得3分, 错一道扣1分...... &lt;/p&gt;
&lt;p&gt;这里是高科的笔试考试范围: &lt;a href="./PT-summery/%E5%B7%B4%E9%BB%8E%E9%AB%98%E7%A7%91%E7%AC%94%E8%AF%95%E8%8C%83%E5%9B%B4%E5%8F%82%E8%80%83.pdf"&gt;巴黎高科笔试范围参考.pdf&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;第一场是数学, 分数学1和数学2, 要申EP的同学需要做数学2. 难度大概比GRE sub稍难一些吧, 但应该超不过交大高数考试的难度...... 高数内容比较简单, 线代当时我是下了比较大功夫复习的(因为忘的比较干净...), 记得考试时有好几道关于特征值特征向量和矩阵对角化的题目... 数学2比较难, 有好多没学过的内容就直接没做......&lt;/p&gt;
&lt;p&gt;第二场是物理和专业课, 物理我感觉蛮难的, 一共十几道题, 每一题的题干都很长...... 而且算出来结果没有出现在选项里的话就很崩溃...... 物理做完后选择自己的专业课, EE的题目比较简单, 有一些信号的内容, 还有些编程以及数电模电的东西, 但都是很简单的, 这些课程不必费太大力气复习.&lt;/p&gt;
&lt;p&gt;准备笔试时拿了点GRE sub做了两套: &lt;a href="./PT-summery/sub.zip"&gt;sub.zip&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;我觉得词汇才是重点, 英语的题干要是看不懂就囧了, 可以带词典, 我嫌词典太重, 就自己打印了份sub词汇表, 用那种一页两面的打印, 刚刚好... &lt;a href="./PT-summery/sub%E8%AF%8D%E6%B1%87.zip"&gt;sub词汇.zip&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;btw, 在同济监场的是俩帅哥, 后来才知道他们是Telecom来交大交流的学生...&lt;/p&gt;
&lt;h1&gt;四. 高科的面试&lt;/h1&gt;
&lt;p&gt;笔试完了之后面试大约在10月底, 在&lt;a href="http://www.paristech-china.com/interviews/"&gt;这里&lt;/a&gt;会有面试通知, 2011年我们是30号面试的. 还是在同济, 不过还算比较人性化, 把交大的面试安排在了下午, 否则还得提前一天晚上过去(闵大荒村民伤不起!!).&lt;/p&gt;
&lt;p&gt;交大那年有三十来人进了面试, 笔试淘汰率不太高的. 这次高科的面试不是技术面, 主要还是询问动机. 着装的话有正装可以穿去, 不过其实也无所谓的, 别太邋遢即可. 我就牛仔裤衬衫去了(因为没租到正装)...... &lt;/p&gt;
&lt;p&gt;面试在同济的中法中心进行, 一共有三四个房间, 基本上是你报了哪几所学校, 这几所学校的老师就回来面试你. 不过EP的人一个也没来, 因为他们有专门的面试... 面试时拿着纸质版简历和推荐信以及护照什么的. &lt;/p&gt;
&lt;p&gt;建议面试前把动机信再好好看看, 另外再了解下各个学校的特点, 那些方面比较强, 这样面试的时候显得你已经对他们研究很久了... 这里有个简单的介绍: &lt;a href="./PT-summery/Relations_domains_schools_ParisTech.pdf"&gt;Relations_domains_schools_ParisTech.pdf&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;另外我把BBS上学长学姐们的面试回忆放在了一起打印了出来: &lt;a href="./PT-summery/%E9%9D%A2%E7%BB%8F.pdf"&gt; 面经.pdf&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;面我的是一个ENSTA的老师(帅哥), 一个Mines的老师(大胡子, Julien), 还有一个Telecom的老师(大鼻子...). 主要是ENSTA的老师在问问题(难道是看到我是自动化系的所以比较亲切??...). Juien询问了我选择高科的原因, 这是面试时都会问的一个问题, 最好能够有条理地说出来, 我说我进行了一个简单的SWAT分析啊, 觉得高科最适合我啊, blablabla...... 他们听了笑而不语...... &lt;/p&gt;
&lt;p&gt;然后ENSTA的老师又拿着我的简历问我为啥选择电院的自动化专业啊, 做的科创以及电设都是干了点什么东西啊之类的... 我给他说了说, 然后又强调了我没有做过研究, 对实际应用比较感兴趣......&lt;/p&gt;
&lt;p&gt;然后ENSTA的老师让我把我申请的这四所学校按照优先级排序...... 没办法, 我只好实话实说了, 我说第一选择是EP, 因为知名度最高; 第二选择是Mines, 因为Mines的毕业生很多进入了法国企业的高管, 然后我又补充说EP和Mines都是很想去的学校, 要是都录取了的话我得好好考虑才知道到底去哪里; 第三选择是ENSTA, 因为他们的机电还有机器人什么的很棒(ENSTA的老师很得意); 第四选择是Telecom, 他们的电子信息方面是法国最好的(Telecom的老师对我把他们排在第四位很不满, 表情严肃...... 最后Telecom果然没录我...). 最后, 他们问我是否有问题问他们(这也是个保留项目), 我问他们觉得中国学生和法国学生有啥区别, 他们说没有, 他们一视同仁...... 然后我就撤了...&lt;/p&gt;
&lt;p&gt;面试大概持续了二三十分钟吧, 建议提前准备下如何回答他们的问题以及如何表达自己想去高科的愿望, 让他们相信你是真想去而不是拿来保底.......&lt;/p&gt;
&lt;p&gt;高科面试之后, 如果没有申请EP或Mines的话, 高科的申请就结束了, 接下来就是耐心的等待, 录取结果大约在十二月中旬出来...&lt;/p&gt;
&lt;h1&gt;五. Mines的面试&lt;/h1&gt;
&lt;p&gt;高科面试结束后, Mines和EP会进行单独的面试, &lt;strong&gt;单独面试的表现才会决定最终的录取&lt;/strong&gt;. 所以如果想进入Mines或者EP的话, 面试完了还要继续苦逼的看高数和大物...&lt;/p&gt;
&lt;p&gt;2011年11月17日收到Mines的面试, 面试在11月21日. Mines的面试是视频面, 在图书信息楼的7楼进行, 不用跑同济了... 交大一共有三个同学进入了面试, 每人面大约半小时. &lt;/p&gt;
&lt;p&gt;额, Mines的面试啊, 这事不能说得太细......&lt;/p&gt;
&lt;p&gt;之前李哲学长(X2010)在BBS上写了他当时&lt;a href="https://bbs.sjtu.edu.cn/bbsanc,path,%2Fgroups%2FGROUP_5%2FFrench%2FD515BBF70%2FDC4C032D6%2FDBBB9C57C%2FM.1321227794.A.html"&gt;面试回忆&lt;/a&gt;, 学长把面试时做的题目是啥都写了, 于是我复习时就打印出来做了做... 结果面试时遇到的题目和李哲学长那年的一样!!...... 有点太幸运了...&lt;/p&gt;
&lt;p&gt;Mines的面试题目可以参见学长的文章. 面试持续半小时, 感觉Mines的面试注重的是应用, 比如求二阶偏导, 比如解微分方程...... 而EP的面试则注重分析推导. 面试时拿到题目不会做没有关系, 老师会给你提示, 如果能够快速反应过来按他们的提示做出来题目, 他们会很高兴...&lt;/p&gt;
&lt;p&gt;面试是面对一个摄像头和一个显示屏, 那边的老师给你念出题目你在黑板上做. 网络条件很不好啊, 时不时的就"sorry, the image is frozen AGAIN"... &lt;/p&gt;
&lt;p&gt;另外强烈建议&lt;strong&gt;看一些国外数学公开课&lt;/strong&gt;, 我看的是MIT的一个老师讲的微积分重点(Course Highlights of Calculus), 葡萄上有下载. 这个课程内容很简单(介绍微积分的最基本内容), 我只看了七八集. 倒不是为了复习高数, 而是学会那些数学用语用英语怎么说... 比如次方, 求导, 积分, 对数之类的术语... 因为面试是向他们用英语讲题嘛...&lt;/p&gt;
&lt;h1&gt;六. EP的面试&lt;/h1&gt;
&lt;p&gt;11月17日收到邮件, 通知我12月2日去同济进行EP的面试. 进入EP面试的人不多, 电院只有三个人... 关于谁进入EP的面试可能主要还是看GPA吧, 如果高科的笔试表现很出色的话也应该会进入EP面试. 据说一旦进入了EP的面试, 会不会录取就&lt;strong&gt;完全取决于面试时的表现&lt;/strong&gt;, 和GPA或排名无关了...&lt;/p&gt;
&lt;p&gt;EP的入学竞考是法国历史最久, 难度最大的竞考之一. EP的面试分三场, 一场数学一场物理一场综合知识(比重貌似是6:4:4?), 大概会持续四个半小时...... 会有三个教授对你进行面试, 他们期望在这四个半小时里全面地了解你, 不仅是考察数理基础, 还包括言谈举止(比如主动擦黑板...)各个方面.&lt;/p&gt;
&lt;p&gt;EP的考试范围: &lt;a href="./PT-summery/EP-%E8%80%83%E8%AF%95%E8%8C%83%E5%9B%B4.zip"&gt;EP-考试范围.zip&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;个人感觉EP的面试难度比Mines高很多!! 比如这是EP网上提供的面试题样题: &lt;a href="./PT-summery/examples-eng.pdf"&gt;examples-eng.pdf&lt;/a&gt;  这个题我和zbf同学在自习室捣鼓了很久才差不多搞出来......&lt;/p&gt;
&lt;p&gt;而且EP的老师会根据你动机信里的内容, 对每个人出不同的题目. 比如有学长写他的试验能力很强, 教授就给他出了一道基于实验的题目. zbf说他电子方面很感兴趣结果老师给出了道电子模型的题目, 瞎了...... 对于数学系物理系的同学, 他们的题目必然要难很多, 工科学生的话题目就简单一些... 幸亏我没在SOP里写我有什么特长, 他们给的题目还算中规中矩, 否则肯定跪了...... &lt;/p&gt;
&lt;p&gt;准备EP的面试的过程非常痛苦, 不知道他们会出什么难度的题目, 又把高数线代大物好好看了一遍. 并且我把BBS上学长们的考试题回忆全部打印下来做了做: &lt;a href="./PT-summery/EP%E9%9D%A2%E7%BB%8F.pdf"&gt;EP面经.pdf&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;EP的面试会持续一星期, 因为他们一上午只能面试四个人(两组老师). 我是12月2号下午面试, 先是数学, 老师给了两道题, 自己做30分钟. 一道是数列的极限以及收敛的速度, 前两问比较简单可以用数学归纳法做出来, 第三问收敛速度不知道咋做就跳过了. 第二道是线代的题目, 定义了两个矩阵的一种运算(非常SORRY没带日记本来, 所以题目的内容忘了!!...), 然后让你证明一些结论... 由于我理解有误所以也不大会做...&lt;/p&gt;
&lt;p&gt;然后去给老师讲, 第一道题前两问讲完后, 第三问在老师的提示下......还是没做出来(弱爆了)... 还有十分钟时老师让我讲下一题... 我对题目理解错了, 不过前两问比较简单, 一会就做出来了(其实前两问就是铺垫, 为了得出第三问的结论). 第三问不会做, 老师提示: 先假设矩阵是对角阵? 然后我捣鼓出来了时间也到了. 然后老师说你看, 对角阵有这个结论吧? 非对角阵只要对它进行对角化我们就能得到这个结论了blablabla...... 我其实也没听懂就出来了...... &lt;/p&gt;
&lt;p&gt;休息一会后, 第二场是物理. 还是两道题, 一道是卫星怪象(高中就学过的, 卫星受到阻力之后速度反而增加), 第二道是运放工作在饱和区...是的, 之前学长写过这道题, 我又踩狗屎了...&lt;/p&gt;
&lt;p&gt;然后给老师讲题, 第一题做完后老师又让我进一步思考: 假设卫星收到的阻力和速度成正比, 该是什么情况, 要是和速度的平方成正比又是什么情况...... 第二题我一开始做错了(亏我之前看过学长的面经==......), 不过还好在老师的帮助下总算做出来了, 解一个微分方程就可以...... &lt;/p&gt;
&lt;p&gt;物理面完再休息一会, 第三场就比较轻松了. 那个数学老师给我一篇文章, 是太阳能发电的维基百科页面, 让我看一下然后跟他们讲讲这篇文章的主要内容. 我讲完后他又问了问我关于这篇文章相关的一些东西, 比如说为啥太阳能板要设计成抛物面... 之后就开始问动机了, 这时就和高科的面试差不多. 他拿着我的动机信, 问我为啥选择申请EP,我就说了说那几条理由. 然后他补充说, "而且你在动机信里也写了, 我们学校可以提供多个学科的教育", 看来EP很以此为傲...... 我又再次向他们表忠心, 说目前我只申请了高科的项目, EP是我最想去的学校没有之一, 如果去不了的话我可能再申香港...... 最后教授问我有啥问题没, 我问了问奖学金的事又问了问EP毕业生的就业情况, 然后就结束了......&lt;/p&gt;
&lt;p&gt;感觉我的面试是很幸运的, 没有给我出太难的数学题, 数学题再稍难一点我就挂了...... 另外英语口语好一些的话也有比较大的帮助...&lt;/p&gt;
&lt;h1&gt;七. 录取通知&lt;/h1&gt;
&lt;p&gt;面试完之后这几天非常纠结, 很害怕没有被录取上, 所以我抽时间写了申请港中文的PS......&lt;/p&gt;
&lt;p&gt;在EP面试前, 高科的网上出现了"admissibility"这么一个东西, 意思是这些学校会考虑录取你, 然后要你按照心目中的优先级进行排序. 这么做估计是为了防止一个人被多个学校录取的情况发生. 我的页面里有admissibility的是EP, Mines以及ENSTA. 于是我很纠结如果把EP排在第一位而最后面试没过的话, 会不会排在二三位的Mines和ENSTA不要我... 不过还是下决心把EP排在了第一位...&lt;/p&gt;
&lt;p&gt;12月14日下午, 收到EP的邮件, 被录取了!! EP的网申页面终于走到了最后一步...... 好开心啊!!...&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./PT-summery/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;p&gt;不过我们这年的意外情况比较多... 2011年是交大的小年, 只录取了18人(往年都是20+的). 和交大(尤其是和电院)关系最好的Telecom只在电院录取了3个人, 电子系很强的zbf同学没有被录取(绝对是他们的损失啊!!). 我最后能够如愿进入EP实在是有很大的运气成分......&lt;/p&gt;
&lt;h1&gt;八. 录取之后&lt;/h1&gt;
&lt;p&gt;记得有学长说过, 一旦你被录取, "everything is orgnized"... 所以录取之后只要时常查一下邮件按照邮件要求的做就是了...&lt;/p&gt;
&lt;h2&gt;奖学金&lt;/h2&gt;
&lt;p&gt;EP给学生提供720欧/月的奖学金(由La Fondation提供), 足够生活的开支(每月总生活费开支大约600-700欧). 而EP也会帮学生申请著名的埃菲尔奖学金, 该奖学金的好处参考&lt;a href="https://bbs.sjtu.edu.cn/bbsanc,path,%2Fgroups%2FGROUP_5%2FFrench%2FD515BBF70%2FD5829ED0F%2FM.1257698441.A.html"&gt;这里&lt;/a&gt;... 总之是各种爽... 只需要填一个EP的表格(大概是把SOP的内容改改粘上去), 然后EP会帮你申请埃奖.&lt;/p&gt;
&lt;p&gt;之前有传闻埃奖是随机分配的, 或者是按照姓名首字母分配的(额...), 不过这次的结果似乎还是排名高一点的同学有较大机会拿到埃奖. 我们这年交大5个埃奖(2EP, 1Mines, 1 Telecom, 1ENSAE).&lt;/p&gt;
&lt;p&gt;除了埃奖, 还可以申请国奖, 数额和埃奖相当只是申请过程比较繁琐... EP的人因为有学校奖保底所以一般不会申请. 国奖的申请流程见附件"交大法国留学手册"... 除了埃奖国奖, 还有一些企业奖和地区奖, 今年campusfrance也增加了一个奖学金. 即使没有奖学金也问题不大, 因为实习时就会有工资拿了...&lt;/p&gt;
&lt;h2&gt;法语学习&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;同学们要好好学习法语啊!&lt;/strong&gt; T_T... &lt;/p&gt;
&lt;p&gt;虽然EP第一年会有半年的学法语时间, 我现在也后悔当初没有好好上法语课, 这边分班分到了水平底的班级......&lt;/p&gt;
&lt;p&gt;上海的法语培训机构主要是凯育和芳赛, 我们当时两边询问比价, 最后把价格减少了很多...... 一半人去凯育一半人去芳赛, 我在凯育上课, 凯育的何春燕老师上课很赞, 可惜我没好好学...... 高科要求的TCF/TEF成绩是B1, 最后还是很容易达到的, 其实即使考了A2也不会有任何问题. &lt;/p&gt;
&lt;h2&gt;其他&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;签证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GEM项目有时会有签证悲剧的情况, 但是高科项目的历史签证通过率是100%...... 按照campusfrance上的通知一步步走即可. 关于签证的材料见附件: &lt;a href="./PT-summery/%E7%AD%BE%E8%AF%81%E6%9D%90%E6%96%99.zip"&gt;签证材料.zip&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;疫苗&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;EP会发一封邮件通知你去接种疫苗以及体检, 在上海出入境检疫中心, 有的人可能会打两针(间隔一个月), 这样的话需要提前去打否则到了法国还要再打...&lt;/p&gt;
&lt;h1&gt;九. 法国留学参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="./PT-summery/%E4%BA%A4%E5%A4%A7%E6%B3%95%E5%9B%BD%E7%95%99%E5%AD%A6%E6%89%8B%E5%86%8C.pdf"&gt;交大法国留学手册.pdf&lt;/a&gt;&lt;br /&gt;
这个手册很给力, 介绍了交大所有法国项目的情况, 强烈推荐认真阅读...&lt;/li&gt;
&lt;li&gt;&lt;a href="./PT-summery/%E4%BA%A4%E5%A4%A7%E6%AC%A7%E6%B4%B2%E7%95%99%E5%AD%A6%E6%89%8B%E5%86%8C.pdf"&gt;交大欧洲留学手册.pdf&lt;/a&gt;&lt;br /&gt;
这个是比较早的一个手册了, 介绍了交大的欧洲项目&lt;/li&gt;
&lt;li&gt;&lt;a href="./PT-summery/%E4%B8%8A%E6%B5%B7%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6goabroad2012%E5%A4%A7%E5%9E%8B%E5%87%BA%E5%9B%BD%E7%95%99%E5%AD%A6%E8%AE%B2%E5%BA%A7PPT%E6%B1%87%E6%80%BB.pdf"&gt;上海交通大学goabroad2012大型出国留学讲座PPT汇总.pdf&lt;/a&gt;&lt;br /&gt;
GAUnion的PPT很给力, 让你发现美国之外的其他选择~ 另外强烈建议大家加入GAUnion, 氛围很好帮助很大!&lt;/li&gt;
&lt;li&gt;饮水思源BBS-french版精华区 
有很多学长的总结贴, 推荐认真看一看.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OKOKOK... 写这么多行了... 祝大家申请顺利!!&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./PT-summery/pasted_image003.png" /&gt;&lt;/p&gt;</summary><category term="出国"></category><category term="巴黎高科"></category></entry><entry><title>git push使用代理</title><link href="http://x-wei.github.io/git%20push%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86.html" rel="alternate"></link><updated>2012-09-21T11:22:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/git push使用代理.html</id><summary type="html">&lt;p&gt;来到X之后, 上外网全部要用代理的, 非常不爽... 而且ubuntu的所谓的全局代理设置(首选项--&amp;gt;网络代理)好像并不管用... 设置了之后apt-get命令可以用, 但是常用软件(最常用莫过于chrome了)都要单独设置才可以...&lt;/p&gt;
&lt;p&gt;然而极为不爽的是git, 这边可以clone, 但是一到push的时候就报错:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git push 
ssh: connect to host github.com port 22: Network is unreachable
fatal: The remote end hung up unexpectedly
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;前一篇帖子把"Toefl"写成了"Tofel"...... 囧大了, 然后想改过来发现没法push...&lt;/p&gt;
&lt;p&gt;不过今天终于弄好了, 虽然不太明白是怎么弄好了的... 这里记一下.&lt;/p&gt;
&lt;p&gt;参考了&lt;a href="http://blog.csdn.net/itstarting/article/details/7305384"&gt;这篇文章&lt;/a&gt;, 不过好像又不大一样(我实在是不懂这个东西是什么原理, 只要求能用就好...).&lt;/p&gt;
&lt;p&gt;首先, 设置代理地址和端口:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git config --global http.proxy&lt;span class="o"&gt;=&lt;/span&gt;yourproxyserver:theport
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后好象就好了...... 不过push的时候要指定用户名和https的地址, 根据提示输入github密码才能使用.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git push https://x-wei@github.com/X-Wei/x-wei.github.com/
Password: 
Counting objects: 234, &lt;span class="k"&gt;done&lt;/span&gt;.
Delta compression using up to &lt;span class="m"&gt;4&lt;/span&gt; threads.
Compressing objects: 100% &lt;span class="o"&gt;(&lt;/span&gt;153/153&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
Writing objects: 100% &lt;span class="o"&gt;(&lt;/span&gt;153/153&lt;span class="o"&gt;)&lt;/span&gt;, 28.73 KiB, &lt;span class="k"&gt;done&lt;/span&gt;.
Total &lt;span class="m"&gt;153&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;delta 141&lt;span class="o"&gt;)&lt;/span&gt;, reused &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;delta 0&lt;span class="o"&gt;)&lt;/span&gt;
To &amp;lt;https://x-wei@github.com/X-Wei/x-wei.github.com/&amp;gt;
   7ec6f3f..957ede7  master -&amp;gt; master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好吧暂时就这样用吧, 虽然原理是什么我完全不知道......&lt;/p&gt;</summary><category term="git"></category></entry><entry><title>用尽量少的时间考一个够用的分数--一点Toefl/GRE备考经验</title><link href="http://x-wei.github.io/GT-summery.html" rel="alternate"></link><updated>2012-09-09T11:21:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/GT-summery.html</id><summary type="html">&lt;p&gt;这个暑假马上结束, 再不写这篇文章就再也没心情写了...... &lt;/p&gt;
&lt;p&gt;2011年3月到6月, 三个多月的时间我完成了托福和GRE的考试, 并且取得了让我比较满意的分数(toefl 105+, AW 3.5, GRE 13500+). 在此分享一些经验, 希望能够帮助大家在尽量不影响GPA的前提下, 用尽量短的时间, 考到一个足够的GT分数...&lt;/p&gt;
&lt;h2&gt;一. 为什么要"用尽量少的时间考一个够用的分数"&lt;/h2&gt;
&lt;h3&gt;"尽少的时间"&lt;/h3&gt;
&lt;p&gt;GT这两样几乎是申请出国必须的敲门砖(请原谅我这么功利...). 但是这些考试难度较大, 即使英语基础比较好的也需要相当大的精力准备. 现在人们喜欢拖延, 所以经常又把GT的备考战线拉得很长, 为了考一个好成绩, 提前好几个月甚至半年开始准备, 耗费了很多时间和精力同时效果却不一定好.&lt;/p&gt;
&lt;h3&gt;"足够的分数"&lt;/h3&gt;
&lt;p&gt;申请下来我的感觉是, 对于申请的学校, GT的分数要求仅仅是一个&lt;strong&gt;门槛&lt;/strong&gt;. 虽然一个优异的GT分数会给你的申请加分, 但大多数学校只关心你是否qualify, &lt;strong&gt;你的GT成绩再好也不会比一个美国本土的本科生流利&lt;/strong&gt;, 所以GT的分数在考虑录取是不会是占有很高权重的一项. &lt;/p&gt;
&lt;p&gt;而学校更看重的是"干货": GPA和Research, 这两样才会在申请中起到决定作用. 如果在GT上耗费太多的时间和精力, 势必会对GPA和科研造成影响, 得不偿失. &lt;/p&gt;
&lt;h3&gt;It's possible!&lt;/h3&gt;
&lt;p&gt;GRE和托福虽然考试难度大, 但是它们的题型固定, 有很强的规律性, 一两个月就可以总结出考试的一些技巧. 再加上机经之类的"特殊手段", 做到"速战速决"是完全可能的. 我就做到了一个月考T, 一个月AW, 一个月考G, 也许有人还可以更快呢!! 但是要做好困难准备, 备考的这几个月确实非常艰苦... &lt;/p&gt;
&lt;h2&gt;二. 多少分是"够用的分数"&lt;/h2&gt;
&lt;p&gt;首先说一下, 最后申请中我其实没有用到GT的分数(提交了一个toefl分数, 但是学校根本不强制要求也不关心, GRE分数完全没有用到...), 可能下面说的和每个学校的具体情况不尽相同, 仅供参考吧... 不过我个人觉得这些分数应该是足够用来申请的...&lt;/p&gt;
&lt;h3&gt;toefl&lt;/h3&gt;
&lt;p&gt;我觉得托福考试的重要性要大于GRE, 大概是因为托福的适用面更广吧, 像澳洲, HK, 欧洲这些地方的学校似乎没有GRE也是可以申请的, 但是要求托福(或雅思)成绩.&lt;/p&gt;
&lt;p&gt;欧洲或香港的学校对托福的要求不高, 90以上就达到了不少学校的要求. 不过当然了, 分数多多益善~ 而申请美国的学校则一般要求在100分以上甚至更高, 如果要申请TA的话口语分数最好高于23分. &lt;/p&gt;
&lt;p&gt;综上, 一个"够用"的toefl分数大概是: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"基本配置": 总分95+, 口语20+; &lt;/li&gt;
&lt;li&gt;"推荐配置": 总分100+, 口语22+;&lt;/li&gt;
&lt;li&gt;"发烧级配置": 总分110+, 口语24+.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;GRE&lt;/h3&gt;
&lt;p&gt;两个月的艰辛的GRE备战过程让我得出了这样的结论: 尼玛GRE绝对是美帝耗费外国学生时间与精力的阴谋啊!!! 太坑爹了!!! 不论是作文还是阅读还是词汇都TMD好难好难啊!!! 吐槽不已...... 不过既然它是申请北美众多学校的必需的敲门砖, 还是要硬着头皮考下来...&lt;/p&gt;
&lt;p&gt;要求GRE分数的学校一般是北美, 由于我没有申请北美的学校, 所以这里给的参考数据可能不够准确...&lt;/p&gt;
&lt;p&gt;我的感觉是, 如果申请MS的话, GRE的要求可能会低一些, 总分1300+, 作文3.0大概是个基本够用的分数了; 如果要申请phd, 总分1350+, 作文3.5的要求基本可以满足大部分学校; 如果申请更好的学校(就是大家耳熟能详的那几个牛校), 必须要更高GRE分数......&lt;/p&gt;
&lt;p&gt;综上, 我给出的"够用"的GRE分数为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"基本配置": 总分1300+, AW3.0+; &lt;/li&gt;
&lt;li&gt;"推荐配置": 总分1350+, AW3.5+;&lt;/li&gt;
&lt;li&gt;"发烧级配置": 总分1400+, AW4.0+.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;三. 我的英语基础&amp;amp;备考经历&lt;/h2&gt;
&lt;p&gt;我的英语底子应该算不错, 但也不是超级好的水平. 考了两次六级, 一次599一次600. &lt;strong&gt;我觉得六级成绩在580以上的同学都有能力在一个月的时间内托福考到100+&lt;/strong&gt;. 另外, 我在备考GT前的一个学期比较系统地背了一遍六级单词(没有坚持到底, 大概背了70%吧), 并且把新概念英语第三册看了一遍(前20课背下, 后40课熟读).&lt;/p&gt;
&lt;p&gt;这大概就是我备考GT之前的英语基础吧. 我拖到大三的下学期才开始考GT, 大三下是非常疯狂的一个学期: 用三个月的时间把GT搞定, 然后最后半个月疯狂复习准备期末考试... 二月末开学来到学校, 准备了一个月, 3.20考了toefl. 考完歇了十天左右, 开始准备AW, 4.26去上财考了AW. 考完AW休息了一个星期, 开始了最暗无天日的GRE备考... 6.11考完了GRE, 然后马上开始了期末考试的复习. &lt;/p&gt;
&lt;p&gt;备考这三个月来我没有旷课, 上课也基本在听讲, 而不是完全不听课去背单词. 所以经过半个月的突击, 期末考试的成绩没有受到GT的影响... &lt;/p&gt;
&lt;p&gt;回想起来, 那三个月实在是目前我经历的最充实的一段时间, 是非常难忘的奋斗经历: 最后一个月(前半个月GRE+期末考试), 我每天在自习室待到12点才回到寝室, 匆匆洗漱后第二天早上七点半起床去图书馆, 天天如此...... 如果想做到用尽少的时间考个足够的分数, 一定要做好困难准备, 做好连续一个月起早贪黑的准备......&lt;/p&gt;
&lt;h2&gt;四. toefl备考经验&lt;/h2&gt;
&lt;p&gt;关于托福的入门介绍, 看饮水思源EnglishTest版的介绍, 看了这个可以不看那本厚厚的OG:
&lt;a href="https://bbs.sjtu.edu.cn/bbstopcon?board=EnglishTest&amp;amp;file=T.1177935865.A"&gt;https://bbs.sjtu.edu.cn/bbstopcon?board=EnglishTest&amp;amp;file=T.1177935865.A&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强烈建议提前把考试题型弄清楚&lt;/strong&gt;, 我前面说了, GT的题型很固定很呆版很有规律性, 掌握了每一类题的题型和每一类题的特点可以事半功倍. 考试题型可以看上面链接的介绍, 然后自己做几套题体会.&lt;/p&gt;
&lt;p&gt;我觉得托福的单词不是重点, 六级词汇全部掌握的话应付托福问题不大. 当然, 有时间看看分类的单词书还是有帮助, 可以重点看看地理学, 生物学等等的分类词汇. &lt;/p&gt;
&lt;p&gt;"&lt;strong&gt;得听力者得托福&lt;/strong&gt;", 这句话是很对的. 因为托福的听说读写四部分, 除了阅读没有听录音的环节, 其他三个环节都有听力参与进来! 所以听力的加强是最重要的! &lt;/p&gt;
&lt;p&gt;我的托福的备考技巧, 简单总结就是: &lt;strong&gt;听力阅读靠TPO, 口语听力靠机经&lt;/strong&gt;...... 下面分别说明: &lt;/p&gt;
&lt;h3&gt;关于听力阅读以及TPO&lt;/h3&gt;
&lt;p&gt;听力和阅读确实需要真功夫, 因为听力阅读的机经没法看...... 所以我的备考重点也一直是听力和阅读的锻炼.&lt;/p&gt;
&lt;p&gt;网上有很多托福的模考软件, 什么巴朗, Delta,Longman...... 我刚开始把这些全部下载下来, 不过幸好只做了两套的巴朗... 因为后来才发现这些模考软件除了界面和实际考试比较相似, 实际题目的难度和考试时相差较大, 使用这些模考来练习的话效果不好. &lt;/p&gt;
&lt;p&gt;所以我推荐TPO, TPO是什么? 就是"TOEFL® Practice Online", 托福在线模考. 为什么推荐TPO呢? 因为这些题都是以前托福考试的原题! 它们最能够反映托福考试的难度! 官方售价是一套TPO题目44.95美元, 好像新东方和网上也有买的, 会便宜很多. &lt;/p&gt;
&lt;p&gt;我使用的是网上下载的PPS格式的TPO, 用Powerpoint打开放映就可以使用, 115下载地址, 有19套题目: 
&lt;a href="http://115.com/file/aq24vbdz"&gt;http://115.com/file/aq24vbdz&lt;/a&gt;&lt;br /&gt;
大家也可以去下载最新的TPO, 貌似已经出了二十几套了...... &lt;/p&gt;
&lt;p&gt;这些PPS放映虽然界面不大好, 而且最后要自己对答案算分, 但是题目都是货真价实的, 非常珍贵. TPO做一套少一套, 我建议在做了二三套模考软件的题目, 熟悉了题型之后再开始做TPO. 精做, 一天就做一套, 做完了好好对答案, 把不明白的句子弄明白, 没听清的对话听清楚. 备考期间我也就做了10套左右的TPO, 感觉提高很快, 一开始算下来听力和阅读分别也就是二十一二分, 到后来基本上能保证28分以上(压缩包里有一个表格, 把你每一部分对了几道题错了几道题输进去就会出来得分). &lt;/p&gt;
&lt;p&gt;那些文件放映时有计时功能, 一开始做题老是超时, 后来渐渐提高了阅读的速度. 另外, 有人建议先看一遍题目再去读文章, 我的经验是&lt;strong&gt;最好先把文章读完再看题目&lt;/strong&gt;. 因为题目也比较长, 而且选对需要对文章意思的正确理解, 看看题目和选项直接能选出来基本不可能. 这样做需要快速读懂文章, 一开始确实比较痛苦, 练的多了掌握做题进度就比较有经验了. &lt;/p&gt;
&lt;p&gt;听力的重要性怎么言也不为过, 好好做TPO可以很快地提高听力水平...... 托福的听力每一题都是固定的题型, 在了解了每一题的题型和特点后, 要做好及时的记录, 同时别因为记录上一句而导致下一句没听进去... 关于英语的速记, 可以用一些小技巧, 比如:
有的单词可以忽略元音字母, 如"book"写成"bk"也认得出来; 
一些表示"提高", "上升"之类的单词可以使用箭头代替; 
用符号代替常用词尾: -ing词尾---&amp;gt;"~", -tion/-sion词尾---&amp;gt;"ʃ", th-开头---&amp;gt;"θ"(them---&amp;gt;θm)......&lt;/p&gt;
&lt;p&gt;这样的技巧可以提高一些记录的速度. 不过最主要的还是听力能力的锻炼, TPO做完后觉得哪些对话没有听懂要&lt;strong&gt;反复听&lt;/strong&gt;, 听懂每一句. 由于听力题型(甚至是话题)的固定性, 这样做进步会很快!~&lt;/p&gt;
&lt;p&gt;另外, 当时做TPO的听力和阅读时感觉就是很有趣(这和背GRE单词和做GRE阅读的心情形成鲜明对比...), 托福的阅读一般是一些科普文章(生物学, 地质学, 人类学啥的), 一些人做的研究, 得到的结论...... 读来很有意思, 比如有一片文章介绍鸡在面临危险或者面临选择时居然会突然睡觉, 这是XXX原因...... 总之让我很开眼界...... 托福的听力则有的是课堂上的对话, 老师和学生的交流什么的, 很有意思......&lt;/p&gt;
&lt;p&gt;TPO的口语和写作我不建议做了, 因为...... 因为机经有很大的机会命中, 而TPO的这些题肯定是不会考到的了......&lt;/p&gt;
&lt;h3&gt;关于口语写作以及机经&lt;/h3&gt;
&lt;p&gt;我得承认, 口语和写作这部分我偷懒了, 并没有下功夫训练... 如果要提高这两部分的能力, 恐怕要下比阅读和听力多得多的功夫. 所以我抱着侥幸的心态使用了机经, 并且幸运地中了...&lt;/p&gt;
&lt;p&gt;机经是什么? 机经就是以前考托福的人考完后对他那场考试内容的回忆. 托福每周都有考试, 而实际上ETS每年只会出十来套新题目, 所以很多的考试会有重复! 而且, "ETS出题太有规律了"(王京竹语), 基本上新东方的老师都可以预测准确! &lt;/p&gt;
&lt;p&gt;既然有机经, 为什么听力和阅读不能靠机经呢? 因为所谓的机经都是考完后的回忆, 就像交大的考经一样, 只言片语, 总不会把听力和阅读的全文回忆出来吧? 所以听力和阅读的机经非常鸡肋, 只能大概回忆出文章的主题以及单词那个题考的啥, 不会有太实质的帮助, 所以听力和阅读还是要好好用TPO练... 而口语和写作的机经由于只需要记住一个主题或者题目即可, 所以很有价值......&lt;/p&gt;
&lt;p&gt;我准备口语和作文的时间也就是10天左右, 因为我寄希望于机经命中, 而机经必须要等到考前一两周才回出来...... 实际上机经命中的概率蛮大的, 尤其是我在听了王京竹点题班的录音之后... 托福的机经可以在淘宝上买到, 也就几十块钱. 小马过河或者王京竹的鸡精网上也会有好心人共享机经出来. &lt;/p&gt;
&lt;p&gt;各个版本的机经相差不大, 基本上都是那十来套题目. 机经会给出可能考的十几套题目, 按照可能性大小分为三类, 每类大概有六七套题目. 我当时把机经的A类和B类题目好好看了一遍, 一共10套题目左右. 和TPO一样, 我准备得非常详细, 对口语的前两题都准备好了要说的话, 对作文的题目都准备好了三个论点, 因为我知道考试时很可能就会碰到原题!! &lt;/p&gt;
&lt;p&gt;关于口语, 我觉得最难的是前两题, 需要在45秒的时间内就一个主题说30秒钟的话. 强烈建议大家去听一听王京竹点题班的录音, 不一定是最近的机经, 他的随便一期点题班录音都可以. 他的方法我觉得短期应付考试很管用: 对于口语, &lt;strong&gt;每个题目说出三个论点&lt;/strong&gt;, 每个点一两句话, 再加上前面的引入和后面的总结, 差不多刚好把时间说完. 这是短期内提高口语分数的很好的方法. 准备机经时, 我就对每个题目列出三个论点(有时想出这三个论点需要很多时间的, 所以如果机经没有中的话我肯定会考得很差), 差不多是三句话, 写在纸上. 考试时, 先第一句话表明自己的观点, 然后firstly......secondly......finally......把三个论点讲出, 最后再来一句"That's why I think......", 时间就差不多到了~ 可以自己总结出适合自己的模板, 引入话题和最后总结时用固定的句式(i.e. "In my view, XXXX......., I have this point mainly because of 3 reasons: firstly......secondly......finally....... So that's why I think XXXX......"), 不要变来变去. &lt;/p&gt;
&lt;p&gt;我当时听的王京竹点题班录音: &lt;a href="http://115.com/file/dpghlbbk"&gt;http://115.com/file/dpghlbbk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外, 口语的前两题一定要大声说出来! 声音越大越好, 否则到后面更加说不出来...... 备考口语的时候, 我在寝室里对这电脑, 看着写好的论点大声说. 说完后听自己的录音, 感觉不好的地方就改正(一开始我说得特别快, 不道20秒已经把三个论点说完了...), 渐渐的就能够比较好的控制时间.&lt;/p&gt;
&lt;p&gt;至于口语的后面几题, 实际上是听力题, 只要能够把对话的内容听明白, 接下来表达出来不是问题了, 况且听力的题型和主题也是那么的固定......&lt;/p&gt;
&lt;p&gt;写作的第一题实际上是阅读+听力, 找出这两篇文章中三个不同的观点(一定会是三个点, 找仔细, ETS出题太有规律了...)即可, 然后可以自己总结出来个模板, 很快写完这篇.&lt;/p&gt;
&lt;p&gt;关于阅读的第二题, 我也推荐使用八股文式的"五段式": 引入-论点1-论点2-论点3-总结. 这个是看一篇&lt;a href="http://www.taisha.org/test/toefl/jyjq/xxjq/201102/20110217100408.html"&gt;太傻上的文章&lt;/a&gt;学到的, 不要担心因为结构的平庸影响分数, 考官最喜欢这种格式!! 所以对于每个作文题目, 只需想好3个论点(同样, 想出这三个论点需要一番功夫...), 并依次进行展开即可!!&lt;/p&gt;
&lt;h3&gt;关于考试&lt;/h3&gt;
&lt;p&gt;我在电信群楼考的, 主场作战就避免了路上的颠簸, 托福一考就是四个小时, 早晨要早起, 多吃点, 一定得带点巧克力啥的, 在考完听力后的十分钟里吃一些......&lt;/p&gt;
&lt;p&gt;考试时我倒数第三个进场, 抽到的是听力加试. 晚入场的好处是, 在我做着听力加试的时候已经听见了别人说口语--而那口语的题目正是我准备过的!! 心中窃喜, 考完听力有十分钟休息时间, 我就边吃点东西边把那一套机经的口语和写作好好看了一遍! 不过晚进场的缺点是, 当你说口语时, 别人几乎都说完了, 没有了大家乱哄哄说话的气氛, 只能听见自己的话在考场里回响...... 不过我脸皮厚, 比较大声地把口语考完了...... &lt;/p&gt;
&lt;p&gt;差不多这些就是我的托福备考经验, 另外大家可以关注太傻或小马过河的托福频道, 其中的一些文章介绍考试技巧什么的还是很给力的. &lt;/p&gt;
&lt;h2&gt;五. GRE备考经验&lt;/h2&gt;
&lt;p&gt;我考的是最后一次老G, 笔试, 现在GRE变成了网络考试, 可能情况有变, 以下的经验可能参考性不如托福的强, 我也少些一些...&lt;/p&gt;
&lt;p&gt;GRE真是要人命... 前面说六级580的水平准备toefl问题不大, 但是不论原来英语底子多么好, 备考GRE都要花很大一番功夫的. 我觉得我备考GRE比备考托福多花费了一倍的时间和投入... 做好困难准备, 天无绝人之路......&lt;/p&gt;
&lt;h3&gt;关于作文&lt;/h3&gt;
&lt;p&gt;说托福作文和六级难度比较相似应该基本准确, 然而GRE的作文就完全是高一个层次了... 不论是Argu还是Issue, 都对思维的逻辑性和表达的流畅性提出了非常高的要求... &lt;/p&gt;
&lt;p&gt;我的AW经验是: Argu看孙远, Issue看题库+RP......&lt;/p&gt;
&lt;h4&gt;Argu和孙远&lt;/h4&gt;
&lt;p&gt;强烈推荐新东方的孙远的AW教学视频, 一共有几十讲, 我只把Argu的部分好好看了. 边看视频边做笔记, 孙远讲得确实不错, 告诉我们如何找出文章立论的漏洞, 常见的漏洞有哪些, 如何进行反驳(Argu貌似都是要反驳的对吧......). 整个教程看完花了一个多星期的时间, 这段时间没怎么实际写文章练过, 但是收获颇多, 后面写Argu也比较顺利了...&lt;/p&gt;
&lt;p&gt;需要特别强调, Argu得到高分还是比较容易的. Issue写得差一点也基本能拿个3分, 拿4分的Issue比较困难, 而4分的Argu却完全有可能做到. 所以在Argu上一定要全力写好, 否则很难保证作文能拿到3.5+的分数!...&lt;/p&gt;
&lt;h4&gt;Issue和题库&lt;/h4&gt;
&lt;p&gt;Issue实在就得靠实力+运气了...... 我AW考了3.5, 运气成分很大...&lt;/p&gt;
&lt;p&gt;AW的题库是开放的, 考试时会从中抽出一道. 论坛上有人总结每次考试的题目, 然后按照频率来排序, 当时时间不够, 我只做了最高频的几个题目--然后考试时Argu是高频第一题, Issue也是昨晚简单准备过的!...... 耗费了比较多的RP, 考前实在也是没底......&lt;/p&gt;
&lt;p&gt;关于Issue的写作, 我觉得还是要像托福那样准备好三四个论点, 但是要挖掘的更深, 写得更长... 别的经验就谈不上了, 有空的话还是多做些题库的高频题目吧, 但是不要抱托福机经那样大的指望...&lt;/p&gt;
&lt;h3&gt;关于词汇&lt;/h3&gt;
&lt;p&gt;词汇是GRE最让人恶心的部分, 也是没法跳过的部分...... &lt;/p&gt;
&lt;p&gt;词汇的准备是最痛苦的, 一开始我想要把红宝书背下来, 一天一个list还需要四十多天那! 我坚持了一个星期就放弃了....... 词汇太多了!TT......&lt;/p&gt;
&lt;p&gt;然后果断转用要你命三千, 这本书三千个单词, 30个list, 但至少比红宝书要少, 而且每个list又分成10个小部分, 可以抽几分钟的零碎时间背10个单词...... 要你命3k绝对不是浪得虚名, 真的快要了我的名了... 开始背要你命3k时, 我算了算, 必须每天背两个list才能赶上进度, 来得及背第二遍. 那两个星期我决定不把要你命3k背完不刮胡子...... 当我终于把3k个单词背完一遍时, 胡子已经两三公分长了......&lt;/p&gt;
&lt;p&gt;要你命3k上的单词是从过去十几年的GRE考试中提取出来的常考词汇, 最终考试时我也非常幸运地碰到了好几个3k里的单词(还有要你命3k增补的几百个单词也要背, 这些是近几年考试中出现的词汇). 另外, 每一个list前面都有一个GRE牛人(其中有2011年北大著名的"横扫姐")的一些话, 很励志的. 让我最感到受益的是一句很简单的话: "&lt;strong&gt;背GRE单词的秘诀就是: 重复, 重复, 再重复&lt;/strong&gt;". 基于这样一句话, 我每天除了背新单词之外, 还会花半个小时的时间复习昨天和一周前背的单词, 不断的重复, 再重复...... 背完第一遍后, 3k里面的单词我差不多能够记得85%了, 然后迅速开始复习第二遍和第三遍. 由于第一遍背单词时就注意及时回顾, 所以二三遍的速度快了许多.&lt;/p&gt;
&lt;p&gt;另外, 在我回顾单词的时候, 发现很多单词是近义词/反义词/同一类别的词, 把这些词汇放在一起再看, 了解他们的区别与联系, 非常有好处. 所以我花了一天时间把3k里出现的这些有联系的单词写在了一起, 背完3k再来看看这些单词有助于强化记忆.  &lt;a href="./GT-summery/ynm3k.txt"&gt;我总结的同类词汇&lt;/a&gt; &lt;/p&gt;
&lt;h3&gt;关于阅读&lt;/h3&gt;
&lt;p&gt;如果说得听力者得托福的话, 我觉得可以说得阅读者得GRE... 因为在词汇部分, 大家都能够拿到差不多的分数, 拉分的项目就是阅读了.&lt;/p&gt;
&lt;p&gt;GRE的阅读, 长, 难, 偏!(尼玛GRE的项目就没有一个正常的...) 需要多多锻炼以提高阅读能力. 那么用什么练呢? 和托福一样, 用真题! 网上有卖所谓的"小白书"的, 是比较早的几十套GRE真题, 这些题目可以反映出GRE阅读的真实难度, 是非常好的训练材料!&lt;/p&gt;
&lt;p&gt;我在要你命3k背的差不多时开始做小白书的题, 一天一套或两套, 掐时间做, 精做. 开始做题就发现, 3k里的词汇果然出现在了题目里, 不再有一开始看到GRE词汇题那种一个也不会的感觉. 做题主要目的是练阅读的速度和准确度, 一开始也会遇到时间不够的情况(一定要掐时间做, 否则没有意义), 但是后来就会知道如何分配时间了. 我基本没有放弃阅读的任何一道题, 时间刚刚好. 做完后对照答案, 把不认识的单词和看不懂的句子弄懂. 极品的GRE, 有时把原文的简单结构的句子故意弄成长得吓人的长难句! 所以要在这方面下点功夫, 网上有GRE长难句解析, 写得不错, 可以看看. 我看了二三十句长难句后就开始做真题了. 这样做上十来套真题, 到后面我差不多可以做到阅读只错二三个的程度! 这样的水平让我在考前就比较放心了......&lt;/p&gt;
&lt;h3&gt;关于数学&lt;/h3&gt;
&lt;p&gt;GRE的数学其实是考的词汇... 那些幼稚的算数几乎不会犯错误的 累的时候可以做做小白书的数学题休息一下...... 网上有人整理的GRE数学词汇倒是值得看一看, 有些词汇不明白啥意思就傻眼了. 比如我考试时不明白一组数据的"range"是啥意思--原来是指一组数据的最大值减去最小值...... &lt;/p&gt;
&lt;p&gt;不过总的来说数学一般不会阴沟里翻船的......&lt;/p&gt;
&lt;h2&gt;六. 总结&lt;/h2&gt;
&lt;p&gt;我个人非常建议有出国意向的人考一下托福, 准备周期较短, 适用面比GRE广, 就算最后不出国, 准备托福的过程也会有很大收获. 当然如果目标是北美的话, GRE就是一道不得不越过的坎了... 如果GT都不想考的话, 其实也有别的出路, 比如德国和法国的项目...&lt;/p&gt;
&lt;p&gt;另外建议常到网上看看, 太傻, 寄托天下什么的, 上面有一些人的心得体会, 有时他们的一句话就能够点醒你. 还可以到bbs的EnglishTest板上逛逛, 交流心得, 看看精华区的文章...&lt;/p&gt;
&lt;p&gt;以上说了这么多的技巧和经验, 但实际上最重要的还是要坚持每天做下去, 就算方向再准确, 计算得再精确, 不迈出前进的脚步仍然没用. 还是那句话, 既然选择了这条路, 就要&lt;strong&gt;做好困难准备&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;最后, 送上我在准备GT时看到的几句话, 共勉:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;第一句: Unless a man undertakes more than he possibly can do, he will never do all that he can. 
第二句: Sloth, like rust, consumes faster than labor wears. 懒惰像生锈一样, 比操劳更能消耗身体. 
第三句: 每当我们对未来充满了各种美好的期望与幻想时, 就该反思一下自己现在的努力 是否配得上这幻境中的将来.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Bon courage!&lt;/strong&gt;&lt;/p&gt;</summary><category term="出国"></category><category term="Toefl"></category><category term="GRE"></category></entry><entry><title>[更新]访问google服务和优酷去广告功能的host列表</title><link href="http://x-wei.github.io/google_youku_host_20120706.html" rel="alternate"></link><updated>2012-07-06T00:36:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/google_youku_host_20120706.html</id><summary type="html">&lt;p&gt;之前两篇帖子介绍了如何通过修改host文件达到无鸭梨&lt;a href="http://x-wei.github.com/google_host.html"&gt;访问google服务&lt;/a&gt;以及&lt;a href="http://x-wei.github.com/host_youkuqiyi.html"&gt;屏蔽优酷土豆广告&lt;/a&gt;的目的, 虽然不明白这东西到底是啥原理, 但一直用得很爽......&lt;/p&gt;
&lt;p&gt;在学校里使用那一个hosts文件一直很顺利, 没啥毛病, 有人抱怨说那个方法不给力, 我也没管...&lt;/p&gt;
&lt;p&gt;后来回家发现原来的host确实不给力了, 优酷广告可以屏蔽, 但gmail的附件预览不能...... 今晚决定搞一搞这个问题... 原先的文件在学校管用的原因, 我猜测是google的host有不少是ipv6的, 回家后这些行都不行了...... 于是上网搜索, 想改改新的host.&lt;/p&gt;
&lt;p&gt;搜了一大堆都是2011年贴出来的, 不知能不能用... 边搜边想, 这样每隔一段时间去搜host的方法貌似有点笨......&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后我发现了两个比较给力的host项目......&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;smarthosts&lt;/h2&gt;
&lt;p&gt;一个是&lt;a href="http://code.google.com/p/smarthosts/"&gt;smarthosts&lt;/a&gt;项目, 在云端不断更新(最近一次是07.03, 两天前)host文件, 而且也提供了各种客户端~ for linux的其实就是&lt;a href="https://smarthosts.googlecode.com/svn/trunk/osx_linux.py"&gt;一个python文件&lt;/a&gt;, 功能就是把云端的文件(地址: &lt;a href="https://smarthosts.googlecode.com/svn/trunk/hosts"&gt;https://smarthosts.googlecode.com/svn/trunk/hosts&lt;/a&gt;)copy到本地覆盖原先的文件... 所以(对我来说)也用不着什么客户端, 需要时去copy那个云端文件来本地就是了.&lt;/p&gt;
&lt;p&gt;把那个文件中的host行copy到我本地的hosts文件里, 顺便把原先的那些行删了, 然后google就可以顺利访问了~ gmail附件预览木问题, googlesites啥的也能上了~&lt;/p&gt;
&lt;h2&gt;hostx&lt;/h2&gt;
&lt;p&gt;之前用的host加上那个修改host屏蔽视频网站的的方法, 只是对优酷有效, 对土豆/奇异貌似都无效, 我猜是因为host的原因. 所以继续搜屏蔽广告的host. 然后我就搜到了hostx这个项目(网址是: &lt;a href="http://orztech.com/softwares/hostsx"&gt;http://orztech.com/softwares/hostsx&lt;/a&gt; 这个值得吐槽的域名==), 和smarthosts项目类似... &lt;/p&gt;
&lt;p&gt;它提供给linux的是shell代码, 很短: &lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
sudo mv /etc/hosts /etc/hosts.bak
wget &amp;lt;http://hostsx.googlecode.com/svn/trunk/HostsX.orzhosts&amp;gt;
sudo mv hosts /etc/hosts
sudo gedit /etc/hosts
sudo /etc/init.d/networking restart
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;啊... 原来这个也是个googlecode上的项目, 和smarthosts很类似... (使用googlecode/github来共享文件确实是不错的办法唉) 不过它的特点是可以提供屏蔽视频网站广告的host, 我把这些host加入本地的hosts文件之后, 果然土豆/奇艺的广告也去除了(当然之前要按&lt;a href="http://x-wei.github.com/host_youkuqiyi.html"&gt;这个帖子&lt;/a&gt;设置一下), 给力啊!~ &lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本来使用hozstx也有关于google的行, 只是实测貌似不给力...... 于是我现在把这俩host内容都放在我本地的hosts文件里(看来host这东西还是多多益善...), 另外, 这两个都提供了youtube等网站的host, 但是实测都不给力...... 不过反正一般也不上什么youtube/twitter(想上的同学自己折腾下"goagent"......), 目前的效果(&lt;strong&gt;访问google所有服务, 上优酷/土豆/奇艺没广告&lt;/strong&gt;)已经很满意了~~&lt;/p&gt;
&lt;p&gt;最后贴上&lt;a href="./[更新]访问google和优酷去广告功能的host/hosts"&gt;我的host文件&lt;/a&gt;... &lt;/p&gt;
&lt;p&gt;我已经把最开头locoalhost那两行删了(否则可能有问题), 下载下来后把这些内容添加到本地的host文件中即可~ 本地的hosts文件位于:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;linux: /ect/hosts
windows: c:/windows/system32/drivers/etc/hosts
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果又不能用了, 可以自己去把 &lt;a href="https://smarthosts.googlecode.com/svn/trunk/hosts"&gt;https://smarthosts.googlecode.com/svn/trunk/hosts&lt;/a&gt; 和 &lt;a href="http://hostsx.googlecode.com/svn/trunk/HostsX.orzhosts"&gt;http://hostsx.googlecode.com/svn/trunk/HostsX.orzhosts&lt;/a&gt; 这俩文件的内容粘贴进本地的hosts文件里就可以了. 我估计换一次host能撑很长时间吧... 当然如果真的很懒的话也可以用他们提供的小软件来搞~&lt;/p&gt;
&lt;p&gt;P.S. 码字+修改花了好长的时间啊啊... 大概是因为昨天看了篇文章, &lt;a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/"&gt;"为什么你应该（从现在开始就）写博客"&lt;/a&gt;......&lt;/p&gt;</summary><category term="google"></category><category term="host"></category></entry><entry><title>步入七月</title><link href="http://x-wei.github.io/%E6%AD%A5%E5%85%A5%E4%B8%83%E6%9C%88.html" rel="alternate"></link><updated>2012-07-03T21:41:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/步入七月.html</id><summary type="html">&lt;p&gt;面临一个早就很渴望的暑假, 两个多月的自由时间, 可以做很多事情, 还有很多雄心勃勃的暑假计划希望在这个暑假充实自己. 可是回家来一周多基本上只在吃饭+睡觉+上网发呆╮(╯▽╰)╭......&lt;/p&gt;
&lt;p&gt;额, 所以得打起精神来做点事情, 像这样的暑假以后估计不多了. 其实&lt;code&gt;必须做的&lt;/code&gt;/&lt;code&gt;该做的&lt;/code&gt;/&lt;code&gt;想做的&lt;/code&gt;事情还是蛮多的, 比如一些以前想研究的小东西, 比如之前喊着要写的一些post...&lt;/p&gt;
&lt;p&gt;所以写这篇水文冒个泡, 算是个宣言吧... 我也希望能把这个小blog慢慢写下去~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Allez!~&lt;/strong&gt;&lt;/p&gt;</summary></entry><entry><title>水源PPP板图片下载器</title><link href="http://x-wei.github.io/%E6%B0%B4%E6%BA%90PPP%E6%9D%BF%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E5%99%A8.html" rel="alternate"></link><updated>2012-06-07T20:14:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/水源PPP板图片下载器.html</id><summary type="html">&lt;p&gt;这个其实是三月份的时候做的, 当时刚刚学会用urllib和正则表达式做一些爬虫, 于是结合人民群众的需要, 写了个小脚本(福利~) &lt;/p&gt;
&lt;p&gt;不过现在我还只是会照葫芦画瓢那样用urllib, 没什么长进...&lt;/p&gt;
&lt;p&gt;github地址: &lt;a href="https://github.com/X-Wei/yssy_ppp_pic_downloader"&gt;https://github.com/X-Wei/yssy_ppp_pic_downloader&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;/p&gt;
&lt;p&gt;功能就是下载水源ppperson板里帖子的图片, 并且每个帖子一个文件夹放好. 通过修改main函数可以选择下载最近一页的帖子还是下载全部帖子(或者最近几页的帖子)&lt;/p&gt;
&lt;p&gt;原理很简单, 分析网页的html代码, 用正则表达式找出图片的地址然后下载到本地. 当时我已经写了两三个简单的爬虫, 所以这个写得蛮快, 而且只用50行就搞定了...&lt;/p&gt;
&lt;p&gt;不会用多线程, 只能一张一张下载, 帖子数目实在太多了, 我让它跑了一晚上, 第二天跑完, 下载了8个G的图, 几千个文件夹(囧)......&lt;/p&gt;
&lt;p&gt;2.&lt;/p&gt;
&lt;p&gt;不过还是遇到了一些问题, 比较老的帖子会有些图片404, 这时或者这个帖子对应的文件夹为空, 或者里面的图片其实不是图片, 而是出错信息的html代码(虽然看后缀是个图片). 我需要把那些不是图片的文件删掉, 而且要删掉所有的空文件夹. &lt;/p&gt;
&lt;p&gt;删除不是图片的文件(其实应该是删除纯文本文件), 在水源发贴问, 用shell命令(perl)做到了(虽然不明白为什么这样写...):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;find yssy_ppp/ -type f | perl -ne 'chomp;unlink "$_" if -T $_'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关于删除空目录, 发现&lt;code&gt;rmdir&lt;/code&gt;命令就已经可以了, 会删除空文件夹, 非空文件夹不会删除(虽然会显示警告).&lt;/p&gt;
&lt;p&gt;python里面调用shell命令只需要:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;os.system("shell_command")&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以, 只需要在程序的最后加上两行:
    os.system('''find yssy_ppp/ -type f | perl -ne 'chomp;unlink "$&lt;em&gt;" if -T $&lt;/em&gt;' ''')
    os.system('rmdir yssy_ppp/*')&lt;/p&gt;
&lt;p&gt;虽然终端里运行时最后会因为那个&lt;code&gt;rmdir&lt;/code&gt;命令出一堆警告, 但是既然功能实现了就懒得改了...&lt;/p&gt;
&lt;p&gt;3.&lt;/p&gt;
&lt;p&gt;还写(改写)过一个人人相册下载的脚本, 不过需要改进, 不知毕业前能不能搞定......&lt;/p&gt;</summary><category term="git"></category><category term="python"></category><category term="shell"></category></entry><entry><title>用pandoc自由转换markdown与html格式</title><link href="http://x-wei.github.io/%E7%94%A8pandoc%E8%87%AA%E7%94%B1%E8%BD%AC%E6%8D%A2markdown%E4%B8%8Ehtml%E6%A0%BC%E5%BC%8F.html" rel="alternate"></link><updated>2012-06-07T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/用pandoc自由转换markdown与html格式.html</id><summary type="html">&lt;p&gt;markdown虽然写起来方便, 但是要预览的话还要用ReText打开, 而且ReText好像是Qt程序, 打开文件时不如别的编辑器那么流畅. 所以想找一个可以把markdown文件变成html格式的工具.&lt;/p&gt;
&lt;p&gt;我甚至搜了很久"markdown2html"(github上居然可以搜到好几个项目...) 而没有注意到, 在终端输入"html2markdown"时显示的警告:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;html2markdown
程序“html2markdown”尚未安装。  您可以使用以下命令安装：
sudo apt-get install pandoc
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;后来安装了pandoc(&lt;code&gt;sudo apt-get install pandoc&lt;/code&gt;), 其实只要看看帮助就知道咋用了: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;pandoc -h
pandoc &lt;span class="o"&gt;[&lt;/span&gt;OPTIONS&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;FILES&lt;span class="o"&gt;]&lt;/span&gt;
Input formats:  native, markdown, markdown+lhs, rst, rst+lhs, html, latex, latex+lhs
Output formats:  native, html, html+lhs, s5, docbook, opendocument, odt, latex, latex+lhs, context, texinfo, man, markdown, markdown+lhs, plain, rst, rst+lhs, mediawiki, rtf
Options:
  -f FORMAT, -r FORMAT  --from&lt;span class="o"&gt;=&lt;/span&gt;FORMAT, --read&lt;span class="o"&gt;=&lt;/span&gt;FORMAT                    
  -t FORMAT, -w FORMAT  --to&lt;span class="o"&gt;=&lt;/span&gt;FORMAT, --write&lt;span class="o"&gt;=&lt;/span&gt;FORMAT                     
  -s                    --standalone                                    
  -o FILENAME           --output&lt;span class="o"&gt;=&lt;/span&gt;FILENAME                               
  -p                    --preserve-tabs                                 
                        --tab-stop&lt;span class="o"&gt;=&lt;/span&gt;TABSTOP                              
                        --strict                                        
                        --reference-links                               
  -R                    --parse-raw                                     
  -S                    --smart                                         
  -m&lt;span class="o"&gt;[&lt;/span&gt;URL&lt;span class="o"&gt;]&lt;/span&gt;               --latexmathml&lt;span class="o"&gt;[=&lt;/span&gt;URL&lt;span class="o"&gt;]&lt;/span&gt;, --asciimathml&lt;span class="o"&gt;[=&lt;/span&gt;URL&lt;span class="o"&gt;]&lt;/span&gt;        
                        --mathml&lt;span class="o"&gt;[=&lt;/span&gt;URL&lt;span class="o"&gt;]&lt;/span&gt;                                  
                        --mimetex&lt;span class="o"&gt;[=&lt;/span&gt;URL&lt;span class="o"&gt;]&lt;/span&gt;                                 
                        --jsmath&lt;span class="o"&gt;[=&lt;/span&gt;URL&lt;span class="o"&gt;]&lt;/span&gt;                                  
                        --gladtex                                       
  -i                    --incremental                                   
                        --xetex                                         
  -N                    --number-sections                               
                        --no-wrap                                       
                        --sanitize-html                                 
                        --email-obfuscation&lt;span class="o"&gt;=&lt;/span&gt;none&lt;span class="p"&gt;|&lt;/span&gt;javascript&lt;span class="p"&gt;|&lt;/span&gt;references  
                        --id-prefix&lt;span class="o"&gt;=&lt;/span&gt;STRING                              
                        --indented-code-classes&lt;span class="o"&gt;=&lt;/span&gt;STRING                  
                        --toc, --table-of-contents                      
                        --base-header-level&lt;span class="o"&gt;=&lt;/span&gt;LEVEL                       
                        --template&lt;span class="o"&gt;=&lt;/span&gt;FILENAME                             
  -V FILENAME           --variable&lt;span class="o"&gt;=&lt;/span&gt;FILENAME                             
  -c URL                --css&lt;span class="o"&gt;=&lt;/span&gt;URL                                       
  -H FILENAME           --include-in-header&lt;span class="o"&gt;=&lt;/span&gt;FILENAME                    
  -B FILENAME           --include-before-body&lt;span class="o"&gt;=&lt;/span&gt;FILENAME                  
  -A FILENAME           --include-after-body&lt;span class="o"&gt;=&lt;/span&gt;FILENAME                   
  -C FILENAME           --custom-header&lt;span class="o"&gt;=&lt;/span&gt;FILENAME                        
  -T STRING             --title-prefix&lt;span class="o"&gt;=&lt;/span&gt;STRING                           
                        --reference-odt&lt;span class="o"&gt;=&lt;/span&gt;FILENAME                        
  -D FORMAT             --print-default-template&lt;span class="o"&gt;=&lt;/span&gt;FORMAT                 
                        --data-dir&lt;span class="o"&gt;=&lt;/span&gt;DIRECTORY                            
                        --dump-args                                     
                        --ignore-args                                   
  -v                    --version                                       
  -h                    --help
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;真是more than I've expected! markdown/rst/html/latex之间可以互转!&lt;/p&gt;
&lt;p&gt;使用pandoc命令就可以在随便转换了, 示例, 把demo.md输出成demo.html:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$pandoc -f markdown -t html -o demo.html demo.md&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者直接:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$pandoc -f markdown -t html -o demo.html demo.md&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我觉得这个实在是很有用的一条命令~&lt;/p&gt;</summary><category term="markdown"></category></entry><entry><title>寂静之声The Sound of Silence[Simon&amp;Garfunkel]</title><link href="http://x-wei.github.io/TheSoundofSilence.html" rel="alternate"></link><updated>2012-06-05T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/TheSoundofSilence.html</id><summary type="html">&lt;p&gt;所有事都完成, 开始写歌评.&lt;/p&gt;
&lt;h2&gt;intro引子&lt;/h2&gt;
&lt;p&gt;本来我是计划从老鹰的一首歌开始写的, 昨天甚至计划好了第一首就写Hotel California. &lt;/p&gt;
&lt;p&gt;BUT SOMEHOW, 决定第一首写它, 寂静之声(SoS).&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./TheSoundofSilence/SnG.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;如果把硬盘里的歌全部删了, 只能留十首歌的话, 我是肯定会留下这一首.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;歌名: The Sound of Silence&lt;/li&gt;
&lt;li&gt;专辑: The Graduate&lt;/li&gt;
&lt;li&gt;歌手: Simon&amp;amp;Garfunkel&lt;/li&gt;
&lt;li&gt;年代: 1967&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;不必多说, 这首歌应该知名度很高的吧, 西蒙与加芬科的成名作. Simon&amp;amp;Garfunkel组合凭借电影&amp;lt;&amp;lt;毕业生&amp;gt;&amp;gt;的两首配乐被许多人所熟知(另一首是Scarborough Fair). &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./TheSoundofSilence/Graduate.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;以下摘自百度百科:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《寂静之声》旋律飘缓低迷，歌词充满了一种幻觉般的意境。细细听来，仿佛在诉说着年轻无助的一种宣泄。眼前似乎看到一个懵懂无知的女孩，独自一人行走在铺着鹅卵石的狭窄、清冷的小巷里，喧嚣的人群在她身后渐渐远去，前面是没有尽头的黑夜……歌曲如果说是属于民谣的话似乎太深邃，如果说随着强劲的乐曲而震荡的节奏是摇滚的话，却太细腻，音乐上它造就了类的中和体，这应该是它成功的最大原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;lyrics歌词&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;Hello darkness, my old friend,
I’ve come to talk with you again,
Because a vision softly creeping,
Left its seeds while I was sleeping,
And the vision that was planted in my brain
Still remains
Within the sound of silence.

In restless dreams I walked alone
Narrow streets of cobblestone,
Neath the halo of a street lamp,
I turned my collar to the cold and damp
When my eyes were stabbed by the flash of a neon light
That split the night
And touched the sound of silence.

And in the naked light I saw
Ten thousand people, maybe more.
People talking without speaking,
People hearing without listening,
People writing songs that voices never share
And no one deared
Disturb the sound of silence.

“Fools” said I,”You do not know
Silence like a cancer grows.
Hear my words that I might teach you,
Take my arms that I might reach you.”
But my words like silent raindrops fell,
And echoed
In the wells of silence

And the people bowed and prayed 
To the neon god they made.
And the sign flashed out its warning,
In the words that it was forming.
And the signs said, The words of the prophets
are written on the subway walls
And tenement halls.
And whisper’d in the sounds of silence.

黑暗，老朋友，我来了
又想同你谈谈
突然有一种幻觉悄悄来临
趁着我入睡时播下了种子
那些个在我脑海中不停滋生的幻觉啊
还仍然滞留在寂寞之声中

在永无休止的梦里
我孤独地行走在
狭窄的布满圆石的路上
行走在路灯的光晕下
感到有点寒冷潮湿
于是我翻竖起衣领
那盏刺痛我双眼的霓红灯
划破了夜晚
触到了寂寞的音符

在那无遮蔽的灯光下
我看见成千上万的人
也许更多
人们无声地诉说着
人们无语地倾听着
他们写出一首首歌曲
却没有一个人去唱
没有人敢
惊扰寂寞沉睡时的轻梦

我说：你们这群傻子啊
难道不知道寂寞的癌细胞正在扩散吗
好好记住我教你们的话
握紧我伸给你们的手臂
可惜我的话只如同雨滴无声地落下
回荡在寂静的深井里

看人们朝着象征神圣的氖灯低头祈祷
而霓红灯广告牌却在讽刺地一闪一闪
发出这样的警告：
“先哲的预言就在地道下的墙上
就写在贫民们的住房里”
还依旧在一片祷告的寂静中喃喃地低语
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;remark简评&lt;/h2&gt;
&lt;p&gt;这首歌的主题好像是"人与人之间交流的障碍", 但是我听出来的却是年轻人关于未来的迷茫. 在电影&amp;lt;&amp;lt;毕业生&amp;gt;&amp;gt;的开头, 随着清脆的吉他前奏, 达斯汀霍夫曼一脸迷离的坐在回家的飞机上, 下飞机拿行李向我们走来...... 不过我是先听的歌后看的电影, 也许是歌太好听了, 电影没我预期的好看...&lt;/p&gt;
&lt;p&gt;歌一开头, "我"去找darkness谈话, 这首歌的内容就是"我"向黑暗讲述"我"的一个"vision", 一个诡异的幻觉或一种感觉:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In restless dreams I walked alone&lt;br /&gt;
Narrow streets of cobblestone,&lt;br /&gt;
Neath the halo of a street lamp,&lt;br /&gt;
I turned my collar to the cold and damp  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这也是我比较喜欢的几句歌词, 几句话就描述了一个让人难忘的典型的restless dream, 一种压抑无助的的气氛. 狭小的鹅卵石街道, 路旁昏暗的路灯, 一个人不安的独行, 禁不住竖起领子, 试图抵御让人难受的cold and damp...&lt;/p&gt;
&lt;p&gt;就在这时, 出现了一束刺眼的neon light, 划过长空. 这是"我"看到了人, 成千上万的人, 像一种仪式一样, 他们在做什么?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;People talking without speaking,&lt;br /&gt;
People hearing without listening,&lt;br /&gt;
People writing songs that voices never share&lt;br /&gt;
And no one deared&lt;br /&gt;
Disturb the sound of silence.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;"talking without speaking", "hearing without listening", 我觉得翻译成"说而不言, 听而不闻"比较好, 人们是怎么了? 这是一种什么状态? "我"有一种"众人皆醉我独醒"的感觉. 但当我要试图劝阻人们的时候, 却发现:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;But my words like silent raindrops fell,&lt;br /&gt;
And echoed&lt;br /&gt;
In the wells of silence  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结果就是"我"的声音回荡在寂静的深井中...&lt;/p&gt;
&lt;p&gt;接下来更是诡异的一幕: 人们像被催眠一般, 对neon god顶礼膜拜, 此时牌子上却闪现出了一行warning:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The words of the prophets&lt;br /&gt;
are written on the subway walls&lt;br /&gt;
And tenement halls.&lt;br /&gt;
And whisper’d in the sounds of silence.    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后歌曲就以这样一句让人迷惑的句子戛然而止.&lt;/p&gt;
&lt;p&gt;整个歌曲就是一个人的喃喃自语, 向darkness慢慢道来他的诡异见闻. 不过我觉得这种诡异和eagles歌曲里的诡异是两种完全不同的感觉, 这里的"诡异", 没有恐怖的气息, 有的只是&lt;strong&gt;迷茫和无助&lt;/strong&gt;......&lt;/p&gt;
&lt;p&gt;所以, 突然觉得这首歌是不是很合现在毕业的气氛呢? 人生的又一段重头戏就这样结束了, 下一段的路是什么样子, 会发生什么事会遇到什么人? 都是未知的, 已经年纪不小的我们, 还没有找到人生的目标和事业的轨迹...... &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;于是, 有时在独行的时候, 想着一些事情, 没来由地, Sound of Silence就会从耳边响起......&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以这首歌一直在我心目里占据一个特殊的位置.&lt;/p&gt;
&lt;h2&gt;versions版本&lt;/h2&gt;
&lt;p&gt;关于SoS, 版本实在太多了, 包括各种翻唱以及他们早年的表演, 我就只写几个让我印象深刻的吧...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电影原声配音&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个是把整个电影剪辑一下, 配上的电影原声. 剪辑的很好, 但是我不觉得西蒙与加芬科这一版唱的很好...&lt;/p&gt;
&lt;p&gt;&lt;embed src="http://player.youku.com/player.php/sid/XMTY0MTg3MDg0/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"&gt;&lt;/embed&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"那个"版本的寂静之声&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个版本我没有查到到底是谁唱的(原文件里没有这个信息?), 当时妈从单位上一个人那里拷来一些英语歌, 这首就在里面. 也许是先入为主吧, 总是觉得这首才最好听, 把那种迷茫的诡异的感觉演绎得淋漓尽致. &lt;code&gt;And the people bowed and prayed, to the neon god they made.&lt;/code&gt;简直就是一种宗教的仪式...&lt;/p&gt;
&lt;p&gt;(优酷上这个视频的配乐刚好就是"那个"版本, 就拿来了)&lt;/p&gt;
&lt;p&gt;&lt;embed src="http://player.youku.com/player.php/sid/XMjc0NDgxOTM2/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"&gt;&lt;/embed&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Yao Shi Ting版&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个中国人的翻唱版, 总觉得这个版本和其他的翻唱版有点区别, 姚斯婷的声音很空灵, 别有一番滋味.&lt;/p&gt;
&lt;p&gt;&lt;embed src="http://player.youku.com/player.php/sid/XODE1MTM4NTI=/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"&gt;&lt;/embed&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;concert in central park&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="./TheSoundofSilence/CiCP.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./TheSoundofSilence/CiCP2.gif" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1981年9月19日，在美国纽约中央公园上演了一场摇滚史上着名的音乐会，那就是Simon &amp;amp; Garfunkel举行的免费音乐会，这也是两人各自单飞11年后的首度合作，约50万歌迷前来捧场，场面蔚为壮观，虽然当时两人都已年过40，但是和声依旧美妙。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当年非常激动下载到了这个演唱会, 找了很久才找到...... 可以说这个演唱会的Sound of Silence以及Scarborough Fair是最最经典的版本. 那时的Simon&amp;amp;Garfunkel都四十几岁, 和声依旧美妙无比, 后来(2002?)格莱美颁奖时, 他们不仅苍老, 嗓子也已经变得沙哑...&lt;/p&gt;
&lt;p&gt;SoS是演唱会快结束是才唱到的, 西蒙的吉他响起, 全场顿时一阵骚动, 但又很快安静下来. 只有西蒙的吉他伴奏, 寂静之声就这样慢慢蔓延开来...... 有几个镜头给了台下观众, 有的低头并把手插在口袋里默默的听, 有的情侣相互依偎着跟着哼唱. 大家都像被催眠了一样, 沉浸在这寂静之声中...&lt;/p&gt;
&lt;p&gt;有一个细节, 其实在他们唱的时候, 观众是在拍手打节拍的, 而其实我看了很多次也没有注意到. 然后, 高三时某天晚上放学回家的路上, 脑海里回放这首歌的时候, 突然, 那些掌声变的异常清晰, 仿佛那些掌声也是伴奏的一部分... 觉得观众的掌声和喊声实在是和西蒙的吉他配合得天衣无缝, 恰到好处, 堪称完美(另一首我觉得现场观众的喊声与歌声配合完美的歌, 大概是94年老鹰的木吉他加州旅馆)......&lt;/p&gt;
&lt;p&gt;这也许就是为什么这一个版本的SoS让我百看不厌的原因吧. &lt;/p&gt;
&lt;p&gt;&lt;embed src="http://player.youku.com/player.php/sid/XMjQ0NjU5MTE2/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"&gt;&lt;/embed&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;第一篇... 终于写完了, 写得好累啊, 以后可能不能每首都写那么多了, 我觉得有可说的就说, 不想说的就不写那么多, 不能让写这些东西变成一种负担...&lt;/p&gt;</summary><category term="Simon&amp;Garfunkel"></category></entry><entry><title>交大beamer模板</title><link href="http://x-wei.github.io/beamer_template.html" rel="alternate"></link><updated>2012-06-02T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/beamer_template.html</id><summary type="html">&lt;p&gt;毕设完了, 把答辩时用的beamer模板拿出来分享下.&lt;/p&gt;
&lt;p&gt;github项目地址:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/X-Wei/aBeamerTemplate4SJTU"&gt;https://github.com/X-Wei/aBeamerTemplate4SJTU&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我是tex菜鸟, 基本是遇见什么问题然后上网搜一通找到解决方案... 这个模板自然也是参考的别人的了...&lt;/p&gt;
&lt;p&gt;参考自&lt;a href="http://yixf.name/2011/06/21/%E4%BD%BF%E7%94%A8xetex%E7%9A%84beamer%E6%A8%A1%E7%89%88/"&gt;Yixf’s blog&lt;/a&gt;, 我只是修改了一下主题, 换了一下交大的图标, 并且做了一些常用功能的例子...&lt;/p&gt;
&lt;p&gt;效果截图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./beamer_template/Screenshot.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用xelatex编译生成, latex估计不行, xelatex的配置参考&lt;a href="http://x-wei.github.com/xelatex_zh.html"&gt;这里&lt;/a&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编辑内容直接修改beame_body.tex即可, 改变设置一般在beamer_header.tex里&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我用的是文泉驿的字体, 可以修改beamer_header.tex改变字体设置, 查看已安装的中文字体的命令为: &lt;code&gt;fc-list :lang=zh-cn&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;个人一点感觉: 用tex写ppt有时也会因为少些括号或者什么地方没注意老编译不过, 所以用tex写也不一定能比用powerpoint方便, 不论啥工具, 只要能&lt;strong&gt;get things done&lt;/strong&gt;,就是好工具~&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="tex"></category><category term="git"></category></entry><entry><title>github上两个比较有用的小项目</title><link href="http://x-wei.github.io/github%E4%B8%8A%E4%B8%A4%E4%B8%AA%E6%AF%94%E8%BE%83%E6%9C%89%E7%94%A8%E7%9A%84%E5%B0%8F%E9%A1%B9%E7%9B%AE.html" rel="alternate"></link><updated>2012-05-31T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/github上两个比较有用的小项目.html</id><summary type="html">&lt;p&gt;github上的好东西不少, 最近发现了两个比较有用的python程序, 这俩功能都是我比较想要的, 有需求就会有牛人去实现~&lt;/p&gt;
&lt;h1&gt;1. 视频下载器youku-lixian&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/iambus/youku-lixian"&gt;https://github.com/iambus/youku-lixian&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可不止支持下载优酷的视频奥, 土豆, 奇艺, 新浪, 酷6...... 通吃~&lt;/p&gt;
&lt;p&gt;而且每个都只是一个小小的py文件, 直接就可以运行, 比起什么优酷客户端, 奇艺客户端小多了! 太赞了!~&lt;/p&gt;
&lt;h1&gt;2. 115网盘自动摇奖&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://gist.github.com/2698830"&gt;https://gist.github.com/2698830&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个功能我曾经想要实现, 但是关于网络通信方面知道的太少了, 搞了一通也没有成功. 现在有人把它共享出来, 代码居然还不到100行, 强大啊~&lt;/p&gt;</summary><category term="git"></category><category term="python"></category></entry><entry><title>给网页添加交互的flash小老鼠</title><link href="http://x-wei.github.io/%E7%BB%99%E7%BD%91%E9%A1%B5%E6%B7%BB%E5%8A%A0%E4%BA%A4%E4%BA%92%E7%9A%84flash%E5%B0%8F%E8%80%81%E9%BC%A0.html" rel="alternate"></link><updated>2012-05-30T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/给网页添加交互的flash小老鼠.html</id><summary type="html">&lt;p&gt;昨天晚上, &lt;a href="http://tieba.baidu.com/p/1621093558#10006-renren-1-97561-1e150dff36f3a7351b3a37e9a1af102e"&gt;这个帖子&lt;/a&gt;突然火了, 号称是交大技术男给女朋友做的... 亮点在于那只小老鼠:&lt;/p&gt;
&lt;p&gt;&lt;object type="application/x-shockwave-flash" style="outline:none;" data="http://hosting.gmodules.com/ig/gadgets/file/112581010116074801021/hamster.swf?" width="300" height="225"&gt;&lt;param name="movie" value="http://hosting.gmodules.com/ig/gadgets/file/112581010116074801021/hamster.swf?"&gt;&lt;/param&gt;&lt;param name="AllowScriptAccess" value="always"&gt;&lt;/param&gt;&lt;param name="wmode" value="opaque"&gt;&lt;/param&gt;&lt;/object&gt;&lt;/p&gt;
&lt;p&gt;我点进去看, 也很吃惊, 不过为什么那是一个flash? 而且美工做得这么好...&lt;/p&gt;
&lt;p&gt;然后今天有人爆料, 这个其实是用的现成的材料, 网站是: &lt;/p&gt;
&lt;p&gt;&lt;a href="http://abowman.com/"&gt;http://abowman.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个网站提供了很多gadgets, 而且都做得好厉害, 还提供了对应的html代码, 只要粘贴进文件就能够看见了...&lt;/p&gt;
&lt;p&gt;所以我把那个小老鼠搬到了侧边栏...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那个网站的一些小工具展示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Penguins:&lt;/p&gt;
&lt;p&gt;&lt;object type="application/x-shockwave-flash" style="outline:none;" data="http://penguinsgadget.googlecode.com/svn/trunk/penguins.swf?" width="300" height="200"&gt;&lt;param name="movie" value="http://penguinsgadget.googlecode.com/svn/trunk/penguins.swf?"&gt;&lt;/param&gt;&lt;param name="AllowScriptAccess" value="always"&gt;&lt;/param&gt;&lt;param name="wmode" value="opaque"&gt;&lt;/param&gt;&lt;param name="scale" value="noscale"/&gt;&lt;param name="salign" value="tl"/&gt;&lt;/object&gt;&lt;/p&gt;
&lt;p&gt;Tree Frog:&lt;/p&gt;
&lt;p&gt;&lt;object type="application/x-shockwave-flash" style="outline:none;" data="http://hosting.gmodules.com/ig/gadgets/file/112581010116074801021/treefrog.swf?" width="300" height="200"&gt;&lt;param name="movie" value="http://hosting.gmodules.com/ig/gadgets/file/112581010116074801021/treefrog.swf?"&gt;&lt;/param&gt;&lt;param name="AllowScriptAccess" value="always"&gt;&lt;/param&gt;&lt;param name="wmode" value="opaque"&gt;&lt;/param&gt;&lt;param name="scale" value="noscale"/&gt;&lt;param name="salign" value="tl"/&gt;&lt;/object&gt;&lt;/p&gt;
&lt;p&gt;Newton’s Cradle:&lt;/p&gt;
&lt;p&gt;&lt;object type="application/x-shockwave-flash" style="outline:none;" data="http://hosting.gmodules.com/ig/gadgets/file/112581010116074801021/newtonsCradle.swf?" width="300" height="225"&gt;&lt;param name="movie" value="http://hosting.gmodules.com/ig/gadgets/file/112581010116074801021/newtonsCradle.swf?"&gt;&lt;/param&gt;&lt;param name="AllowScriptAccess" value="always"&gt;&lt;/param&gt;&lt;param name="wmode" value="opaque"&gt;&lt;/param&gt;&lt;/object&gt;&lt;/p&gt;
&lt;p&gt;Fish:&lt;/p&gt;
&lt;p&gt;&lt;object type="application/x-shockwave-flash" style="outline:none;" data="http://hosting.gmodules.com/ig/gadgets/file/112581010116074801021/fish.swf?" width="300" height="200"&gt;&lt;param name="movie" value="http://hosting.gmodules.com/ig/gadgets/file/112581010116074801021/fish.swf?"&gt;&lt;/param&gt;&lt;param name="AllowScriptAccess" value="always"&gt;&lt;/param&gt;&lt;param name="wmode" value="opaque"&gt;&lt;/param&gt;&lt;param name="scale" value="noscale"/&gt;&lt;param name="salign" value="tl"/&gt;&lt;/object&gt;&lt;/p&gt;
&lt;p&gt;不过貌似我用的模板的宽度和这个flash有点不匹配... 可能过几天就把它从侧栏撤掉了...&lt;/p&gt;</summary></entry><entry><title>关于用pelican写博客的三点tips</title><link href="http://x-wei.github.io/%E5%85%B3%E4%BA%8E%E7%94%A8pelican%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%89%E7%82%B9tips.html" rel="alternate"></link><updated>2012-05-27T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/关于用pelican写博客的三点tips.html</id><summary type="html">&lt;h1&gt;1.插入视频&lt;/h1&gt;
&lt;p&gt;效果就像校内网日志那样, 可以内嵌的视频.&lt;/p&gt;
&lt;p&gt;其实很简单, 只需要把html代码放进markdown源文件就行了! 而视频的html代码在视频网站上一般都会提供:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./关于用pelican写博客的两点tips/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;复制下来放进源文件即可&lt;/p&gt;
&lt;h1&gt;2.删除线&lt;/h1&gt;
&lt;p&gt;markdown不支持删除线? 反正我没有在教程里找到... 但是删除线确实是个有用的功能, 在zim里记笔记的时候我就经常使用.
但是好像听说markdown是支持html内容的, 那么, 是不是直接加html的删除线代码就行了呢? 果然~!&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;s&amp;gt;&lt;/span&gt;文本&lt;span class="nt"&gt;&amp;lt;/s&amp;gt;&lt;/span&gt;
or
&lt;span class="nt"&gt;&amp;lt;strike&amp;gt;&lt;/span&gt;文本&lt;span class="nt"&gt;&amp;lt;/strike&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;嗯, 更复杂的html样式如果markdown没有的话也可以用这种方法弄~&lt;/p&gt;
&lt;h1&gt;3.给博客加入分享按钮&lt;/h1&gt;
&lt;p&gt;这个也是用网上找的html代码, 然后修改了一下主题(pelican-themes/bs5)中的一个html文件, 不过我水平太菜, 改了好久也没能让分享按钮处于标题下方...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2012-05-31补充&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原先那个分享的按钮不好看也不很好用, 我借鉴了&lt;a href="http://www.ubuntusoft.com/"&gt;ubuntusoft&lt;/a&gt;网站上的分享按钮和回顶部按钮, 查看了下网页代码, 原来是用的百度分享以及友荐按钮, 修改主题文件&lt;code&gt;./pelican-themes/bs6/templates/base.html&lt;/code&gt;,在&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;后面加上这几行:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;&amp;lt;!-- Baidu Button BEGIN --&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bdshare_js&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;data=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;type=slide&amp;amp;img=6&amp;amp;pos=right&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bdshell_js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        var bds_config = {&amp;quot;bdTop&amp;quot;:289};
        document.getElementById(&amp;quot;bdshell_js&amp;quot;).src = &amp;quot;http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=&amp;quot; + new Date().getHours();
&lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!-- Baidu Button END --&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!-- UJian Button BEGIN --&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://v1.ujian.cc/code/ujian.js?type=slide&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!-- UJian Button END --&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;网页就变成了现在的样子, 嗯, 现在就比较满意了...&lt;/p&gt;</summary><category term="pelican"></category><category term="markdown"></category></entry><entry><title>TODO list--忙完这一段之后要做的事情</title><link href="http://x-wei.github.io/TODOlist-20120511.html" rel="alternate"></link><updated>2012-05-11T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/TODOlist-20120511.html</id><summary type="html">&lt;p&gt;好吧最近太废了... 主观原因是心不静, 懒惰拖延, 客观原因(理由)是毕设和法语...&lt;/p&gt;
&lt;p&gt;仔细分析一下, 貌似目前还是要专心把毕设跟法语搞定. 但是我还是想在毕业前多做一点事情, 列一个清单, 等忙完这一阵就开始做一下这些事情: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写歌评&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Eagles, Simon&amp;amp;Garfunkel, Brothers Four, 主要是这三个乐队的, 大概会有20首吧... 可能毕业前写不完, 但是一定要开始写, 我觉得关于某些歌我会有很多要写的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写写我的毕设&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能我做的毕设没什么意思, 但是至少可以写写那些学到的matlab技巧.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写(所谓的)总结贴&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个是GT的一些经验总结, 一个是PT申请的一些经验总结. 这两件事大概就是我的2011的主线. 唉, 要是前者在2011年7月写掉, 后者在2011年12月写掉该多好!......&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;行了, 还是好好对付法语考试以及毕设论文去吧...&lt;/p&gt;</summary></entry><entry><title>打乱文本的行</title><link href="http://x-wei.github.io/%E6%89%93%E4%B9%B1%E6%96%87%E6%9C%AC%E7%9A%84%E8%A1%8C.html" rel="alternate"></link><updated>2012-05-01T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/打乱文本的行.html</id><summary type="html">&lt;p&gt;今天cbl问了我一个问题: 怎样打乱一个文本文件的所有行??&lt;/p&gt;
&lt;p&gt;仔细一想, 确实有难度... 因为那个文本文件居然有1G, 用python读进内存再打乱的思路估计不行啊... 那么awk, shell什么的有没有解决方法? 搜到了一些帖子, 但是稍微复杂一点的shell脚本我也看不懂(弱爆了)...&lt;/p&gt;
&lt;p&gt;我甚至想大概vim会提供这个功能吧, 没想到在搜的时候居然搜到了一个现成的shell命令: &lt;strong&gt;shuf&lt;/strong&gt;!!&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;shuf --help
用法： shuf &lt;span class="o"&gt;[&lt;/span&gt;选项&lt;span class="o"&gt;]&lt;/span&gt;... &lt;span class="o"&gt;[&lt;/span&gt;文件&lt;span class="o"&gt;]&lt;/span&gt;
　或者:  shuf -e &lt;span class="o"&gt;[&lt;/span&gt;选项&lt;span class="o"&gt;]&lt;/span&gt;... &lt;span class="o"&gt;[&lt;/span&gt;参数&lt;span class="o"&gt;]&lt;/span&gt;...
　或者:  shuf -i LO-HI &lt;span class="o"&gt;[&lt;/span&gt;选项&lt;span class="o"&gt;]&lt;/span&gt;...
把输入行按随机顺序输出到标准输出。

长选项必须使用的参数对于短选项时也是必需使用的。
  -e, --echo            将每个参数视为输入行
  -i, --input-range&lt;span class="o"&gt;=&lt;/span&gt;LO-HI   将LO 到HI 的每个数字视为输入行
  -n, --head-count&lt;span class="o"&gt;=&lt;/span&gt;行数       最多输出指定的行数
  -o, --output&lt;span class="o"&gt;=&lt;/span&gt;文件       将结果输出到指定文件而非标准输出
      --random-source&lt;span class="o"&gt;=&lt;/span&gt;文件    从指定文件获得随机比特
  -z, --zero-terminated 以0 结束行而非新行
      --help        显示此帮助信息并退出
      --version     显示版本信息并退出

如果没有指定文件，或者文件为&lt;span class="s2"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;，则从标准输入读取。

&lt;span class="o"&gt;[&lt;/span&gt;请向bug-coreutils@gnu.org&lt;span class="o"&gt;](&lt;/span&gt;mailto:请向bug-coreutils@gnu.org&lt;span class="o"&gt;)&lt;/span&gt; 报告shuf 的错误
GNU coreutils 项目主页：&lt;span class="s"&gt;&amp;lt;&amp;lt;http://www.gnu.org/software/coreutils/&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class="s"&gt;GNU 软件一般性帮助：&amp;lt;&amp;lt;http&lt;/span&gt;://www.gnu.org/gethelp/&amp;gt;&amp;gt;
请向&lt;span class="s"&gt;&amp;lt;&amp;lt;http://translationproject.org/team/zh_CN.ht&lt;/span&gt;ml&amp;gt;&amp;gt; 报告shuf 的翻译错误
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;太好了吧! 用一个小的文本文件一试, 果然是可以的! 
&lt;code&gt;shuf [filename]&lt;/code&gt;
另外, 加上-o参数, 可以指定输出到一个新文件(估计用shell的输出重定向方法也可以吧):
&lt;code&gt;shuf [filename] -o [output_filename]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对了, 我搜到的网址是&lt;a href="http://os.51cto.com/art/201103/246525.htm"&gt;这里&lt;/a&gt;, 介绍了一些非主流的命令. 比如另一条命令: &lt;code&gt;tac&lt;/code&gt;(&lt;code&gt;cat&lt;/code&gt;的反转), 作用是先输出文件的末端, 也很有意思.&lt;/p&gt;</summary><category term="shell"></category></entry><entry><title>在bolg页面上加入ubuntu发布倒计时图标</title><link href="http://x-wei.github.io/%E5%9C%A8bolg%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%8A%A0%E5%85%A5ubuntu%E5%8F%91%E5%B8%83%E5%80%92%E8%AE%A1%E6%97%B6%E5%9B%BE%E6%A0%87.html" rel="alternate"></link><updated>2012-04-25T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/在bolg页面上加入ubuntu发布倒计时图标.html</id><summary type="html">&lt;p&gt;明天ubuntu12.04&lt;strong&gt;LTS&lt;/strong&gt;就要发布了! 然后今天下课回来在各种网站上闲逛, 突然发现了这个页面: &lt;a href="http://www.ubuntu.com/community/countdown"&gt;给网页添加ubuntu发布倒计时&lt;/a&gt;. 很厉害的样子, 介绍说只要把那一段代码加入网页的html文件就可以了. 我试了一下, 直接加在index.html上面--还真的可以唉~~&lt;/p&gt;
&lt;p&gt;不过, pelican每次都是自动生成和更新index.html的啊, 难道每次都要手动加入这一行代码?? 难道还要自己修改pelican的代码??......&lt;/p&gt;
&lt;p&gt;此时我想到了farseerfc学长的配置文件, 其中我把他的微博秀那几行注释掉了:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;#~ SIDEBAR_CUSTOM = r&amp;quot;&amp;quot;&amp;quot;
#~ &lt;span class="nt"&gt;&amp;lt;li&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;nav-header&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;h4&amp;gt;&amp;lt;i&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;icon-list-alt&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/i&amp;gt;&lt;/span&gt;Weibo&lt;span class="nt"&gt;&amp;lt;/h4&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
#~ &lt;span class="nt"&gt;&amp;lt;iframe&lt;/span&gt; &lt;span class="na"&gt;width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;100%&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;550&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;share_self&amp;quot;&lt;/span&gt;  &lt;span class="na"&gt;frameborder=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;scrolling=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;no&amp;quot;&lt;/span&gt; 
&lt;span class="err"&gt;#~&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;lt;http://widget.weibo.com/weiboshow/index.php?language=&amp;amp;width=0&amp;amp;height=550&amp;amp;fansRow=1&amp;amp;ptype=1&amp;amp;speed=0&amp;amp;skin=2&amp;amp;isTitle=1&amp;amp;noborder=1&amp;amp;isWeibo=1&amp;amp;isFans=1&amp;amp;uid=1862842353&amp;amp;verifier=b193b9de&amp;amp;dpc=1&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
#~ &lt;span class="nt"&gt;&amp;lt;/iframe&amp;gt;&lt;/span&gt;
#~ &amp;quot;&amp;quot;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;今天仔细一看, 我靠, &lt;code&gt;SIDEBAR_CUSTOM&lt;/code&gt;不就是可以自定义的侧边栏么??!! 赶紧, 写上这样一行:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;SIDEBAR_CUSTOM=r&amp;quot;&amp;quot;&amp;quot;
&lt;span class="nt"&gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;lt;http://www.ubuntu.com/&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;img&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;lt;http://www.ubuntu.com/countdown/banner1.png&amp;gt;&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;border=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;width=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;180&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;height=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;150&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;alt=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;The next version of Ubuntu is coming soon&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&amp;quot;&amp;quot;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行一下, 果然好了!!~~ 需要注意的是, 这个设置只有使用farseerfc制作的bootstrap2主题时才有用(再次感谢farseerfc!)~&lt;/p&gt;
&lt;p&gt;那么怎么添加多个小工具呢? 很简单, 只要在字符串SIDEBAR_CUSTOM里面罗列copy来的代码就可以啦!~(比如, 还可以&lt;a href="http://www.google.com/talk/service/badge/New"&gt;添加gtalk&lt;/a&gt;的小工具.) 所以, google自定义搜索引擎其实也可以这样添加的~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BTW&lt;/strong&gt;
今天才知道原来pelican是支持中文文件名的啊啊啊啊啊... 以后没必要取那些dt的英文文件名了...
另外今天又自己修改了一点bootstrap2主题(把存档页面换成了bootstrap主题的...), 越来越喜欢pelican这个工具了~&lt;/p&gt;</summary><category term="pelican"></category></entry><entry><title>不用安装插件, 设置chrome点击播放flash</title><link href="http://x-wei.github.io/chrome_flashblock.html" rel="alternate"></link><updated>2012-04-24T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/chrome_flashblock.html</id><summary type="html">&lt;p&gt;以前搜索怎么加速打开网页的速度, 有人会推荐flashblock插件. 安装之后, 所有的flash(视频也好, 广告也好)都不会自动播放, 只有自己去点击一下才会播放. 当时觉得这样挺好啊, 因为flash肯定占用了不少带宽以及cpu嘛~&lt;/p&gt;
&lt;p&gt;后来, 发现cbl同学没有安装插件也实现了这样的效果, 如下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./chrome_flashblock/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;cbl教我把chrome设置成插件点击播放, 个人感觉这样挺有用的~
大概是两步:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;, 扳手菜单--&amp;gt;首选项--&amp;gt;高级选项--&amp;gt;隐私设置--&amp;gt;内容设置&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./chrome_flashblock/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;然后找到"插件"这一项, 选择"点后运行"
&lt;img alt="" src="./chrome_flashblock/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;p&gt;这样设置之后, chrome就不会自动播放flash, 然后再设置点击运行flash.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;, 在地址栏输入: &lt;chrome://flags/&gt;, 找到"点后运行"一行, 选择"启用".&lt;/p&gt;
&lt;p&gt;OK, 到此为止, 就可以不装插件实现flashblock效果了~~&lt;/p&gt;</summary><category term="google"></category></entry><entry><title>使用google自定义搜索以及让google收录自己的网站</title><link href="http://x-wei.github.io/add-google-custom-search.html" rel="alternate"></link><updated>2012-04-23T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/add-google-custom-search.html</id><summary type="html">&lt;p&gt;虽然我的blog点击人数可能还是个位数的, 我还是每天都想折腾一下它...&lt;/p&gt;
&lt;p&gt;bootstrap2模板里提供了很丰富的内容(可以看farseerfc学长的页面), 其中的google站内搜索我觉得很有用, 于是也自己去弄了一下...&lt;/p&gt;
&lt;h1&gt;使用google自定义搜索&lt;/h1&gt;
&lt;p&gt;要登录google&lt;a href="http://www.google.com/cse/?hl=zh-CN"&gt;自定义搜索&lt;/a&gt;, 的页面, 用google帐号登录, 然后选择新建一个自定义搜索引擎, 会看到这样的界面: &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./add-google-custom-search/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;第一项的名称和描述啥的随便填就行, 关键是第二项"要搜索的网站", 可以点击"了解详情"看一下应该怎么写. 比如我的网站是&lt;code&gt;x-wei.github.com&lt;/code&gt;, 而且我想是在这个网站的所有子页面中搜索, 于是这里就填写: &lt;code&gt;x-wei.github.com/*&lt;/code&gt;即可~ 第三项当然是免费版, 然后下一步.&lt;/p&gt;
&lt;p&gt;下一步是一个测试, 可以在搜索框里尝试一下能不能得到想要的结果(&lt;strong&gt;我就是这里有问题的, 待会说&lt;/strong&gt;). 如果没问题, 点击下一步, 下一步是给出了一段html代码, 把这些代码加入网页就可以添加google自定义搜索栏了(不过使用pelican写博客的话就不用这样了, 见后文).&lt;/p&gt;
&lt;p&gt;嗯, 这个过程还是非常简单的吧!~&lt;/p&gt;
&lt;h1&gt;如何把自定义搜索栏加入pelican生成的页面&lt;/h1&gt;
&lt;p&gt;首先, 可能只能使用bootstrap2这个主题... 然后, 在&lt;code&gt;settings.py&lt;/code&gt;文件里加入这一行: 
&lt;code&gt;GOOGLE_CUSTOM_SEARCH_SIDEBAR = "001578481551708017171:axpo6yvtdyg"&lt;/code&gt;
注意, 引号里的那一串字符是你刚才申请的自定义搜索引擎的id, 这个id在哪里? 再次登录google自定义搜索, 这次点"管理现有引擎", 点击你刚才创建的那个引擎的"控制面板":&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./add-google-custom-search/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;在基本信息里面就会看到"搜索引擎的唯一 ID", 把那一串数字赋值给GOOGLE_CUSTOM_SEARCH_SIDEBAR即可~&lt;/p&gt;
&lt;h1&gt;让google收录你的网站&lt;/h1&gt;
&lt;p&gt;但是我没有那么顺利的完成以上, 因为我在测试自定义引擎的时候总是搜不到任何我的网站的东西... 还以为是设置搜索的网页格式写错了呢... 非常崩溃... 后来在zyb同学的提醒下意识到可能是google没有收录我的网页... 果然, google怎么也搜不到我的网站的内容唉...&lt;/p&gt;
&lt;p&gt;那么怎么才能让google收录自己的网页?? 难道要坐等几个月后google发现我? 呵呵, 其实是可以主动申请让搜索引擎收录自己的网站的, 我看的&lt;a href="http://zhidao.baidu.com/question/102933806.html"&gt;这里&lt;/a&gt;. 原来就是很简单的一个工作, &lt;a href=""&gt;登录http://www.google.com/addurl/?hl=zh-CN&amp;amp;continue=/addurl&lt;/a&gt; (要是想被百度收录就登录 &lt;a href="http://www.baidu.com/search/url_submit.html"&gt;http://www.baidu.com/search/url_submit.html&lt;/a&gt; ) 填上你的网址以及验证码(google的验证码太难辨认... 而百度的有点太简单了吧...)就可以了, 我昨天填的, 今天一试发现就可以搜索到了! 然后又发现google自定义搜索也好使了!~~&lt;/p&gt;</summary><category term="pelican"></category><category term="google"></category></entry><entry><title>修改host去除优酷奇艺网站广告</title><link href="http://x-wei.github.io/host_youkuqiyi.html" rel="alternate"></link><updated>2012-04-19T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/host_youkuqiyi.html</id><summary type="html">&lt;p&gt;优酷现在的广告已经是半分钟长了?? 所以屏蔽这些广告还是很有必要滴~&lt;/p&gt;
&lt;p&gt;之前, 马阳同学给我一个修改host的方式, 用了几个月之后, 发现不好使了: 虽然不会显示广告, 但是不会直接跳过去, 而是显示"广告不能正常播放..." 然后还是要等待半分钟才能看... &lt;/p&gt;
&lt;p&gt;后来, 看了&lt;a href="http://www.nenew.net/youku-qiyi-hosts-windows-win7-windows7-vista-ubuntu-linux-archlinux-firefox-chrome.html"&gt;奶牛的博客&lt;/a&gt;, 终于找到了解决办法, 至少到目前还是好使的~&lt;/p&gt;
&lt;h1&gt;第一步&lt;/h1&gt;
&lt;p&gt;首先, 添加屏蔽广告的host. 关于host的修改, 直接参考&lt;a href="http://x-wei.github.com/google_host.html"&gt;这篇博客&lt;/a&gt;, 把里面host的全部内容粘贴进对应的文件中.&lt;/p&gt;
&lt;h1&gt;第二步&lt;/h1&gt;
&lt;p&gt;然后, 按照奶牛的办法:&lt;/p&gt;
&lt;h2&gt;linux用户&lt;/h2&gt;
&lt;p&gt;找到: &lt;code&gt;~/.macromedia/Flash_Player/#SharedObjects/某某名字文件夹/&lt;/code&gt; 这里, 可能会有两个文件夹: &lt;code&gt;www.iqiyi.com&lt;/code&gt;以及&lt;code&gt;static.youku.com&lt;/code&gt;, 删除之, 然后新建两个空白文件, 名字就取这两个文件夹的名字(要是没有这俩文件夹, 则直接新建这两个空白文件).&lt;/p&gt;
&lt;h2&gt;windows用户&lt;/h2&gt;
&lt;p&gt;和linux用户一样, 只是那个文件夹在: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;(xp) C:\Documents and Settings\Administrator\Application Data\Macromedia\Flash Player\#SharedObjects\某某名字文件夹 (呵呵, 略长略长...)
(win7) C:\Users\用户名\AppData\Roaming\Macromedia\Flash Player\#SharedObjects\某某名字文件夹
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意啊, 新建的空白文件就是叫&lt;code&gt;www.iqiyi.com&lt;/code&gt;和&lt;code&gt;static.youku.com&lt;/code&gt;, 我的意思是...别加上.txt的后缀之类的...&lt;/p&gt;
&lt;p&gt;这样做好之后, 看优酷奇艺的视频就没有广告了, enjoy~&lt;/p&gt;
&lt;p&gt;另外, 我的host文件里好像提供了土豆的屏蔽规则, 但是貌似不大好使...&lt;/p&gt;</summary><category term="host"></category></entry><entry><title>修改host访问google的所有服务</title><link href="http://x-wei.github.io/google_host.html" rel="alternate"></link><updated>2012-04-18T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/google_host.html</id><summary type="html">&lt;p&gt;google的服务(mail, doc, site, code, project...)很多都实在很方便(个人感觉QQ, 网易什么的和它绝对不是一个档次). 但是比较悲剧的是, google服务在国内不很稳定, 时不时上不去(比如gmail), 而有的服务(比如site)居然完全上不去...&lt;/p&gt;
&lt;p&gt;自己的经验, 使用修改host的方式可以比较好的解决这个问题(而youtube啊, facebook啊什么的修改了不一定好使...) 这里贴一下..&lt;/p&gt;
&lt;p&gt;其实就是修改一个文件...linux用户修改&lt;code&gt;/ect/hosts&lt;/code&gt;, windows用户修改&lt;code&gt;c:/windows/system32/drivers/etc/hosts&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2012-07-06更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面这些host不给力了, 新的host见&lt;a href="http:x-wei.github.com/google_youku_host_20120706.html"&gt;我的日志&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;S&gt;
关于google的host, 网上到处都是, 比如&lt;a href="http://www.douban.com/note/161139377/"&gt;这里&lt;/a&gt;, 不过我没有试过这里的host可不可以(应该可以吧...), 还是把我的host贴出来吧. 这里说一下, 我同时还加了去优酷广告(这里修改完了还要&lt;a href="http://x-wei.github.com/host_youkuqiyi.html"&gt;再处理一下&lt;/a&gt;), 上youtube(貌似有点问题). 把这些东西粘贴进hosts文件, 即可访问google的服务, gmail也不会抽风了~~
(要是嫌复制粘贴麻烦, 直接&lt;a href="./google_host/hosts"&gt;下载hosts文件&lt;/a&gt;)&lt;/S&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;#优酷屏蔽广告规则如下：
127.0.0.1       stat.youku.com
127.0.0.1       static.lstat.youku.com
127.0.0.1       static.atm.youku.com/crossdomain.xml
127.0.0.1       valb.atm.youku.com
127.0.0.1       valc.atm.youku.com
127.0.0.1       valf.atm.youku.com
127.0.0.1       valo.atm.youku.com
127.0.0.1       valp.atm.youku.com
127.0.0.1       vid.atm.youku.com
127.0.0.1       walp.atm.youku.com
#土豆屏蔽广告规则如下：
127.0.0.1       adextensioncontrol.tudou.com
127.0.0.1       adplay.tudou.com
127.0.0.1       adcontrol.tudou.com
127.0.0.1       iwstat.tudou.com
127.0.0.1       nstat.tudou.com
127.0.0.1       stat.tudou.com
127.0.0.1       stats.tudou.com
127.0.0.1       at-img1.tdimg.com
127.0.0.1       at-img2.tdimg.com
127.0.0.1       at-img3.tdimg.com
127.0.0.1        *.p2v.tudou.com*
#PS:    127.0.0.1       at-img1.tdimg.com
127.0.0.1       at-img2.tdimg.com
127.0.0.1       at-img3.tdimg.com
#会导致部分图片无显示（与广告挂钩），建议保留at-img1.tdimg.com，其余两条前打个“#”号去掉，最大化的去除广告和显示图片，具体算法自己选择吧。
#去迅雷看看广告
127.0.0.1       pubstat.sandai.net
127.0.0.1       mcfg.sandai.net
127.0.0.1       biz5.sandai.net
127.0.0.1       float.sandai.net
127.0.0.1       recommend.xunlei.com
127.0.0.1       cl.kankan.xunlei.com
#去56广告
127.0.0.1       acs.56.com
127.0.0.1       acs.agent.56.com
127.0.0.1       acs.agent.v-56.com
127.0.0.1       bill.agent.56.com
127.0.0.1       union.56.com
127.0.0.1       v16.56.com
#去搜狐高清广告
127.0.0.1       images.sohu.com
#去新浪视频广告
127.0.0.1       dcads.sina.com.cn
#去酷6广告
127.0.0.1       1.allyes.com.cn
127.0.0.1       analytics.ku6.com
127.0.0.1       stat0.888.ku6.com
127.0.0.1       stat1.888.ku6.com
127.0.0.1       stat2.888.ku6.com
127.0.0.1       stat3.888.ku6.com
127.0.0.1       ku6afp.allyes.com
#去凤凰网广告(不包括直播部分)
127.0.0.1       img.ifeng.com
#去pptv.com广告
127.0.0.1       pp2.pptv.com
#去cntv广告
127.0.0.1       d.cntv.cn
#去乐视广告
127.0.0.1       pro.letv.com
#去奇艺广告
127.0.0.1       afp.qiyi.com
127.0.0.1       focusbaiduafp.allyes.com
#去6间房广告(还有一点点残留)
127.0.0.1       simba.6.cn
127.0.0.1       pole.6rooms.com
127.0.0.1       shrek.6.cn
127.0.0.1       union.6.cn
#去激动网广告
127.0.0.1       86file.megajoy.com
127.0.0.1       86get.joy.cn
127.0.0.1       86log.joy.cn

#dropbox
208.43.202.50 www.dropbox.com
174.129.11.212 dl.dropbox.com
184.73.163.57 dl-web.dropbox.com

127.0.0.1   localhost Hasee
127.0.1.1   Hasee

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters


127.0.0.1 atm.youku.com

127.0.0.1 Fvid.atm.youku.com

127.0.0.1 html.atm.youku.com

127.0.0.1 valb.atm.youku.com

127.0.0.1 valf.atm.youku.com

127.0.0.1 valo.atm.youku.com

127.0.0.1 valp.atm.youku.com

127.0.0.1 lstat.youku.com

127.0.0.1 speed.lstat.youku.com

127.0.0.1 urchin.lstat.youku.com

127.0.0.1 stat.youku.com

127.0.0.1 static.lstat.youku.com

127.0.0.1 valc.atm.youku.com

127.0.0.1 vid.atm.youku.com

127.0.0.1 walp.atm.youku.com


127.0.0.1 valf.atm.youku.com
127.0.0.1 valb.atm.youku.com
127.0.0.1 vid.atm.youku.com

##Google.com       Google.com
2404:6800:8005::68 www.google.com                     #主页
#2404:6800:8005::68 www.l.google.com
2404:6800:8005::c1 m.google.com                       #Google移动版
2404:6800:8005::54 accounts.google.com                #帐户
2404:6800:8005::62 id.google.com                      #帐号登录
#2404:6800:8005::62 id.l.google.com                    #
2404:6800:8005::62 gg.google.com                      #
#2404:6800:8005::62 csi.l.google.com
2404:6800:8005::62 safebrowsing.clients.google.com    #安全浏览客户端服务器
#2404:6800:8005::62 clients.l.google.com
2404:6800:8005::62 ns1.google.com                     #域名系统服务器ns-soa/ns
2404:6800:8005::62 ns2.google.com                     #域名系统服务器ns
2404:6800:8005::62 ns3.google.com                     #域名系统服务器ns
2404:6800:8005::62 ns4.google.com                     #域名系统服务器ns
2404:6800:8005::65 services.google.com                #服务申请
#2404:6800:8005::65 www3.l.google.com
2404:6800:8005::76 feedproxy.google.com               #Feed代理
#2404:6800:8005::76 www4.l.google.com
2404:6800:8005::d2 jmt0.google.com                    #未知
2404:6800:8005::62 googlemashups.l.google.com         #位置
##Google.com.hk    谷歌香港
2404:6800:8005::2e www.google.com.hk
2404:6800:8005::2e images.google.com.hk
2404:6800:8005::2e video.google.com.hk
2404:6800:8005::2e maps.google.com.hk
2404:6800:8005::2e news.google.com.hk
2404:6800:8005::2e translate.google.com.hk
2404:6800:8005::2e blogsearch.google.com.hk
2404:6800:8005::2e picasaweb.google.com.hk
2404:6800:8005::2e toolbar.google.com.hk
2404:6800:8005::2e desktop.google.com.hk
2404:6800:8005::2e id.google.com.hk
##Google.cn        谷歌中国（启用此地址无法正常使用谷歌音乐）
#2401:3800:c001::2c www.google.cn                      #主页
#2401:3800:c001::2c g.cn                               #主页
#2401:3800:c001::2c google.cn                          #主页
#2401:3800:c001::2c ipv6cn.l.google.com 
#IPv6：ipv6.google.cn
2401:3800:c001::84 music.googleusercontent.cn
##Google.com.tw    Google台湾
2404:6800:8005::2f www.google.com.tw                  #主页
2404:6800:8005::2f picasaweb.google.com.tw            #picasaweb
##Google.co.jp     Google日本
2a00:1450:8006::30 www.google.co.jp
#IPv6：ipv6.google.co.jp
##
2404:6800:8005::20 www.google.com.tr 土耳其
2404:6800:8005::21 www.google.com.au 澳大利亚
2404:6800:8005::22 www.google.com.vn 越南
2404:6800:8005::23 www.google.com.pk 巴基斯坦
2404:6800:8005::24 www.google.com.my 马来西亚
2404:6800:8005::25 www.google.com.pe
2404:6800:8005::26 www.google.co.za
2404:6800:8005::27 www.google.co.ve
2404:6800:8005::28 www.google.com.ph
2404:6800:8005::29 www.google.com.ar
2404:6800:8005::2a www.google.co.nz
2404:6800:8005::2b www.google.lt
#2404:6800:8005::2c www.google.cn     中国（已死）
2404:6800:8005::2d www.google.com.sg
2404:6800:8005::2e www.google.com.hk 香港
2404:6800:8005::2f www.google.com.tw 台湾
2404:6800:8005::30 www.google.co.jp  日本
2404:6800:8005::31 www.google.ae
2404:6800:8005::32 www.google.co.uk  英国
2404:6800:8005::33 www.google.com.gr
2404:6800:8005::34 www.google.de 
2404:6800:8005::35 www.google.co.il
2404:6800:8005::36 www.google.fr     法国

2404:6800:8005::38 www.google.it
2404:6800:8005::39 www.google.lv
2404:6800:8005::3a www.google.ca
2404:6800:8005::3b www.google.pl
2404:6800:8005::3c www.google.ch
2404:6800:8005::3d www.google.ro
2404:6800:8005::3e www.google.nl
2404:6800:8005::3f www.google.com.ru
2404:6800:8005::40 www.google.at     奥地利

2404:6800:8005::42 www.google.be

2404:6800:8005::44 www.google.co.kr
2404:6800:8005::45 www.google.com.ua

2404:6800:8005::48 www.google.fi     芬兰
2404:6800:8005::49 www.google.co.in
2404:6800:8005::4a www.google.pt
2404:6800:8005::4b www.google.com.ly
2404:6800:8005::4c www.google.com.br

#Web               网页
2404:6800:8005::68 www.google.com                     #主页
2404:6800:8005::68 www.l.google.com
2404:6800:8005::62 www0.l.google.com
2404:6800:8005::62 www1.l.google.com
2404:6800:8005::62 www3.l.google.com
2404:6800:8005::62 suggestqueries.google.com          #搜索建议
2404:6800:8005::62 suggestqueries.l.google.com        #搜索建议
2404:6800:8005::62 clients0.google.com                #客户端服务器
2404:6800:8005::62 clients1.google.com                #客户端服务器
2404:6800:8005::62 clients2.google.com                #客户端服务器
2404:6800:8005::62 clients3.google.com                #客户端服务器
2404:6800:8005::62 clients4.google.com                #客户端服务器

#Images            图片
2404:6800:8005::68 images.google.com                  #主页
2404:6800:8005::68 images.l.google.com                #
2404:6800:8005::62 tbn0.google.com
2404:6800:8005::62 tbn1.google.com
2404:6800:8005::62 tbn2.google.com
2404:6800:8005::62 tbn3.google.com
2404:6800:8005::62 tbn4.google.com
2404:6800:8005::62 tbn5.google.com
2404:6800:8005::62 tbn6.google.com

#Video             视频
2404:6800:8005::62 video.google.com                   #主页
#2404:6800:8005::62 video.l.google.com
2404:6800:8005::62 0.gvt0.com
2404:6800:8005::62 1.gvt0.com
2404:6800:8005::62 2.gvt0.com
2404:6800:8005::62 3.gvt0.com
2404:6800:8005::62 4.gvt0.com
2404:6800:8005::62 5.gvt0.com
2404:6800:8005::62 video-stats.video.google.com
2404:6800:8005::74 upload.video.google.com
2404:6800:8005::74 sslvideo-upload.l.google.com
2404:6800:8005::62 vp.video.google.com 
2404:6800:8005::62 vp.video.l.google.com 
2404:6800:8005::62 qwqy.vp.video.l.google.com
2404:6800:8005::62 nz.vp.video.l.google.com
2404:6800:8005::62 nztdug.vp.video.l.google.com
2404:6800:8005::62 pr.vp.video.l.google.com
2404:6800:8005::62 ug.vp.video.l.google.com
2404:6800:8005::62 vp01.video.l.google.com
2404:6800:8005::62 vp02.video.l.google.com
2404:6800:8005::62 vp03.video.l.google.com
2404:6800:8005::62 vp04.video.l.google.com
2404:6800:8005::62 vp05.video.l.google.com
2404:6800:8005::62 vp06.video.l.google.com
2404:6800:8005::62 vp07.video.l.google.com
2404:6800:8005::62 vp08.video.l.google.com
2404:6800:8005::62 vp09.video.l.google.com
2404:6800:8005::62 vp10.video.l.google.com
2404:6800:8005::62 vp11.video.l.google.com
2404:6800:8005::62 vp12.video.l.google.com
2404:6800:8005::62 vp13.video.l.google.com
2404:6800:8005::62 vp14.video.l.google.com
2404:6800:8005::62 vp15.video.l.google.com
2404:6800:8005::62 vp16.video.l.google.com
2404:6800:8005::62 vp17.video.l.google.com
2404:6800:8005::62 vp18.video.l.google.com
2404:6800:8005::62 vp19.video.l.google.com
2404:6800:8005::62 vp20.video.l.google.com

#Map               地图
2404:6800:8005::68 maps.google.com                    #主页
2404:6800:8005::68 maps.l.google.com
2404:6800:8005::62 maps-api-ssl.google.com
#2404:6800:8005::62 clients.l.google.com
2404:6800:8005::62 map.google.com
2404:6800:8005::62 kh.google.com
2404:6800:8005::62 kh.l.google.com
2404:6800:8005::62 khmdb.google.com
2404:6800:8005::62 khm.google.com                     #
2404:6800:8005::62 khm.l.google.com
2404:6800:8005::62 khm0.google.com                    #Satellite View
2404:6800:8005::62 khm1.google.com                    #Satellite View
2404:6800:8005::62 khm2.google.com                    #Satellite View
2404:6800:8005::62 khm3.google.com                    #Satellite View
2404:6800:8005::62 cbk0.google.com                    #Street View
2404:6800:8005::62 cbk1.google.com                    #Street View
2404:6800:8005::62 cbk2.google.com                    #Street View
2404:6800:8005::62 cbk3.google.com                    #Street View
2404:6800:8005::62 mw0.google.com
2404:6800:8005::62 mw1.google.com
2404:6800:8005::62 mw2.google.com
2404:6800:8005::62 mw3.google.com
2404:6800:8005::62 mw-small.l.google.com
2404:6800:8005::62 mt.l.google.com
2404:6800:8005::62 mt0.google.com
2404:6800:8005::62 mt1.google.com
2404:6800:8005::62 mt2.google.com
2404:6800:8005::62 mt3.google.com
2404:6800:8005::62 mlt0.google.com
2404:6800:8005::62 mlt1.google.com
2404:6800:8005::62 mlt2.google.com
2404:6800:8005::62 mlt3.google.com

#News              资讯
2404:6800:8005::68 news.google.com                    #主页
2404:6800:8005::68 news.l.google.com                  
2404:6800:8005::62 nt0.ggpht.com
2404:6800:8005::62 nt1.ggpht.com
2404:6800:8005::62 nt2.ggpht.com
2404:6800:8005::62 nt3.ggpht.com
2404:6800:8005::62 nt4.ggpht.com
2404:6800:8005::62 nt5.ggpht.com

#Gmail             邮箱
2404:6800:8005::11 mail.google.com                    #主页
2404:6800:8005::53 googlemail.l.google.com
2404:6800:8005::11 googlemail.l.google.com
2404:6800:8005::12 googlemail.l.google.com
2404:6800:8005::13 googlemail.l.google.com
2404:6800:8005::bd chatenabled.mail.google.com        #Gmail中Gtalk聊天服务
#2404:6800:8005::bd b.googlemail.l.google.com
2404:6800:8005::62 talk.gmail.com                     #Gmail中Gtalk聊天服务
2404:6800:8005::62 gmail.google.com                   #
2404:6800:8005::62 gmail.l.google.com                 #
2404:6800:8005::62 www.gmail.com                      #Gmail主页
2404:6800:8005::62 gmail.com                          #Gmail主页
2404:6800:8005::62 pop.gmail.com                      #pop服务
2404:6800:8005::62 smtp.gmail.com                     #smtp服务
2404:6800:8005::62 smtp1.google.com 
2404:6800:8005::62 smtp2.google.com 
2404:6800:8005::62 smtp3.google.com 
2404:6800:8005::62 smtp4.google.com 
2404:6800:8005::62 smtp5.google.com 
2404:6800:8005::62 smtp-out.google.com
2404:6800:8005::62 smtp-out2.google.com
2404:6800:8005::62 smtp-out3.google.com
2404:6800:8005::62 imap.google.com                    #
2404:6800:8005::62 gmail-pop.l.google.com 
2404:6800:8005::62 gmail-smtp.l.google.com 
2404:6800:8005::62 gmail-smtp-in.l.google.com 
2404:6800:8005::62 gmr-smtp-in.l.google.com

#Books             图书
2404:6800:8005::62 books.google.com                   #主页
#2404:6800:8005::64 www3.l.google.com
2404:6800:8005::62 bks0.books.google.com
2404:6800:8005::62 bks1.books.google.com
2404:6800:8005::62 bks2.books.google.com
2404:6800:8005::62 bks3.books.google.com
2404:6800:8005::62 bks4.books.google.com
2404:6800:8005::62 bks5.books.google.com
2404:6800:8005::62 bks6.books.google.com
2404:6800:8005::62 bks7.books.google.com
2404:6800:8005::62 bks8.books.google.com
2404:6800:8005::62 bks9.books.google.com

#Finance           财经
2404:6800:8005::62 finance.google.com

#Translate         翻译
2404:6800:8005::62 translate.google.com

#Blog              博客搜索
2404:6800:8005::63 blogsearch.google.com
#2404:6800:8005::63 www2.l.google.com

#Calendar          日历
2404:6800:8005::64 calendar.google.com
#2404:6800:8005::64 www3.l.google.com

#Photo/Picasa      照片/网络相册
2404:6800:8005::5d photos.google.com
#2404:6800:8005::5d picasaweb.l.google.com
2404:6800:8005::63 picasa.google.com
#2404:6800:8005::63 www2.l.google.com
2404:6800:8005::be picasaweb.google.com
#2404:6800:8005::be picasaweb.l.google.com
2404:6800:8005::62 lh0.ggpht.com
2404:6800:8005::62 lh1.ggpht.com
2404:6800:8005::62 lh2.ggpht.com
2404:6800:8005::62 lh3.ggpht.com
2404:6800:8005::62 lh4.ggpht.com
2404:6800:8005::62 lh5.ggpht.com
2404:6800:8005::62 lh6.ggpht.com
2404:6800:8005::62 lh7.ggpht.com
2404:6800:8005::62 lh8.ggpht.com
2404:6800:8005::62 lh9.ggpht.com

#Docs              文档
2404:6800:8005::64 docs.google.com
2404:6800:8005::64 writely.l.google.com
2404:6800:8005::62 spreadsheet.google.com
2404:6800:8005::62 spreadsheets.google.com
2404:6800:8005::62 spreadsheets0.google.com
2404:6800:8005::62 spreadsheets.l.google.com
2404:6800:8005::62 writely.google.com
2404:6800:8005::62 writely.l.google.com
2404:6800:8005::62 writely-com.l.google.com
2404:6800:8005::62 writely-china.l.google.com

#Reader            阅读器
2404:6800:8005::68 reader.google.com
2404:6800:8005::68 www2.l.google.com

#Sites             协作平台
2404:6800:8005::65 sites.google.com
#2404:6800:8005::65 www3.l.google.com
#2404:6800:8005::62 ghs.google.com
#2404:6800:8005::62 ghs.l.google.com

#Group             论坛
2404:6800:8005::62 groups.google.com
2404:6800:8005::62 groups.l.google.com
2404:6800:8005::89 *.googlegroups.com
2404:6800:8005::89 blob-s-docs.googlegroups.com
2404:6800:8005::89 2503061233288453901-a-1802744773732722657-s-sites.googlegroups.com

#Scholar           学术搜索
2404:6800:8005::62 scholar.google.com
2404:6800:8005::62 scholar.l.google.com

#Tools             工具
2404:6800:8005::62 tools.google.com
2404:6800:8005::62 tools.l.google.com

#Code              代码
2404:6800:8005::64 code.google.com                    #主页
2404:6800:8005::64 code.l.google.com                  #
2404:6800:8005::52 *.googlecode.com                   #
2404:6800:8005::52 chromium.googlecode.com            #
2404:6800:8005::52 searchforchrome.googlecode.com     #
2404:6800:8005::52 android-scripting.googlecode.com   #Android Scripting Environment
2404:6800:8005::52 earth-api-samples.googlecode.com   #
2404:6800:8005::52 gmaps-samples-flash.googlecode.com #
2404:6800:8005::52 google-code-feed-gadget.googlecode.com
2404:6800:8005::52 china-addthis.googlecode.com       #
2404:6800:8005::52 get-flash-videos.googlecode.com    #get-flash-videos
2404:6800:8005::52 youplayer.googlecode.com           #YouPlayer
2404:6800:8005::52 cclive.googlecode.com              #ccLive

#Labs              实验室
2404:6800:8005::65 labs.google.com
#2404:6800:8005::65 www3.l.google.com
2404:6800:8005::62 www.googlelabs.com
2404:6800:8005::62 browsersize.googlelabs.com         #Browser Size
2404:6800:8005::62 storegadget.googlelabs.com         #Google Checkout Store Gadget
2404:6800:8005::62 citytours.googlelabs.com           #City Tours
2404:6800:8005::62 livingstories.googlelabs.com       #Living Stories
2404:6800:8005::62 image-swirl.googlelabs.com         #Image Swirl
2404:6800:8005::62 scriptconv.googlelabs.com          #Script Converter
2404:6800:8005::62 relatedlinks.googlelabs.com        #Related Links
2404:6800:8005::62 fastflip.googlelabs.com            #Fast Flip
2404:6800:8005::62 listen.googlelabs.com              #Google Listen
2404:6800:8005::62 similar-images.googlelabs.com      #Similar Images
2404:6800:8005::62 tables.googlelabs.com              #Fusion Tables
2404:6800:8005::62 newstimeline.googlelabs.com        #Google News Timeline

#Knol              在线百科全书
2404:6800:8005::65 knol.google.com
#2404:6800:8005::65 www3.l.google.com

#SketchUp          3D建模工具
2404:6800:8005::62 sketchup.google.com
#2404:6800:8005::62 sketchup.l.google.com

#Pack              软件精选
2404:6800:8005::68 pack.google.com
#2404:6800:8005::68 www2.l.google.com
2404:6800:8005::68 cache.pack.google.com

#Blogger           博客服务
2404:6800:8005::bf www.blogger.com
2404:6800:8005::bf buttons.blogger.com
2404:6800:8005::bf beta.blogger.com
2404:6800:8005::bf draft.blogger.com                  #Blogger 测试区
2404:6800:8005::bf status.blogger.com                 #Blogger 状态
2404:6800:8005::bf help.blogger.com                   #支持中心
2404:6800:8005::bf buzz.blogger.com                   #Blogger Buzz博客（英文）
2404:6800:8005::bf photos1.blogger.com
2404:6800:8005::bf bp0.blogger.com
2404:6800:8005::62 blogger.google.com
2404:6800:8005::62 blogger.l.google.com
2404:6800:8005::62 www.blogblog.com
2404:6800:8005::62 www1.blogblog.com
2404:6800:8005::62 www2.blogblog.com
2404:6800:8005::62 img.blogblog.com
2404:6800:8005::62 img1.blogblog.com
2404:6800:8005::62 img2.blogblog.com
2404:6800:8005::62 img.blshe.com


#Blogspot          博客服务
2404:6800:8005::62 www.blogspot.com                   #主页
#2404:6800:8005::62 blogger.l.google.com
2404:6800:8005::62 blogsofnote.blogspot.com           #留言博客（英文版本）
2404:6800:8005::62 knownissues.blogspot.com           #已知问题
2404:6800:8005::62 1.bp.blogspot.com                  #
2404:6800:8005::62 2.bp.blogspot.com                  #
2404:6800:8005::62 3.bp.blogspot.com                  #
2404:6800:8005::62 4.bp.blogspot.com                  #
2404:6800:8005::62 googleblog.blogspot.com            #Official Google Blog
2404:6800:8005::62 googlesystem.blogspot.com          #Google Operating System
2404:6800:8005::62 googlechromereleases.blogspot.com  #Google Chrome Releases
2404:6800:8005::62 youtube-global.blogspot.com        #YouTube Blog
2404:6800:8005::62 igoogledeveloper.blogspot.com      #iGoogle Developer Blog
2404:6800:8005::62 google-code-featured.blogspot.com  #Featured Projects on Google Code
2404:6800:8005::62 googlegeodevelopers.blogspot.com   #Google Geo Developers Blog
2404:6800:8005::62 googlecustomsearch.blogspot.com    #Google Custom Search Blog
2404:6800:8005::62 chinafreenet.blogspot.com          #中国自由网
2404:6800:8005::62 gregmankiw.blogspot.com            #GREG MANKIW&amp;#39;S BLOG
2404:6800:8005::62 xiangeliushui.blogspot.com         #年华似水，岁月如歌
2404:6800:8005::62 chinagfw.blogspot.com              #GFW Blog
2404:6800:8005::62 wallpapers-arena.blogspot.com      #Wallpapers Arena
2404:6800:8005::62 ggq.blogspot.com                   #GG圈
2404:6800:8005::62 whiteappleer.blogspot.com          #WA＋ER
2404:6800:8005::62 rain-reader.blogspot.com           #Nostalgia: Those Who Remain
2404:6800:8005::62 unityteam1.blogspot.com            #生活圈 BLOG
2404:6800:8005::62 ipv6-or-no-ipv6.blogspot.com       #IPv6 Related Stuff
2404:6800:8005::62 autoproxy2pac.appspot.com          #
2404:6800:8005::62 gysj.blogspot.com                  #
2404:6800:8005::62 szncu.blogspot.com                 #
#2404:6800:8005::62 *.blogspot.com                     #可以添加你自己的博客地址到这里

#Checkout          买家
2404:6800:8005::73 checkout.google.com
#2404:6800:8005::73 checkout.l.google.com

#Orkut             网络社区（貌似错误）
#2404:6800:8005::62 orkut.google.com
#2404:6800:8005::62 orkut.l.google.com
#2404:6800:8005::62 www.orkut.com
#2404:6800:8005::62 clients1.orkut.com

#Toolbar           工具栏
2404:6800:8005::62 toolbar.google.com
#2404:6800:8005::62 tools.l.google.com
2404:6800:8005::62 www.gmailnotifier.com              #Gmail Notifier

#App Engine
2404:6800:8005::64 appengine.google.com               #主页
#2404:6800:8005::64 www3.l.google.com
2404:6800:8005::62 appspot.l.google.com               #
2404:6800:8005::62 chart.apis.google.com              #Google 图表 API
2404:6800:8005::5f *.googleapis.com
2404:6800:8005::5f translate.googleapis.com           #Google 翻译 API
2404:6800:8005::5f ajax.googleapis.com                #Ajax API
2404:6800:8005::8d *.appspot.com
2404:6800:8005::8d productideas.appspot.com           #Google 汇问
2404:6800:8005::8d wave-api.appspot.com               #Google Wave API
2404:6800:8005::8d wave-skynet.appspot.com            #SkyNet
2404:6800:8005::8d cactus-wave.appspot.com            #
2404:6800:8005::8d storegadgetwizard.appspot.com      #Google Checkout Store Gadget
2404:6800:8005::8d moderator.appspot.com              #Google Moderator
2404:6800:8005::8d haiticrisis.appspot.com            #Google Person Finder: Haiti Earthquake
2404:6800:8005::8d mytracks.appspot.com               #My Tracks for Android
2404:6800:8005::8d reader2twitter.appspot.com         #Reader2Tweet
2404:6800:8005::8d twitese.appspot.com
2404:6800:8005::8d gfw.appspot.com
2404:6800:8005::8d go2china9.appspot.com
2404:6800:8005::8d mirrorrr.appspot.com
2404:6800:8005::8d mirrornt.appspot.com
2404:6800:8005::8d soproxy.appspot.com 
2404:6800:8005::8d so-proxy.appspot.com
2404:6800:8005::8d go-west.appspot.com
2404:6800:8005::8d proxytea.appspot.com 
2404:6800:8005::8d sivanproxy.appspot.com
2404:6800:8005::8d proxybay.appspot.com
2404:6800:8005::8d ipgoto.appspot.com
2404:6800:8005::8d meme2028.appspot.com 
2404:6800:8005::8d autoproxy2pac.appspot.com

#Chrome            谷歌浏览器
2404:6800:8005::64 chrome.google.com

#Chromium OS       
2404:6800:8005::62 goto.ext.google.com
#2404:6800:8005::62 ghs.l.google.com

#Desktop           桌面
2404:6800:8005::62 desktop.google.com
2404:6800:8005::62 desktop.l.google.com

#Google Earth      Google地球
2404:6800:8005::65 earth.google.com
#2404:6800:8005::65 www3.l.google.com

#Google Mars       Google火星地图
2404:6800:8005::65 mars.google.com
#2404:6800:8005::65 www3.l.google.com

#Panoramio
2001:4860:8010::8d www.panoramio.com
#2001:4860:8010::8d appspot.l.google.com
2001:4860:8010::8d static.panoramio.com

#Keyhole           地理查询软件
2404:6800:8005::62 www.keyhole.com
2404:6800:8005::62 geo.keyhole.com
2404:6800:8005::62 dev.keyhole.com
2404:6800:8005::62 auth.keyhole.com

#iGoogle Modules   Google小工具
2404:6800:8005::62 gmodules.com
2404:6800:8005::62 www.gmodules.com
2404:6800:8005::62 www.ig.gmodules.com
2404:6800:8005::62 ig.gmodules.com
2404:6800:8005::62 ads.gmodules.com
2404:6800:8005::62 p.gmodules.com
2404:6800:8005::62 1.ig.gmodules.com
2404:6800:8005::62 2.ig.gmodules.com
2404:6800:8005::62 3.ig.gmodules.com
2404:6800:8005::62 4.ig.gmodules.com
2404:6800:8005::62 5.ig.gmodules.com
2404:6800:8005::62 6.ig.gmodules.com
2404:6800:8005::62 maps.gmodules.com
2404:6800:8005::62 img0.gmodules.com
2404:6800:8005::62 img1.gmodules.com
2404:6800:8005::62 img2.gmodules.com
2404:6800:8005::62 img3.gmodules.com
2404:6800:8005::62 skins.gmodules.com
2404:6800:8005::62 friendconnect.gmodules.com
2404:6800:8005::62 mc8tdi0ripmbpds25eboaupdulritrp6.friendconnect.gmodules.com
2404:6800:8005::62 r1rk9np7bpcsfoeekl0khkd2juj27q3o.friendconnect.gmodules.com
2404:6800:8005::62 r1rk9np7bpcsfoeekl0khkd2juj27q3o.a.friendconnect.gmodules.com

##Google其他服务
#Ajax
2404:6800:8005::62 googleapis-ajax.google.com
#2404:6800:8005::62 googleapis-ajax.l.google.com

#YouTube
203.208.46.29   youtube.com
203.208.46.29   www.youtube.com
203.208.46.29   gdata.youtube.com
203.208.46.29   m.youtube.com
203.208.46.29   help.youtube.com
74.125.71.116   upload.youtube.com
203.208.46.29   accounts.youtube.com
203.208.46.29   insight.youtube.com
203.208.46.29   apiblog.youtube.com
203.208.46.29   clients1.youtube.com
203.208.46.29   s.youtube.com
203.208.46.29   s2.youtube.com
203.208.46.29   s.ytimg.com
203.208.46.29   i1.ytimg.com
203.208.46.29   i2.ytimg.com
203.208.46.29   i3.ytimg.com
203.208.46.29   i4.ytimg.com
203.208.46.29   o-o.preferred.sjc07s15.v1.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v2.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v3.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v4.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v5.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v6.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v7.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v8.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v9.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v10.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v11.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v12.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v13.lscache1.c.youtube.com
203.208.46.29   dn.net
125.56.199.9 photos-d.ak.fbcdn.net
125.56.199.9 photos-e.ak.fbcdn.net
125.56.199.9 photos-f.ak.fbcdn.net
125.56.199.9 photos-g.ak.fbcdn.net
125.56.199.9 photos-h.ak.fbcdn.neto-o.preferred.sjc07s15.v14.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v15.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v16.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v17.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v18.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v19.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v20.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v21.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v22.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v23.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v24.lscache1.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v1.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v2.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v3.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v4.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v5.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v6.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v7.lscache2.c.youtube.com
203.208.46.29   dn.net
125.56.199.9 photos-d.ak.fbcdn.net
125.56.199.9 photos-e.ak.fbcdn.net
125.56.199.9 photos-f.ak.fbcdn.net
125.56.199.9 photos-g.ak.fbcdn.net
125.56.199.9 photos-h.ak.fbcdn.neto-o.preferred.sjc07s15.v8.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v9.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v10.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v11.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v12.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v13.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v14.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v15.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v16.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v17.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v18.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v19.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v20.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v21.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v22.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v23.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v24.lscache2.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v1.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v2.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v3.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v4.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v5.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v6.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v7.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v8.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v9.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v10.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v11.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v12.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v13.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v14.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v15.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v16.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v17.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v18.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v19.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v20.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v21.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v22.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v23.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v24.lscache3.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v1.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v2.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v3.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v4.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v5.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v6.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v7.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v8.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v9.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v10.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v11.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v12.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v13.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v14.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v15.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v16.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v17.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v18.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v19.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v20.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v21.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v22.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v23.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v24.lscache4.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v1.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v2.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v3.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v4.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v5.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v6.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v7.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v8.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v9.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v10.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v11.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v12.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v13.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v14.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v15.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v16.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v17.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v18.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v19.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v20.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v21.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v22.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v23.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v24.lscache5.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v1.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v2.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v3.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v4.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v5.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v6.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v7.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v8.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v9.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v10.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v11.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v12.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v13.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v14.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v15.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v16.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v17.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v18.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v19.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v20.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v21.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v22.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v23.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v24.lscache6.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v1.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v2.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v3.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v4.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v5.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v6.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v7.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v8.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v9.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v10.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v11.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v12.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v13.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v14.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v15.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v16.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v17.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v18.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v19.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v20.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v21.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v22.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v23.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v24.lscache7.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v1.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v2.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v3.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v4.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v5.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v6.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v7.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v8.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v9.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v10.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v11.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v12.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v13.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v14.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v15.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v16.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v17.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v18.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v19.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v20.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v21.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v22.lscache8.c.youtube.com
203.208.46.29   o-o.preferred.sjc07s15.v23.lscache8.c.youtube.com
203.208.46.29   dn.net
125.56.199.9 photos-d.ak.fbcdn.net
125.56.199.9 photos-e.ak.fbcdn.net
125.56.199.9 photos-f.ak.fbcdn.net
125.56.199.9 photos-g.ak.fbcdn.net
125.56.199.9 photos-h.ak.fbcdn.neto-o.preferred.sjc07s15.v24.lscache8.c.youtube.com
203.208.46.29   r1.pek01s01.c.youtube.com
203.208.46.29   r2.pek01s01.c.youtube.com
203.208.46.29   r3.pek01s01.c.youtube.com
203.208.46.29   r4.pek01s01.c.youtube.com
203.208.46.29   r5.pek01s01.c.youtube.com
203.208.46.29   r6.pek01s01.c.youtube.com
203.208.46.29   r7.pek01s01.c.youtube.com
203.208.46.29   r8.pek01s01.c.youtube.com
203.208.46.29   r9.pek01s01.c.youtube.com
203.208.46.29   r10.pek01s01.c.youtube.com
203.208.46.29   r11.pek01s01.c.youtube.com
203.208.46.29   r12.pek01s01.c.youtube.com
203.208.46.29   r13.pek01s01.c.youtube.com
203.208.46.29   r14.pek01s01.c.youtube.com
203.208.46.29   r15.pek01s01.c.youtube.com
203.208.46.29   r16.pek01s01.c.youtube.com
203.208.46.29   r17.pek01s01.c.youtube.com
203.208.46.29   r18.pek01s01.c.youtube.com
203.208.46.29   r19.pek01s01.c.youtube.com
203.208.46.29   r20.pek01s01.c.youtube.com
203.208.46.29   r21.pek01s01.c.youtube.com
203.208.46.29   r22.pek01s01.c.youtube.com
203.208.46.29   r23.pek01s01.c.youtube.com
203.208.46.29   r24.pek01s01.c.youtube.com
203.208.46.29   tc.v1.cache1.c.youtube.com
203.208.46.29   tc.v2.cache1.c.youtube.com
203.208.46.29   tc.v3.cache1.c.youtube.com
203.208.46.29   tc.v4.cache1.c.youtube.com
203.208.46.29   tc.v5.cache1.c.youtube.com
203.208.46.29   tc.v6.cache1.c.youtube.com
203.208.46.29   tc.v7.cache1.c.youtube.com
203.208.46.29   tc.v8.cache1.c.youtube.com
203.208.46.29   tc.v9.cache1.c.youtube.com
203.208.46.29   tc.v10.cache1.c.youtube.com
203.208.46.29   tc.v11.cache1.c.youtube.com
203.208.46.29   tc.v12.cache1.c.youtube.com
203.208.46.29   tc.v13.cache1.c.youtube.com
203.208.46.29   tc.v14.cache1.c.youtube.com
203.208.46.29   tc.v15.cache1.c.youtube.com
203.208.46.29   tc.v16.cache1.c.youtube.com
203.208.46.29   tc.v17.cache1.c.youtube.com
203.208.46.29   tc.v18.cache1.c.youtube.com
203.208.46.29   tc.v19.cache1.c.youtube.com
203.208.46.29   tc.v20.cache1.c.youtube.com
203.208.46.29   tc.v21.cache1.c.youtube.com
203.208.46.29   tc.v22.cache1.c.youtube.com
203.208.46.29   tc.v23.cache1.c.youtube.com
203.208.46.29   tc.v24.cache1.c.youtube.com
203.208.46.29   tc.v1.cache2.c.youtube.com
203.208.46.29   tc.v2.cache2.c.youtube.com
203.208.46.29   tc.v3.cache2.c.youtube.com
203.208.46.29   tc.v4.cache2.c.youtube.com
203.208.46.29   tc.v5.cache2.c.youtube.com
203.208.46.29   tc.v6.cache2.c.youtube.com
203.208.46.29   tc.v7.cache2.c.youtube.com
203.208.46.29   tc.v8.cache2.c.youtube.com
203.208.46.29   tc.v9.cache2.c.youtube.com
203.208.46.29   tc.v10.cache2.c.youtube.com
203.208.46.29   tc.v11.cache2.c.youtube.com
203.208.46.29   tc.v12.cache2.c.youtube.com
203.208.46.29   tc.v13.cache2.c.youtube.com
203.208.46.29   tc.v14.cache2.c.youtube.com
203.208.46.29   tc.v15.cache2.c.youtube.com
203.208.46.29   tc.v16.cache2.c.youtube.com
203.208.46.29   tc.v17.cache2.c.youtube.com
203.208.46.29   tc.v18.cache2.c.youtube.com
203.208.46.29   tc.v19.cache2.c.youtube.com
203.208.46.29   tc.v20.cache2.c.youtube.com
203.208.46.29   tc.v21.cache2.c.youtube.com
203.208.46.29   tc.v22.cache2.c.youtube.com
203.208.46.29   tc.v23.cache2.c.youtube.com
203.208.46.29   tc.v24.cache2.c.youtube.com
203.208.46.29   tc.v1.cache3.c.youtube.com
203.208.46.29   tc.v2.cache3.c.youtube.com
203.208.46.29   tc.v3.cache3.c.youtube.com
203.208.46.29   tc.v4.cache3.c.youtube.com
203.208.46.29   tc.v5.cache3.c.youtube.com
203.208.46.29   tc.v6.cache3.c.youtube.com
203.208.46.29   tc.v7.cache3.c.youtube.com
203.208.46.29   tc.v8.cache3.c.youtube.com
203.208.46.29   tc.v9.cache3.c.youtube.com
203.208.46.29   tc.v10.cache3.c.youtube.com
203.208.46.29   tc.v11.cache3.c.youtube.com
203.208.46.29   tc.v12.cache3.c.youtube.com
203.208.46.29   tc.v13.cache3.c.youtube.com
203.208.46.29   tc.v14.cache3.c.youtube.com
203.208.46.29   tc.v15.cache3.c.youtube.com
203.208.46.29   tc.v16.cache3.c.youtube.com
203.208.46.29   tc.v17.cache3.c.youtube.com
203.208.46.29   tc.v18.cache3.c.youtube.com
203.208.46.29   tc.v19.cache3.c.youtube.com
203.208.46.29   tc.v20.cache3.c.youtube.com
203.208.46.29   tc.v21.cache3.c.youtube.com
203.208.46.29   tc.v22.cache3.c.youtube.com
203.208.46.29   tc.v23.cache3.c.youtube.com
203.208.46.29   tc.v24.cache3.c.youtube.com
203.208.46.29   tc.v1.cache4.c.youtube.com
203.208.46.29   tc.v2.cache4.c.youtube.com
203.208.46.29   tc.v3.cache4.c.youtube.com
203.208.46.29   tc.v4.cache4.c.youtube.com
203.208.46.29   tc.v5.cache4.c.youtube.com
203.208.46.29   tc.v6.cache4.c.youtube.com
203.208.46.29   tc.v7.cache4.c.youtube.com
203.208.46.29   tc.v8.cache4.c.youtube.com
203.208.46.29   tc.v9.cache4.c.youtube.com
203.208.46.29   tc.v10.cache4.c.youtube.com
203.208.46.29   tc.v11.cache4.c.youtube.com
203.208.46.29   tc.v12.cache4.c.youtube.com
203.208.46.29   tc.v13.cache4.c.youtube.com
203.208.46.29   tc.v14.cache4.c.youtube.com
203.208.46.29   tc.v15.cache4.c.youtube.com
203.208.46.29   tc.v16.cache4.c.youtube.com
203.208.46.29   tc.v17.cache4.c.youtube.com
203.208.46.29   tc.v18.cache4.c.youtube.com
203.208.46.29   tc.v19.cache4.c.youtube.com
203.208.46.29   tc.v20.cache4.c.youtube.com
203.208.46.29   tc.v21.cache4.c.youtube.com
203.208.46.29   tc.v22.cache4.c.youtube.com
203.208.46.29   tc.v23.cache4.c.youtube.com
203.208.46.29   tc.v24.cache4.c.youtube.com
203.208.46.29   tc.v1.cache5.c.youtube.com
203.208.46.29   tc.v2.cache5.c.youtube.com
203.208.46.29   tc.v3.cache5.c.youtube.com
203.208.46.29   tc.v4.cache5.c.youtube.com
203.208.46.29   tc.v5.cache5.c.youtube.com
203.208.46.29   tc.v6.cache5.c.youtube.com
203.208.46.29   tc.v7.cache5.c.youtube.com
203.208.46.29   tc.v8.cache5.c.youtube.com
203.208.46.29   tc.v9.cache5.c.youtube.com
203.208.46.29   tc.v10.cache5.c.youtube.com
203.208.46.29   tc.v11.cache5.c.youtube.com
203.208.46.29   tc.v12.cache5.c.youtube.com
203.208.46.29   tc.v13.cache5.c.youtube.com
203.208.46.29   tc.v14.cache5.c.youtube.com
203.208.46.29   tc.v15.cache5.c.youtube.com
203.208.46.29   tc.v16.cache5.c.youtube.com
203.208.46.29   tc.v17.cache5.c.youtube.com
203.208.46.29   tc.v18.cache5.c.youtube.com
203.208.46.29   tc.v19.cache5.c.youtube.com
203.208.46.29   tc.v20.cache5.c.youtube.com
203.208.46.29   tc.v21.cache5.c.youtube.com
203.208.46.29   tc.v22.cache5.c.youtube.com
203.208.46.29   tc.v23.cache5.c.youtube.com
203.208.46.29   tc.v24.cache5.c.youtube.com
203.208.46.29   tc.v1.cache6.c.youtube.com
203.208.46.29   tc.v2.cache6.c.youtube.com
203.208.46.29   tc.v3.cache6.c.youtube.com
203.208.46.29   tc.v4.cache6.c.youtube.com
203.208.46.29   tc.v5.cache6.c.youtube.com
203.208.46.29   tc.v6.cache6.c.youtube.com
203.208.46.29   tc.v7.cache6.c.youtube.com
203.208.46.29   tc.v8.cache6.c.youtube.com
203.208.46.29   tc.v9.cache6.c.youtube.com
203.208.46.29   tc.v10.cache6.c.youtube.com
203.208.46.29   tc.v11.cache6.c.youtube.com
203.208.46.29   tc.v12.cache6.c.youtube.com
203.208.46.29   tc.v13.cache6.c.youtube.com
203.208.46.29   tc.v14.cache6.c.youtube.com
203.208.46.29   tc.v15.cache6.c.youtube.com
203.208.46.29   tc.v16.cache6.c.youtube.com
203.208.46.29   tc.v17.cache6.c.youtube.com
203.208.46.29   tc.v18.cache6.c.youtube.com
203.208.46.29   tc.v19.cache6.c.youtube.com
203.208.46.29   tc.v20.cache6.c.youtube.com
203.208.46.29   tc.v21.cache6.c.youtube.com
203.208.46.29   tc.v22.cache6.c.youtube.com
203.208.46.29   tc.v23.cache6.c.youtube.com
203.208.46.29   tc.v24.cache6.c.youtube.com
203.208.46.29   tc.v1.cache7.c.youtube.com
203.208.46.29   tc.v2.cache7.c.youtube.com
203.208.46.29   tc.v3.cache7.c.youtube.com
203.208.46.29   tc.v4.cache7.c.youtube.com
203.208.46.29   tc.v5.cache7.c.youtube.com
203.208.46.29   tc.v6.cache7.c.youtube.com
203.208.46.29   tc.v7.cache7.c.youtube.com
203.208.46.29   tc.v8.cache7.c.youtube.com
203.208.46.29   tc.v9.cache7.c.youtube.com
203.208.46.29   tc.v10.cache7.c.youtube.com
203.208.46.29   tc.v11.cache7.c.youtube.com
203.208.46.29   tc.v12.cache7.c.youtube.com
203.208.46.29   tc.v13.cache7.c.youtube.com
203.208.46.29   tc.v14.cache7.c.youtube.com
203.208.46.29   tc.v15.cache7.c.youtube.com
203.208.46.29   tc.v16.cache7.c.youtube.com
203.208.46.29   tc.v17.cache7.c.youtube.com
203.208.46.29   tc.v18.cache7.c.youtube.com
203.208.46.29   tc.v19.cache7.c.youtube.com
203.208.46.29   tc.v20.cache7.c.youtube.com
203.208.46.29   tc.v21.cache7.c.youtube.com
203.208.46.29   tc.v22.cache7.c.youtube.com
203.208.46.29   tc.v23.cache7.c.youtube.com
203.208.46.29   tc.v24.cache7.c.youtube.com
203.208.46.29   tc.v1.cache8.c.youtube.com
203.208.46.29   tc.v2.cache8.c.youtube.com
203.208.46.29   tc.v3.cache8.c.youtube.com
203.208.46.29   tc.v4.cache8.c.youtube.com
203.208.46.29   tc.v5.cache8.c.youtube.com
203.208.46.29   tc.v6.cache8.c.youtube.com
203.208.46.29   tc.v7.cache8.c.youtube.com
203.208.46.29   tc.v8.cache8.c.youtube.com
203.208.46.29   tc.v9.cache8.c.youtube.com
203.208.46.29   tc.v10.cache8.c.youtube.com
203.208.46.29   tc.v11.cache8.c.youtube.com
203.208.46.29   tc.v12.cache8.c.youtube.com
203.208.46.29   tc.v13.cache8.c.youtube.com
203.208.46.29   tc.v14.cache8.c.youtube.com
203.208.46.29   tc.v15.cache8.c.youtube.com
203.208.46.29   tc.v16.cache8.c.youtube.com
203.208.46.29   tc.v17.cache8.c.youtube.com
203.208.46.29   tc.v18.cache8.c.youtube.com
203.208.46.29   tc.v19.cache8.c.youtube.com
203.208.46.29   tc.v20.cache8.c.youtube.com
203.208.46.29   tc.v21.cache8.c.youtube.com
203.208.46.29   tc.v22.cache8.c.youtube.com
203.208.46.29   tc.v23.cache8.c.youtube.com
203.208.46.29   tc.v24.cache8.c.youtube.com
203.208.46.29   v1.lscache1.c.youtube.com
203.208.46.29   v2.lscache1.c.youtube.com
203.208.46.29   v3.lscache1.c.youtube.com
203.208.46.29   v4.lscache1.c.youtube.com
203.208.46.29   v5.lscache1.c.youtube.com
203.208.46.29   v6.lscache1.c.youtube.com
203.208.46.29   v7.lscache1.c.youtube.com
203.208.46.29   v8.lscache1.c.youtube.com
203.208.46.29   v9.lscache1.c.youtube.com
203.208.46.29   v10.lscache1.c.youtube.com
203.208.46.29   v11.lscache1.c.youtube.com
203.208.46.29   v12.lscache1.c.youtube.com
203.208.46.29   v13.lscache1.c.youtube.com
203.208.46.29   v14.lscache1.c.youtube.com
203.208.46.29   v15.lscache1.c.youtube.com
203.208.46.29   v16.lscache1.c.youtube.com
203.208.46.29   v17.lscache1.c.youtube.com
203.208.46.29   v18.lscache1.c.youtube.com
203.208.46.29   v19.lscache1.c.youtube.com
203.208.46.29   v20.lscache1.c.youtube.com
203.208.46.29   v21.lscache1.c.youtube.com
203.208.46.29   v22.lscache1.c.youtube.com
203.208.46.29   v23.lscache1.c.youtube.com
203.208.46.29   v24.lscache1.c.youtube.com
203.208.46.29   v1.lscache2.c.youtube.com
203.208.46.29   v2.lscache2.c.youtube.com
203.208.46.29   v3.lscache2.c.youtube.com
203.208.46.29   v4.lscache2.c.youtube.com
203.208.46.29   v5.lscache2.c.youtube.com
203.208.46.29   v6.lscache2.c.youtube.com
203.208.46.29   v7.lscache2.c.youtube.com
203.208.46.29   v8.lscache2.c.youtube.com
203.208.46.29   v9.lscache2.c.youtube.com
203.208.46.29   v10.lscache2.c.youtube.com
203.208.46.29   v11.lscache2.c.youtube.com
203.208.46.29   v12.lscache2.c.youtube.com
203.208.46.29   v13.lscache2.c.youtube.com
203.208.46.29   v14.lscache2.c.youtube.com
203.208.46.29   v15.lscache2.c.youtube.com
203.208.46.29   v16.lscache2.c.youtube.com
203.208.46.29   v17.lscache2.c.youtube.com
203.208.46.29   v18.lscache2.c.youtube.com
203.208.46.29   v19.lscache2.c.youtube.com
203.208.46.29   v20.lscache2.c.youtube.com
203.208.46.29   v21.lscache2.c.youtube.com
203.208.46.29   v22.lscache2.c.youtube.com
203.208.46.29   v23.lscache2.c.youtube.com
203.208.46.29   v24.lscache2.c.youtube.com
203.208.46.29   v1.lscache3.c.youtube.com
203.208.46.29   v2.lscache3.c.youtube.com
203.208.46.29   v3.lscache3.c.youtube.com
203.208.46.29   v4.lscache3.c.youtube.com
203.208.46.29   v5.lscache3.c.youtube.com
203.208.46.29   v6.lscache3.c.youtube.com
203.208.46.29   v7.lscache3.c.youtube.com
203.208.46.29   v8.lscache3.c.youtube.com
203.208.46.29   v9.lscache3.c.youtube.com
203.208.46.29   v10.lscache3.c.youtube.com
203.208.46.29   v11.lscache3.c.youtube.com
203.208.46.29   v12.lscache3.c.youtube.com
203.208.46.29   v13.lscache3.c.youtube.com
203.208.46.29   v14.lscache3.c.youtube.com
203.208.46.29   v15.lscache3.c.youtube.com
203.208.46.29   v16.lscache3.c.youtube.com
203.208.46.29   v17.lscache3.c.youtube.com
203.208.46.29   v18.lscache3.c.youtube.com
203.208.46.29   v19.lscache3.c.youtube.com
203.208.46.29   v20.lscache3.c.youtube.com
203.208.46.29   v21.lscache3.c.youtube.com
203.208.46.29   v22.lscache3.c.youtube.com
203.208.46.29   v23.lscache3.c.youtube.com
203.208.46.29   v24.lscache3.c.youtube.com
203.208.46.29   v1.lscache4.c.youtube.com
203.208.46.29   v2.lscache4.c.youtube.com
203.208.46.29   v3.lscache4.c.youtube.com
203.208.46.29   v4.lscache4.c.youtube.com
203.208.46.29   v5.lscache4.c.youtube.com
203.208.46.29   v6.lscache4.c.youtube.com
203.208.46.29   v7.lscache4.c.youtube.com
203.208.46.29   v8.lscache4.c.youtube.com
203.208.46.29   v9.lscache4.c.youtube.com
203.208.46.29   v10.lscache4.c.youtube.com
203.208.46.29   v11.lscache4.c.youtube.com
203.208.46.29   v12.lscache4.c.youtube.com
203.208.46.29   v13.lscache4.c.youtube.com
203.208.46.29   v14.lscache4.c.youtube.com
203.208.46.29   v15.lscache4.c.youtube.com
203.208.46.29   v16.lscache4.c.youtube.com
203.208.46.29   v17.lscache4.c.youtube.com
203.208.46.29   v18.lscache4.c.youtube.com
203.208.46.29   v19.lscache4.c.youtube.com
203.208.46.29   v20.lscache4.c.youtube.com
203.208.46.29   v21.lscache4.c.youtube.com
203.208.46.29   v22.lscache4.c.youtube.com
203.208.46.29   v23.lscache4.c.youtube.com
203.208.46.29   v24.lscache4.c.youtube.com
203.208.46.29   v1.lscache5.c.youtube.com
203.208.46.29   v2.lscache5.c.youtube.com
203.208.46.29   v3.lscache5.c.youtube.com
203.208.46.29   v4.lscache5.c.youtube.com
203.208.46.29   v5.lscache5.c.youtube.com
203.208.46.29   v6.lscache5.c.youtube.com
203.208.46.29   v7.lscache5.c.youtube.com
203.208.46.29   v8.lscache5.c.youtube.com
203.208.46.29   v9.lscache5.c.youtube.com
203.208.46.29   v10.lscache5.c.youtube.com
203.208.46.29   v11.lscache5.c.youtube.com
203.208.46.29   v12.lscache5.c.youtube.com
203.208.46.29   v13.lscache5.c.youtube.com
203.208.46.29   v14.lscache5.c.youtube.com
203.208.46.29   v15.lscache5.c.youtube.com
203.208.46.29   v16.lscache5.c.youtube.com
203.208.46.29   v17.lscache5.c.youtube.com
203.208.46.29   v18.lscache5.c.youtube.com
203.208.46.29   v19.lscache5.c.youtube.com
203.208.46.29   v20.lscache5.c.youtube.com
203.208.46.29   v21.lscache5.c.youtube.com
203.208.46.29   v22.lscache5.c.youtube.com
203.208.46.29   v23.lscache5.c.youtube.com
203.208.46.29   v24.lscache5.c.youtube.com
203.208.46.29   v1.lscache6.c.youtube.com
203.208.46.29   v2.lscache6.c.youtube.com
203.208.46.29   v3.lscache6.c.youtube.com
203.208.46.29   v4.lscache6.c.youtube.com
203.208.46.29   v5.lscache6.c.youtube.com
203.208.46.29   v6.lscache6.c.youtube.com
203.208.46.29   v7.lscache6.c.youtube.com
203.208.46.29   v8.lscache6.c.youtube.com
203.208.46.29   v9.lscache6.c.youtube.com
203.208.46.29   v10.lscache6.c.youtube.com
203.208.46.29   v11.lscache6.c.youtube.com
203.208.46.29   v12.lscache6.c.youtube.com
203.208.46.29   v13.lscache6.c.youtube.com
203.208.46.29   v14.lscache6.c.youtube.com
203.208.46.29   v15.lscache6.c.youtube.com
203.208.46.29   v16.lscache6.c.youtube.com
203.208.46.29   v17.lscache6.c.youtube.com
203.208.46.29   v18.lscache6.c.youtube.com
203.208.46.29   v19.lscache6.c.youtube.com
203.208.46.29   v20.lscache6.c.youtube.com
203.208.46.29   v21.lscache6.c.youtube.com
203.208.46.29   v22.lscache6.c.youtube.com
203.208.46.29   v23.lscache6.c.youtube.com
203.208.46.29   v24.lscache6.c.youtube.com
203.208.46.29   v1.lscache7.c.youtube.com
203.208.46.29   v2.lscache7.c.youtube.com
203.208.46.29   v3.lscache7.c.youtube.com
203.208.46.29   v4.lscache7.c.youtube.com
203.208.46.29   v5.lscache7.c.youtube.com
203.208.46.29   v6.lscache7.c.youtube.com
203.208.46.29   v7.lscache7.c.youtube.com
203.208.46.29   v8.lscache7.c.youtube.com
203.208.46.29   v9.lscache7.c.youtube.com
203.208.46.29   v10.lscache7.c.youtube.com
203.208.46.29   v11.lscache7.c.youtube.com
203.208.46.29   v12.lscache7.c.youtube.com
203.208.46.29   v13.lscache7.c.youtube.com
203.208.46.29   v14.lscache7.c.youtube.com
203.208.46.29   v15.lscache7.c.youtube.com
203.208.46.29   v16.lscache7.c.youtube.com
203.208.46.29   v17.lscache7.c.youtube.com
203.208.46.29   v18.lscache7.c.youtube.com
203.208.46.29   v19.lscache7.c.youtube.com
203.208.46.29   v20.lscache7.c.youtube.com
203.208.46.29   v21.lscache7.c.youtube.com
203.208.46.29   v22.lscache7.c.youtube.com
203.208.46.29   v23.lscache7.c.youtube.com
203.208.46.29   v24.lscache7.c.youtube.com
203.208.46.29   v1.lscache8.c.youtube.com
203.208.46.29   v2.lscache8.c.youtube.com
203.208.46.29   v3.lscache8.c.youtube.com
203.208.46.29   v4.lscache8.c.youtube.com
203.208.46.29   v5.lscache8.c.youtube.com
203.208.46.29   v6.lscache8.c.youtube.com
203.208.46.29   v7.lscache8.c.youtube.com
203.208.46.29   v8.lscache8.c.youtube.com
203.208.46.29   v9.lscache8.c.youtube.com
203.208.46.29   v10.lscache8.c.youtube.com
203.208.46.29   v11.lscache8.c.youtube.com
203.208.46.29   v12.lscache8.c.youtube.com
203.208.46.29   v13.lscache8.c.youtube.com
203.208.46.29   v14.lscache8.c.youtube.com
203.208.46.29   v15.lscache8.c.youtube.com
203.208.46.29   v16.lscache8.c.youtube.com
203.208.46.29   v17.lscache8.c.youtube.com
203.208.46.29   v18.lscache8.c.youtube.com
203.208.46.29   v19.lscache8.c.youtube.com
203.208.46.29   v20.lscache8.c.youtube.com
203.208.46.29   v21.lscache8.c.youtube.com
203.208.46.29   v22.lscache8.c.youtube.com
203.208.46.29   v23.lscache8.c.youtube.com
203.208.46.29   v24.lscache8.c.youtube.com 
#Twitter

199.59.148.84 oauth.twitter.com
199.59.148.84 twitter.com
199.59.148.84 www.twitter.com
199.59.148.84 api.twitter.com
199.59.148.201 search.twitter.com
199.59.148.139 userstream.twitter.com
199.59.148.84 ssl.twitter.com
199.59.148.84 status.twitter.com
199.59.148.84 assets0.twitter.com
199.59.148.84 assets1.twitter.com
199.59.148.84 assets2.twitter.com
199.59.148.84 assets3.twitter.com
199.59.148.84 static.twitter.com
184.29.36.124 platform.twitter.com
219.76.10.138 platform0.twitter.com
199.59.148.206 help.twitter.com
199.59.148.206 support.twitter.com
209.84.4.102 si0.twimg.com
209.84.4.102 si1.twimg.com
209.84.4.102 si2.twimg.com
209.84.4.102 si3.twimg.com
209.84.4.102 si4.twimg.com
209.84.4.102 si5.twimg.com

#Facebook 脸谱网（尚未完全部署）
69.63.189.16 facebook.com
69.63.189.16 www.facebook.com
69.63.181.31 m.facebook.com
69.63.181.20 login.facebook.com
69.63.179.70 secure.facebook.com
66.220.146.18 apps.facebook.com
69.63.181.31 touch.facebook.com
118.214.114.110 s-static.ak.facebook.com
66.220.147.47 api.facebook.com
69.63.181.16 zh-CN.facebook.com
202.157.186.28  static.ak.facebook.com
202.157.186.34 b.static.ak.facebook.com
69.63.178.57 secure-profile.facebook.com
69.63.178.57 secure-media-sf2p.facebook.com
69.63.178.15 ssl.facebook.com
69.63.190.18 apps.facebook.com
118.214.190.105 profile.ak.facebook.com

#Facebook web
69.63.187.17 fbcdn.net
97.65.135.139 external.ak.fbcdn.net
124.155.222.50 vthumb.ak.fbcdn.net
97.65.135.163 static.ak.fbcdn.net
97.65.135.163 b.static.ak.fbcdn.net
202.157.186.34 creative.ak.fbcdn.net
118.214.190.128 profile.ak.fbcdn.net
69.63.176.21 s-hprofile-sf2p.fbcdn.net
125.56.199.9 photos-a.ak.fbcdn.net
125.56.199.9 photos-b.ak.fbcdn.net
125.56.199.9 photos-c.ak.fbcdn.net
125.56.199.9 photos-d.ak.fbcdn.net
125.56.199.9 photos-e.ak.fbcdn.net
125.56.199.9 photos-f.ak.fbcdn.net
125.56.199.9 photos-g.ak.fbcdn.net
125.56.199.9 photos-h.ak.fbcdn.net
&lt;/pre&gt;&lt;/div&gt;</summary><category term="google"></category><category term="host"></category></entry><entry><title>用pelican在github上创建自己的博客!</title><link href="http://x-wei.github.io/pelican_github_blog.html" rel="alternate"></link><updated>2012-04-13T00:00:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/pelican_github_blog.html</id><summary type="html">&lt;p&gt;折腾了许久, 终于把&lt;a href="http://x-wei.github.com"&gt;我的博客&lt;/a&gt;搞得差不多了, 在此写一个总结, 以免自己以后忘了, 并且给和我一样菜的人提供一点参考....&lt;/p&gt;
&lt;h2&gt;先扯点别的&lt;/h2&gt;
&lt;p&gt;其实啊, 很早就想要建立自己的博客, 把值得分享的东西拿出来放到网上, 但是又不屑于使用网易, 百度等提供的现成服务, 技术又很菜... 于是一直拖着. zim的出现让我很欣喜--zim可以写类似于博客的东西(不过是给自己看的~), 记录有价值的内容. 但是怎么把我的一些总结放到网上?? 我先后考虑了这些东西:&lt;/p&gt;
&lt;p&gt;googlesite--&amp;gt;wordpress--&amp;gt;jekyll+github--&amp;gt;pelican+github&lt;/p&gt;
&lt;p&gt;googlesite是个很好的工具, &lt;strong&gt;很容易上手&lt;/strong&gt;(google好赞...), 我曾经用它做过一个个人页面. 但是这种傻瓜工具的缺点就是: 没法自己定制... 当我发现googlesite的bolg页面不支持标签云的时候, 就决定不用它了... 况且googlesite在国内需要修改一下host才能访问... &lt;/p&gt;
&lt;p&gt;然后是wordpress, 这个似乎目前也是最流行的网页制作工具, 我看到了很多很多大牛小牛使用WP搭建的自己的网站, 而且都是自己的顶级域名, 看上去就灰常霸气~ 当我终于有空折腾, 兴冲冲地研究WP时, 却发现&lt;strong&gt;顶级域名注册都是要交钱的&lt;/strong&gt;, 还要弄什么vpn...这... 大概不适合我...&lt;/p&gt;
&lt;p&gt;在我纠结的时候, 请教了&lt;a href="http://www.dofine.me/"&gt;dofine&lt;/a&gt;同学, 他推荐我使用&lt;a href="http://help.github.com/pages/"&gt;github pages&lt;/a&gt;(后来证明这是非常正确的~). 早就听说git大名, 只是我太菜了... 不知能不能搞定啊... 还好可以随时询问dofine同学(有时我的问题很弱智, 他还是很耐心的回答, 真好~). github page弄好后, 要按装jekyll作为&lt;strong&gt;静态页面&lt;/strong&gt;的生成工具. 在使用zim的时候, 我就对轻量级标记语言非常喜欢, jekyll可以使用Markdown格式(比zim的wiki语法还要简洁), 所以说应该是非常好的选择. &lt;strong&gt;但是我在jekyll的安装这一步卡住了&lt;/strong&gt;... 由于我用的是ubuntu10.04, 安装各种报错... 更新了rubygem之后以为成功了, 但是运行jekyll还是不行... 折腾了两天后, 我决定暂时放弃了...&lt;/p&gt;
&lt;p&gt;就在纠结之时, 报着试一试的态度, 在&lt;a href="https://bbs.sjtu.edu.cn/file/bbs/index/index.htm"&gt;yssy&lt;/a&gt; 的gnu/linux版上问了一下, 得到了 &lt;a href="http://farseerfc.github.com/"&gt;farseerfc&lt;/a&gt; 学长非常热情耐心的回答. 他建议我&lt;a href="http://farseerfc.github.com/try-pelican-zhs.html"&gt;采用pelican&lt;/a&gt;来生成静态页面, 这是一个法国人用python写的程序. 我很容易就安装好了, 然后又折腾了许久, 现在终于基本搞定...... 感觉pelican还是相当不错的选择, 配置好了之后就可以安心写文章了...&lt;/p&gt;
&lt;h2&gt;第一步: 生成github page&lt;/h2&gt;
&lt;p&gt;第一步要做的就是注册github, 生成一个自己的二级域名(比如我的x-wei.github.com). 注册和配置SSH密钥过程&lt;a href="http://help.github.com/linux-set-up-git/"&gt;help page&lt;/a&gt;写得很清楚, 虽然我连SSH是什么都搞不清, 按它说的一步一步做, 很容易就搞定了.&lt;/p&gt;
&lt;p&gt;然后要新建一个repo(中文翻译成"依赖"?), 注意&lt;strong&gt;这个repo需要命名成: your_id.github.com&lt;/strong&gt;, 所以一个id只能生成一个啦... 生成这个repo后会有提示, 运行一下mkdir, git init什么的就OK了.&lt;/p&gt;
&lt;p&gt;这样, 建立好了your_id.github.com的repo之后, 只要把一个index.html文件上传到master分支, 就可以访问your_id.github.com看到那个index.html文件了~&lt;/p&gt;
&lt;h2&gt;第二步: 安装和使用pelican&lt;/h2&gt;
&lt;p&gt;pelican的安装需要用到pip:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$sudo apt-get install python-pip&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后再用pip安装pelican:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$sudo pip install pelican&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样, 安装就完成了~&lt;/p&gt;
&lt;p&gt;pelican的使用很简单, 这是帮助信息:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;pelican -h
usage: pelican &lt;span class="o"&gt;[&lt;/span&gt;-h&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-t THEME&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-o OUTPUT&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-m MARKUP&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-s SETTINGS&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-d&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-v&lt;span class="o"&gt;]&lt;/span&gt;
               &lt;span class="o"&gt;[&lt;/span&gt;-q&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-D&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--version&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-r&lt;span class="o"&gt;]&lt;/span&gt;
               &lt;span class="o"&gt;[&lt;/span&gt;path&lt;span class="o"&gt;]&lt;/span&gt;

A tool to generate a static blog, with restructured text input files.

positional arguments:
  path                  Path where to find the content files

optional arguments:
  -h, --help            show this &lt;span class="nb"&gt;help &lt;/span&gt;message and &lt;span class="nb"&gt;exit&lt;/span&gt;
  -t THEME, --theme-path THEME
                        Path where to find the theme templates. If not
                        specified, itwill use the default one included with
                        pelican.
  -o OUTPUT, --output OUTPUT
                        Where to output the generated files. If not specified,
                        a directory will be created, named &lt;span class="s2"&gt;&amp;quot;output&amp;quot;&lt;/span&gt; in the
                        current path.
  -m MARKUP, --markup MARKUP
                        the list of markup language to use &lt;span class="o"&gt;(&lt;/span&gt;rst or md&lt;span class="o"&gt;)&lt;/span&gt;. Please
                        indicate them separated by commas
  -s SETTINGS, --settings SETTINGS
                        the settings of the application. Default to False.
  -d, --delete-output-directory
                        Delete the output directory.
  -v, --verbose         Show all messages
  -q, --quiet           Show only critical errors
  -D, --debug           Show all message, including debug messages
  --version             Print the pelican version and &lt;span class="nb"&gt;exit&lt;/span&gt;
  -r, --autoreload      Relaunch pelican each &lt;span class="nb"&gt;time &lt;/span&gt;a modification occurs on
                        the contentfiles
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;额, 其实那些参数可以先无视(直接用默认参数)... 那么用法就很简单了: &lt;strong&gt;$pelican [path]&lt;/strong&gt;, 其中, path是放置markdown或rst文件的目录. 如果手头有几篇.md文件或.rst文件, 那么只要:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$pelican [.md/.rst文件所在目录]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;就会看到效果了... 大概会在一个'output'目录里, 打开index.html就可以看到生成的页面, 只要把这些生成的文件push到github的master分支, 你的博客就建好了~~&lt;/p&gt;
&lt;p&gt;另外, 把.md文件分别放在几个子目录, 那么生成的页面显示属于不同分类的文章了~&lt;/p&gt;
&lt;p&gt;关于pelican的配置, 待会再说, 先说说git的上传...&lt;/p&gt;
&lt;h2&gt;第三步: 编辑.md/.rst文件&lt;/h2&gt;
&lt;p&gt;markdown和rst都是非常优秀的轻量级标记语言, 可以很方便的写出整洁漂亮的笔记, 编写博客文章只要写成一个一个的.md或.rst文件然后交给pelican就OK了.&lt;/p&gt;
&lt;p&gt;关于这两种格式的语法, 其实我自己还不太熟悉呢... 网上有不少教程, 比如这个&lt;a href="http://wowubuntu.com/markdown/"&gt;markdown的教程&lt;/a&gt;和&lt;a href="http://readthedocs.org/docs/beinggeekbook/en/latest/rst.html"&gt;这个ReST教程&lt;/a&gt;...&lt;/p&gt;
&lt;p&gt;需要注意的是, 在文章的开头要指定一下博客的信息: 博客标题, 时间, 标签... pelican的帮助页面各提供了一个示例(我稍微修改了一下):&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.rst示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;My super title
##############

:date: 2010-10-03 10:20
:tags: tag1, tag2
:category: yeah //如果把这个rst文件放在posts/下的子目录的话, 那么这一行可以省略, 默认把子文件夹名作为分类
:author: Alexis Metaireau //由于settings文件已经指定了作者. 这一行可以省略
:slug: test-blog //这个是指定生成页面的名称, 比如这个是指定生成的页面名字是&amp;quot;test-blog.html&amp;quot;

这里写博客内容...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;.md示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2010&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;03&lt;/span&gt;
&lt;span class="n"&gt;Title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="kd"&gt;super&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;
&lt;span class="n"&gt;Slug&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;blog&lt;/span&gt;
&lt;span class="n"&gt;Tags&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;tag1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tag2&lt;/span&gt;

&lt;span class="err"&gt;这里写博客内容&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;另: 关于编辑器&lt;/strong&gt;
编辑这类文件时最好能够预览效果, linux下用&lt;a href="http://wowubuntu.com/retext.html"&gt;ReText&lt;/a&gt;即可~ &lt;/p&gt;
&lt;h2&gt;第四步: 把生成的文件上传到github&lt;/h2&gt;
&lt;p&gt;以前没用过git, 所以这个让我困惑了很长时间... &lt;/p&gt;
&lt;p&gt;首先, 应该在your_id.github.com页面下有一个.git文件夹(大概是git init生成的吧), 然后, 把生成好了的那些文件(比如上一步的output文件夹里的东西)放在这个目录下, 依次运行以下三个命令:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; add .&lt;/span&gt;
&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; commit -am &amp;quot;your commit message&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; push&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;额 是的, 需要三条命令才能完成上传... 另外, 貌似这样会覆盖掉原先的那些文件, 不必担心, github有history功能(我的理解 可能跟快照有点类似吧), 原先的东西应该可以找回来...&lt;/p&gt;
&lt;p&gt;push完成后, 你的注册邮箱会收到邮件"page built successful", 如果是第一次生成的话, 最多等10分钟, 你就可以访问your_id.github.com看到效果啦~~&lt;/p&gt;
&lt;h2&gt;第五步: pelican的进一步配置&lt;/h2&gt;
&lt;p&gt;如果按照默认的参数, 直接$pelican path的话, 估计不会得到让你满意的页面--至少网站名字要改一下吧!! 还有, 默认的主题没有标签云, 反正我比较想要这个功能... &lt;/p&gt;
&lt;p&gt;farseerfc给了一个&lt;a href="https://github.com/farseerfc/farseerfc.github.com/blob/master/settings.py"&gt;settings.py&lt;/a&gt;配置文件, 各个变量的名字含义应该比较清楚, 或者看pelican的&lt;a href="http://readthedocs.org/docs/pelican/en/2.8/settings.html"&gt;帮助页面&lt;/a&gt;, 这个页面也提供了一个示例配置文件. 可以在这俩配置文件基础上进行修改... 修改完成了之后, 运行pelican时加上-s参数指定settings.py作为配置文件:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$pelican -s settings.py [.md/.rst文件所在目录]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我是从farseerfc的配置文件改的, 大概是这个样子:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="n"&gt;TIMEZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Asia/Shanghai&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;DEFAULT_LANG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;zhs&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;X. Wei&amp;#39;s Blog&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;AUTHOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;X.Wei&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;xweisblog&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;GITHUB_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;lt;https://github.com/X-Wei&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="c"&gt;#github链接&lt;/span&gt;
&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;lt;http://x-wei.github.com&amp;gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;GOOGLE_ANALYTICS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;UA-30756331-1&amp;#39;&lt;/span&gt;&lt;span class="c"&gt;#谷歌站点分析&lt;/span&gt;
&lt;span class="n"&gt;TAG_FEED&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.atom.xml&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;DEFAULT_PAGINATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="c"&gt;#默认每一页有多少篇文章&lt;/span&gt;

&lt;span class="n"&gt;DEFAULT_CATEGORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;misc&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;OUTPUT_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;#需要把输出路径从默认的&amp;#39;output&amp;#39;改成根目录(your_id.github.com目录), 因为githubpage需要把index.html上传到repo的master分支的根目录才可以!&lt;/span&gt;
&lt;span class="n"&gt;PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;posts&amp;#39;&lt;/span&gt;&lt;span class="c"&gt;#这个是指定放置.md/.rst文件的目录&lt;/span&gt;

&lt;span class="n"&gt;LINKS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;dofine&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;lt;http://www.dofine.me&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;farseerfc&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;lt;http://farseerfc.github.com/&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c"&gt;#友情链接~&lt;/span&gt;

&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;github&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;lt;https://github.com/x-wei&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c"&gt;#社交网络链接&lt;/span&gt;
          &lt;span class="c"&gt;#~ (&amp;#39;twitter&amp;#39;, &amp;#39;&amp;lt;http://twitter.com/farseerfc&amp;gt;&amp;#39;),&lt;/span&gt;
          &lt;span class="c"&gt;#~ (&amp;#39;facebook&amp;#39;, &amp;#39;&amp;lt;http://www.facebook.com/farseerfc&amp;gt;&amp;#39;),&lt;/span&gt;
          &lt;span class="c"&gt;#~ (&amp;#39;weibo&amp;#39;, &amp;#39;&amp;lt;http://weibo.com/farseerfc&amp;gt;&amp;#39;),&lt;/span&gt;
          &lt;span class="c"&gt;#~ (&amp;#39;renren&amp;#39;, &amp;#39;&amp;lt;http://www.renren.com/farseer&amp;gt;&amp;#39;),&lt;/span&gt;


&lt;span class="c"&gt;#这个是farseerfc同学自己加的, 可以显示他的新浪微博内容, 有微博的话可以把这些加上~&lt;/span&gt;
&lt;span class="c"&gt;#~ TWITTER_USERNAME = &amp;#39;farseerfc&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;#~ SIDEBAR_CUSTOM = r&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;#~ &amp;lt;li class=&amp;quot;nav-header&amp;quot;&amp;gt;&amp;lt;h4&amp;gt;&amp;lt;i class=&amp;quot;icon-list-alt&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;Weibo&amp;lt;/h4&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;#~ &amp;lt;iframe width=&amp;quot;100%&amp;quot; height=&amp;quot;550&amp;quot; class=&amp;quot;share_self&amp;quot;  frameborder=&amp;quot;0&amp;quot; scrolling=&amp;quot;no&amp;quot; &lt;/span&gt;
&lt;span class="c"&gt;#~ src=&amp;quot;&amp;lt;http://widget.weibo.com/weiboshow/index.php?language=&amp;amp;width=0&amp;amp;height=550&amp;amp;fansRow=1&amp;amp;ptype=1&amp;amp;speed=0&amp;amp;skin=2&amp;amp;isTitle=1&amp;amp;noborder=1&amp;amp;isWeibo=1&amp;amp;isFans=1&amp;amp;uid=1862842353&amp;amp;verifier=b193b9de&amp;amp;dpc=1&amp;gt;&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;#~ &amp;lt;/iframe&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;#~ &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;#google自定义搜索(大概是站内搜索吧)&lt;/span&gt;
&lt;span class="c"&gt;#~ GOOGLE_CUSTOM_SEARCH_SIDEBAR = &amp;quot;001578481551708017171:axpo6yvtdyg&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;#~ GOOGLE_CUSTOM_SEARCH_NAVBAR = &amp;quot;001578481551708017171:hxkva69brmg&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于配置文件里已经包含了PATH和OUTPUT_PATH什么的, 所以运行只要:&lt;code&gt;$pelican -s settings.py&lt;/code&gt;即可~&lt;/p&gt;
&lt;p&gt;然后, 关于主题模板, 可以使用-t参数指定主题. pelican目前主题在&lt;a href="https://github.com/farseerfc/pelican-themes"&gt;github&lt;/a&gt;上, 可以用$git clone &lt;a href="https://github.com/farseerfc/pelican-themes"&gt;https://github.com/farseerfc/pelican-themes&lt;/a&gt; 下载, 然后使用主题的话就是:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$pelican -s settings.py -t [主题所在目录] [.md/.rst文件所在目录]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果想生成后就预览一下, 那就写:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$pelican -s settings.py -t [主题所在目录] [.md/.rst文件所在目录] | xdg-open index.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;个人感觉还是bootstrap2主题比较好... 目前由于pelican使用的人不多, 所以主题也就那十几个... &lt;/p&gt;
&lt;h2&gt;再罗嗦一下: 关于一些问题的解决方法&lt;/h2&gt;
&lt;p&gt;这几天折腾pelican很久很久, 发现以下几个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不支持多层分类?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;--这个目前没法解决, 不过既然有标签功能, 分类不能多层也无所谓啦...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装后不支持Markdown语法?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个是因为Markdown没有与pelican包一起安装(pelican默认的还是支持rst格式), 安装上Markdown包就行了:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$sudo pip install Markdown&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何插图?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里不是讨论markdown语法如何插图, 而是怎么让生成的网页有图片. 其实很简单, 把.md文件里引用的图片复制一份到static目录即可~ (其实剪切也是可以的, 只不过那样的话编辑预览时就看不见图片了...)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中文tag不支持?(事后证明其实是支持的, 是我搞得不支持了...)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pelican2.8(当前版本)是支持中文tag的! 我一开始直接git clone了3.0的源码, 然后不支持了... 需要重装pelican:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;sudo&lt;/span&gt;&lt;span class="x"&gt; pip uninstall pelican&lt;/span&gt;
&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;sudo&lt;/span&gt;&lt;span class="x"&gt; pip install pelican&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;不支持中文文件名(&lt;strong&gt;2012-04-25: XXXXX!! 可以啊, 谁说不可以...&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个我没解决, 无所谓, 起一个英文文件名(.md文件以及Slug最好都用英文吧)好了, 毕竟博客标题(Title)是可以用中文的~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OK, 就写这些吧... (累死了...)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(我发现几乎所有文章都是从zim里搬来的, so, 以后就不在文章最后标注"imported from zim"了...)&lt;/p&gt;</summary><category term="pelican"></category><category term="git"></category></entry><entry><title>Hello World!</title><link href="http://x-wei.github.io/hello-world.html" rel="alternate"></link><updated>2012-04-09T20:39:00+02:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/hello-world.html</id><summary type="html">&lt;p&gt;建立起了我的github博客~!&lt;/p&gt;
&lt;p&gt;作为一个很菜的低端桌面(ubuntu, gnome)用户, 这个还是相当不容易啊~~&lt;/p&gt;
&lt;p&gt;本来考虑使用的是jekyll, 但是安装过程老是报错... 最终选择了pelican生成静态页面, 这个工具很好用, 只是目前关注度不足啊~ 关于pelican的介绍可以参考
&lt;a class="reference external" href="http://farseerfc.github.com/try-pelican.html"&gt;这里&lt;/a&gt;
, jekyll我折腾了N久没有搞定, 而pelican很快就装好了~ 非常感谢
&lt;a class="reference external" href="http://farseerfc.github.com/index.html"&gt;farseerfc&lt;/a&gt;
同学, 非常耐心地回答我这个菜鸟的问题... 不过还是自力更生比较好, 好好看它的
&lt;a class="reference external" href="http://readthedocs.org/docs/pelican/en/2.8/"&gt;文档&lt;/a&gt;
吧~&lt;/p&gt;
&lt;p&gt;另外, 我之前用
&lt;a class="reference external" href="http://zim-wiki.org/"&gt;zim&lt;/a&gt;
写了一些笔记, 准备把值得分享的部分放到blog上来. zim0.56刚刚开始支持把笔记导出成markdown格式, 这实在是太棒啦!!&lt;/p&gt;
</summary><category term="pelican"></category></entry><entry><title>使用google doc建立在线调查表!~</title><link href="http://x-wei.github.io/google_doc_form.html" rel="alternate"></link><updated>2012-03-21T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/google_doc_form.html</id><summary type="html">&lt;p&gt;在线办公我以前试过zoho, 但是一个xls文件有多个人同时编辑时会有问题...&lt;/p&gt;
&lt;p&gt;昨天收到学长关于春游的&lt;a href="https://docs.google.com/spreadsheet/viewform?formkey=dDhzYnRNVHFReXRoanlpZWRyYjM4Y2c6MQ"&gt;调查表&lt;/a&gt;, 居然是用google doc做的, 很给力. 我早就想做一个分布式通讯录, 所以研究了一下. 越来越感觉google提供的服务(google doc, google site, google project)太方便了!!!&lt;/p&gt;
&lt;h2&gt;建立&lt;/h2&gt;
&lt;p&gt;大概的流程是这样的:
用google帐号进入google doc, 然后点击creat-&amp;gt;form, 会看到这样的页面:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./google_doc_form/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;嗯, 功能是比较简单但是够用!
点击add item 或者右边俩方框的按钮, 就可以添加问题了, 很easy, 我做的同学录是这个样子的:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./google_doc_form/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;然后还可以选择主题...&lt;/p&gt;
&lt;h2&gt;发布&lt;/h2&gt;
&lt;p&gt;编辑完成之后, 就可以发布了, 点击右上角的"Share"(有个g+的图标, 我一开始以为是像人人那样的分享呢...), 之后页面底部就会有一个链接~! 把这个链接发给别人, 别人就可以提交了~&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./google_doc_form/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;p&gt;btw, 如果不想发布, 只想发给几个人看的话, 点击share右边的那个"email this form"按钮, 输入联系人的邮箱地址即可~&lt;/p&gt;
&lt;h2&gt;统计&lt;/h2&gt;
&lt;p&gt;那么别人提交之后, 我怎么看统计结果呢? 进入google doc, 会发现刚才建立的form的结果在一个表单里:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./google_doc_form/pasted_image003.png" /&gt;&lt;/p&gt;
&lt;p&gt;点进去看, 就可以看到大家的回复统计&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./google_doc_form/pasted_image004.png" /&gt;&lt;/p&gt;
&lt;p&gt;看! 多方便!!
然后, 可以把这个文件共享给别人: 右键-&amp;gt;share:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./google_doc_form/pasted_image005.png" /&gt;&lt;/p&gt;
&lt;h2&gt;发布后的修改&lt;/h2&gt;
&lt;p&gt;那么, form发布后, 还可不可以再修改呢? --可以! 打开google doc里的表单, form-&amp;gt;edit form, 就会弹出编辑form的窗口啦!!&lt;/p&gt;
&lt;p&gt;注意那个more action里面的confirmation, 不要勾选"publish response summery"...否则任何人提交后就可以看到目前所有的信息了...&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./google_doc_form/pasted_image006.png" /&gt;&lt;/p&gt;
&lt;h2&gt;一点不足&lt;/h2&gt;
&lt;p&gt;就是一旦发布了, 任何有这个链接的人都可以填这个表格... 没有密码之类的...
我的方法是设置一个必填的"验证问题"项, 只有回答对了验证问题的人, 我才发给他同学录...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;imported from zim&lt;/strong&gt;&lt;/p&gt;</summary><category term="google"></category></entry><entry><title>自定义nautilus的菜单栏</title><link href="http://x-wei.github.io/nautilus-menu.html" rel="alternate"></link><updated>2012-03-08T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/nautilus-menu.html</id><summary type="html">&lt;p&gt;Nautilus是gnome的默认文件浏览器, 那次更新安装了elementory主题的Nautilus之后, 发现菜单栏少了些很常用的功能: 比如上一层,主页, 刷新等...&lt;/p&gt;
&lt;p&gt;其实可以自定义的, 编辑-&amp;gt;customize toolbar:
&lt;img alt="" src="./nautilus-menu/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;顺便提一下, 发现了些方便的快捷键:
alt+up: 父目录
alt+left: 返回
~~alt+home: 到~/~~(不好使?)
F2: 重命名
F5/ctrl+R: 刷新
ctrl+L: 输入位置地址
ctrl+H:显示隐藏文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--imported from zim&lt;/strong&gt;&lt;/p&gt;</summary><category term="外观"></category><category term="快捷键"></category></entry><entry><title>无聊中的发现--递归截图~</title><link href="http://x-wei.github.io/recursion-scr-shot.html" rel="alternate"></link><updated>2012-03-08T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/recursion-scr-shot.html</id><summary type="html">&lt;p&gt;就放一张图片, 知道怎么做的吗?~&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./recursion-scr-shot/Screenshot-7.png" /&gt;&lt;/p&gt;
&lt;p&gt;btw, 真心感觉zim可以作为一个写给自己的博客了, 不仅仅是记笔记... BON!~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--imported from zim&lt;/strong&gt;&lt;/p&gt;</summary></entry><entry><title>tex插入程序代码--so easy~</title><link href="http://x-wei.github.io/tex_insert_code.html" rel="alternate"></link><updated>2012-03-03T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/tex_insert_code.html</id><summary type="html">&lt;p&gt;这个问题... 我本来想用python解决的...&lt;/p&gt;
&lt;p&gt;但是显然应该先搜一下吧... 果然, 早就有人解决了(其实是tex的常用命令里就有的), 比如&lt;a href="http://hi.baidu.com/xuelicheng/blog/item/194c844a22d2452a09f7ef8a.html"&gt;这里&lt;/a&gt;...&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;usepackage&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;listings&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;lstset&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;language&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="err"&gt;这条命令可以让&lt;/span&gt;&lt;span class="n"&gt;LaTeX&lt;/span&gt;&lt;span class="err"&gt;排版时将&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="err"&gt;键字突出显示&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;lstset&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;breaklines&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="err"&gt;这条命令可以让&lt;/span&gt;&lt;span class="n"&gt;LaTeX&lt;/span&gt;&lt;span class="err"&gt;自动将长的代码行换行排版&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;lstset&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;extendedchars&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="err"&gt;这一条命令可以解决代码跨页时，章节标题，页眉等汉字不显示的问题&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;lstlisting&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nf"&gt;%paste&lt;/span&gt; &lt;span class="n"&gt;your&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;lstlisting&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;很简单的... 不过比较长的代码换行显示不是很爽(貌似不换行也不是办法啊)... 另外没有颜色高亮哎...&lt;/p&gt;
&lt;p&gt;嗯, 貌似&lt;a href="http://bbs.chinatex.org/forum.php?mod=viewthread&amp;amp;tid=3692"&gt;这里&lt;/a&gt;的介绍更详细...
还有这个人的&lt;a href="http://aifreedom.com/technology/170"&gt;博客&lt;/a&gt;...
&lt;a href="http://blog.sina.com.cn/s/blog_5e16f1770100o9ef.html"&gt;这篇文章&lt;/a&gt;是针对python的高亮...&lt;/p&gt;
&lt;p&gt;总结一下, 这样比较好:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;\documentclass&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;article&lt;span class="nb"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;\usepackage&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;listings&lt;span class="nb"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;\usepackage&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;xcolor&lt;span class="nb"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;\usepackage&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;xeCJK&lt;span class="nb"&gt;}&lt;/span&gt;  &lt;span class="c"&gt;%必须加xeCJK包&lt;/span&gt;
&lt;span class="k"&gt;\setCJKmainfont&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;WenQuanYi Micro Hei&lt;span class="nb"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;\begin&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;document&lt;span class="nb"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;\lstset&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;numbers=left,
numberstyle=&lt;span class="k"&gt;\tiny&lt;/span&gt;,
keywordstyle=&lt;span class="k"&gt;\color&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;blue!70&lt;span class="nb"&gt;}&lt;/span&gt;, commentstyle=&lt;span class="k"&gt;\color&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;red!50!green!50!blue!50&lt;span class="nb"&gt;}&lt;/span&gt;,
frame=shadowbox,
rulesepcolor=&lt;span class="k"&gt;\color&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;red!20!green!20!blue!20&lt;span class="nb"&gt;}&lt;/span&gt;,
breaklines=true,
extendedchars=true
&lt;span class="nb"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;\begin&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;lstlisting&lt;span class="nb"&gt;}&lt;/span&gt;[language=&lt;span class="nb"&gt;{&lt;/span&gt;Python&lt;span class="nb"&gt;}&lt;/span&gt;]
&lt;span class="c"&gt;%这里插入代码~&lt;/span&gt;
&lt;span class="k"&gt;\end&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;lstlisting&lt;span class="nb"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;\end&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;document&lt;span class="nb"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;附件: 我做的一个简单实例
&lt;a href="./tex_insert_code/insertcode2.tex"&gt;./insertcode2.tex&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;imported from zim&lt;/strong&gt;&lt;/p&gt;</summary><category term="tex"></category></entry><entry><title>xelatex--linux下tex中文的完全解决!</title><link href="http://x-wei.github.io/xelatex_zh.html" rel="alternate"></link><updated>2012-02-27T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/xelatex_zh.html</id><summary type="html">&lt;p&gt;前几天校内上看见了这个&lt;a href="http://page.renren.com/601024697/note/806581340?ref=share"&gt;latex中文指南&lt;/a&gt;, 想试一试...&lt;/p&gt;
&lt;p&gt;可是貌似不给力(or我没做对)安装了texlive之后还是不能编译它的测试源文件...&lt;/p&gt;
&lt;p&gt;搜索发现了&lt;a href="http://blog.sina.com.cn/s/blog_4c20fe7b0100vjbj.html"&gt;这样一篇&lt;/a&gt;非常强大的文章... 这货直接把他的源文件放上去了... 不过这样的话他的文章可读性就不好了...&lt;/p&gt;
&lt;p&gt;要进行的操作:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sudo apt-get install texlive-xetex latex-cjk-xcjk texlive-latex-recommended
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其实好像这样之后就可以用中文了(按博客里的意思), 可惜我用的geany开始使用latex编译的, 老是报错...&lt;/p&gt;
&lt;p&gt;其实应该用命令行 xelatex xx.tex就应该好使了...&lt;/p&gt;
&lt;p&gt;然后我又按照博客里的提示安装了Gummi...... 一个可以在右面看到效果的texIDE... 还是不行, 因为默认的编译器都是latex不是xelatex...&lt;/p&gt;
&lt;p&gt;当然我最终发现了要用xelatex, 那么老是用命令行也不大方便... gummi里面找到了设置:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./xelatex_zh/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;这样就好了...&lt;/p&gt;
&lt;p&gt;但是我现在已经非常喜欢geany了, 不想因为tex再单独用一个编辑环境... 还好找到了geany里面的设置: 生成--&amp;gt;设置生成命令, 在里面添加一个xelatex就行啦!~ 嗯 还是geany亲切~!&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./xelatex_zh/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;最后把源文件生成好的pdf也放进来吧...
&lt;a href="./xelatex_zh/xelatex_test.tex"&gt;./xelatex_test.tex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="./xelatex_zh/xelatex%20%E5%8F%8A%E4%B8%AD%E6%96%87%20Gummi%20%E5%9C%A8%20ubuntu%20%E4%B8%8A%E7%9A%84%E9%85%8D%E7%BD%AE.pdf"&gt;./xelatex 及中文 Gummi 在 ubuntu 上的配置.pdf&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;imported from zim&lt;/strong&gt; &lt;/p&gt;</summary><category term="tex"></category><category term="中文乱码"></category></entry><entry><title>chrome护眼设置--把背景设置为绿豆沙</title><link href="http://x-wei.github.io/chrome-background.html" rel="alternate"></link><updated>2012-02-23T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/chrome-background.html</id><summary type="html">&lt;p&gt;直接把&lt;a href="http://hi.baidu.com/laolao18k/blog/item/3a268016cd4c4907c83d6d46.html"&gt;这里&lt;/a&gt;的贴上吧...
(以下为copy)&lt;/p&gt;
&lt;p&gt;首先，下载安装chrome的&lt;a href="https://chrome.google.com/extensions/detail/pabfempgigicdjjlccdgnbmeggkbjdhd"&gt;stylist插件&lt;/a&gt;
然后，打开"扩展设置"，点击chrome stylist的选项，点击demo进行修改。 &lt;/p&gt;
&lt;p&gt;把网页背景修改为豆沙绿的参数设置: 
输入框1：demo 选项框2：regexp 输入框3：(ftp|http|https)://\D 输入框4： * { background: #C7EDCC !important; } 修改后保存即可 (url和style text可根据自己喜好配置) 
附：豆沙绿的参数 RGB颜色 199；237；204 十六位颜色代码 #C7EDCC 色调：85；饱和度：123；亮度：205 &lt;/p&gt;
&lt;p&gt;不会的话直接用&lt;a href="https://chrome.google.com/extensions/detail/hnjebfhieiaohnhafcolehbbcfkkkhje#%E5%AE%83%E9%99%A4%E4%BA%86%E6%8A%8AGoogle%E7%9A%84%E8%83%8C%E6%99%AF%E6%94%B9%E4%B8%BA%E4%BF%9D%E6%8A%A4%E7%9C%BC%E7%9D%9B%E7%9A%84%E7%BB%BF%E8%89%B2%EF%BC%8C%E4%BB%96%E6%B2%A1%E6%9C%89%E5%88%AB%E7%9A%84%E5%8A%9F%E8%83%BD"&gt;这个扩展&lt;/a&gt;。
&lt;img alt="" src="./chrome-background/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;04/24/2012续&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于那个正则表达式, 如果写成 &lt;code&gt;*{ background: #C7EDCC !important;}&lt;/code&gt;, 虽然一片绿豆色很护眼, 但是不少网页显示会有问题. 比如校内上新鲜事显示不了照片预览, gmail的加星标签看不见等... 最坑爹的是有的网页文字是浅色的, 那样的话几乎看不清楚了... 我现在使用的这样的规则: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nt"&gt;body&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;background&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="m"&gt;#C7EDCC&lt;/span&gt; &lt;span class="cp"&gt;!important&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt; 
&lt;span class="nt"&gt;body&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;color&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;black&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一行, 指定只是网页的body部分为绿豆沙色(大部分网页的背景都是body); 第二行, 指定body里的文字都使用黑色.&lt;/p&gt;
&lt;p&gt;这样弄下来比原先要好不少(关于上面提到的显示校内网和gmail的问题都解决了), 虽然网页不是全部绿豆沙了...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--imported from zim&lt;/strong&gt;&lt;/p&gt;</summary><category term="tips"></category><category term="google"></category><category term="外观"></category></entry><entry><title>chrome输出网页为pdf!</title><link href="http://x-wei.github.io/chrome%E8%BE%93%E5%87%BA%E7%BD%91%E9%A1%B5%E4%B8%BApdf!.html" rel="alternate"></link><updated>2012-02-23T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/chrome输出网页为pdf!.html</id><summary type="html">&lt;p&gt;不用装插件, 直接右键--&amp;gt;打印--&amp;gt;打印到文件 即可!&lt;/p&gt;
&lt;p&gt;太方便了! 关键是pdf分页很合理, 效果超好!&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./chrome%E8%BE%93%E5%87%BA%E7%BD%91%E9%A1%B5%E4%B8%BApdf!/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;03/05/2012续&lt;/strong&gt;
打印前需要把网页缩放足够小, 否则打印的文件只是一部分网页.&lt;/p&gt;</summary></entry><entry><title>gnome护眼设置--窗口背景设置为绿豆沙</title><link href="http://x-wei.github.io/gnome-background.html" rel="alternate"></link><updated>2012-02-23T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/gnome-background.html</id><summary type="html">&lt;p&gt;我就说win能做到ubuntu也能~&lt;/p&gt;
&lt;p&gt;主题--&amp;gt;自定义--&amp;gt;颜色&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./gnome-background/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;修改窗口和输入框两项的颜色:
126-12-91&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./gnome-background/pasted_image002.png" /&gt;&lt;/p&gt;
&lt;p&gt;现在就很舒服了&lt;/p&gt;
&lt;p&gt;然后貌似nautils要再设置一下:
编辑--&amp;gt;背景和徽标--&amp;gt;颜色--&amp;gt;把那个绿豆沙颜色加进去&lt;/p&gt;
&lt;p&gt;再加上[chrome的设置], 嗯 就完美了!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--imported from zim&lt;/strong&gt;&lt;/p&gt;</summary><category term="tips"></category><category term="外观"></category></entry><entry><title>用du命令查看各目录大小</title><link href="http://x-wei.github.io/use_du_shell.html" rel="alternate"></link><updated>2012-02-14T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/use_du_shell.html</id><summary type="html">&lt;p&gt;du用来计算目录的磁盘用量. 具体的参数可以用man或者--help, 这里不贴了(其实我也没仔细看...). 今天看见水源上有人说 用 -sh这个参数比较好:&lt;/p&gt;
&lt;p&gt;-s: 只计算各个目录的总用量(就是说不要递归操作) 后面跟着&lt;em&gt;或者.&lt;/em&gt;就可以查看各个目录的大小了.
-h: 易于查看的方式&lt;/p&gt;
&lt;p&gt;比如~/目录经常不知道为什么空间在减少, 那就运行:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;du -sh ~/*&lt;/code&gt; 以及 &lt;code&gt;du -sh /.*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;即可&lt;/p&gt;
&lt;p&gt;有时候文件夹比较多的情况, 还是不容易发现那个文件夹占用了大部分空间, 这时用sort命令对du的结果进行排序就行了!
参考了&lt;a href="http://www.xn--b0t733db8c.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12950504311.html"&gt;这里&lt;/a&gt;, 顺便学会了: 两条一起执行是用"|"进行分割的.&lt;/p&gt;
&lt;p&gt;所以命令为:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;du -sm ~/* | sort -nr
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意这时du不能用-h参数, 因为这样的话文件可能是以M为单位也可能是以k为单位, 而sort的时候只看前面的数字值, 不看单位. 用-m参数, 表示让所有结果以M为单位显示.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;imported from zim&lt;/strong&gt;&lt;/p&gt;</summary><category term="shell"></category></entry><entry><title>cmus--很棒的终端音乐播放器</title><link href="http://x-wei.github.io/cmus-%E5%BE%88%E6%A3%92%E7%9A%84%E7%BB%88%E7%AB%AF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8.html" rel="alternate"></link><updated>2012-01-23T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/cmus-很棒的终端音乐播放器.html</id><summary type="html">&lt;p&gt;最近发现一个终端下超好用的音乐播放器: &lt;a href="http://en.wikipedia.org/wiki/Cmus"&gt;CMUS&lt;/a&gt;. 界面简洁, vi的按键绑定, 由于最近越来越感觉键盘和快捷键的方便, 对这个迷你的播放器爱不释手.&lt;/p&gt;
&lt;p&gt;关于它的用法可以参考&lt;a href="http://www.tuxarena.com/static/cmus_guide.php"&gt;这里&lt;/a&gt;, 另外&lt;a href="http://roylez.heroku.com/2010/01/26/replay-gain.html"&gt;这里&lt;/a&gt;还介绍了怎么设置replay gain(大概是不同音乐播放的音量相同), 但我没有设置.&lt;/p&gt;
&lt;p&gt;网站上的文档不多, 我觉得最好的教程还是man:
man cmus
man cmus-tutorial
把tutorial看完就基本上会用了~&lt;/p&gt;
&lt;p&gt;这里列一下我觉得常用的几点吧:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1~7共7种view, 用数字键就可以切换;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用命令要想vi一样加':', 常见命令有:&lt;/p&gt;
&lt;p&gt;:cd xx_dir&lt;br /&gt;
:add xx_dir&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;c--暂停, hl/&amp;lt;&amp;gt;--快进快退, x--播放, v--停止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;右下角显示播放模式: R表示重复, S随机, C连续(播完一曲后不停)&lt;/li&gt;
&lt;/ol&gt;</summary></entry><entry><title>zip乱码解决</title><link href="http://x-wei.github.io/zip%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3.html" rel="alternate"></link><updated>2012-01-12T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/zip乱码解决.html</id><summary type="html">&lt;p&gt;这个问题困扰了很久, 以前的方法参考了&lt;a href="http://thiger.blog.hexun.com/46569055_d.html"&gt;这里&lt;/a&gt;, 使用一条命令:
&lt;code&gt;unzip -O CP936 xxx.zip&lt;/code&gt;
但是谁tm记得住? 所以每次都要上网现查...&lt;/p&gt;
&lt;p&gt;今天看到了ubuntu论坛上的&lt;a href="http://forum.ubuntu.org.cn/viewtopic.php?f=122&amp;amp;t=301951"&gt;帖子&lt;/a&gt;, 六楼给出了终极的解决方案. &lt;/p&gt;
&lt;p&gt;见附件: &lt;a href="./zip%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/zip%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3.zip"&gt;./zip乱码解决.zip&lt;/a&gt; 
这个压缩包中的5个 7z* 文件拷贝覆盖到/usr/lib/p7zip/&lt;/p&gt;
&lt;p&gt;代码:
&lt;code&gt;sudo cp 7z* /usr/lib/p7zip/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意以后不要升级p7zip&lt;/p&gt;
&lt;p&gt;一切就正常了! 而且打开时也没有乱码! so good!&lt;/p&gt;</summary><category term="中文乱码"></category></entry><entry><title>把抓图工具关联到ubuntu快捷键</title><link href="http://x-wei.github.io/scrshot-shortcut.html" rel="alternate"></link><updated>2012-01-10T00:00:00+01:00</updated><author><name>mx</name></author><id>http://x-wei.github.io/scrshot-shortcut.html</id><summary type="html">&lt;p&gt;终端输入gnome-screenshot --help, 发现选项"-a"表示的是抓取一部分屏幕.&lt;/p&gt;
&lt;p&gt;于是打开编辑键盘快捷键窗口, 新建一个快捷键如下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./scrshot-shortcut/pasted_image.png" /&gt;&lt;/p&gt;
&lt;p&gt;这样, 按下Ctrl+Alt+s快捷键后即可启动抓图, 且是抓取一个区域. 不过不知为什么, 反应比较慢, 需要按下一段时间  (一秒钟?)才会有反应.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;02/23/2012续:&lt;/strong&gt;
安装了lucid之后不好使了!
症状就是, 参数-a不起作用, 按下快捷键后直接出来桌面截图, 如果一直按着的话会出来选取区域的, 但是此时已经把桌面截了N次了!.... 无语啊!&lt;/p&gt;
&lt;p&gt;上网搜了好久,终于在&lt;a href="http://www.nenew.net/ubuntu-linux-gnome-screenshot-area.html"&gt;奶牛的博客&lt;/a&gt;里看见了方法: 命令参数变成 -ai, 这样每次按下快捷键后会先弹出来交互界面... 也罢...&lt;/p&gt;
&lt;p&gt;我非常无语...&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./scrshot-shortcut/pasted_image001.png" /&gt;&lt;/p&gt;
&lt;p&gt;嗯 就这样吧~...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--imported from zim&lt;/strong&gt;&lt;/p&gt;</summary><category term="tips"></category><category term="快捷键"></category></entry></feed>