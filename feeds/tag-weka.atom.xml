<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>mx's blog</title><link href="http://x-wei.github.io/" rel="alternate"></link><link href="http://x-wei.github.io/feeds/tag-weka.atom.xml" rel="self"></link><id>http://x-wei.github.io/</id><updated>2016-05-21T00:00:00+02:00</updated><entry><title>在java程序里使用weka进行机器学习</title><link href="http://x-wei.github.io/java-use-weka.html" rel="alternate"></link><published>2016-05-21T00:00:00+02:00</published><author><name>mx</name></author><id>tag:x-wei.github.io,2016-05-21:java-use-weka.html</id><summary type="html">&lt;p&gt;之前一直用weka的GUI界面做机器学习的任务, 感觉这个软件虽然界面丑, 不过确实是快速开展机器学期的利器. 关于GUI的weka使用以后有时间再写. 今天这篇记录一下最近使用的java版本的weka.   &lt;/p&gt;
&lt;h1 id="1-include-jars-into-project"&gt;1. Include jars into project&lt;/h1&gt;
&lt;p&gt;weka官网的下载链接里选择linux版本的weka压缩包即可, 下载以后找到weka.jar文件, 在工程里将其include一下就可以使用了(btw, 现在开始放弃eclipse, 进入IDEA的怀抱了...).   &lt;/p&gt;
&lt;p&gt;weka的文档在解压缩的文件里有, 另外在线文档在: &lt;a href="http://weka.sourceforge.net/doc.stable-3-8/"&gt;http://weka.sourceforge.net/doc.stable-3-8/&lt;/a&gt; &lt;/p&gt;
&lt;h3 id="about-libsvm"&gt;about libsvm...&lt;/h3&gt;
&lt;p&gt;关于libsvm需要有一点特别指出. weka自带的算法里是不包含libsvm的 (有个类似的SMO, 不过还是libsvm久经考验啊...), 需要使用weka的package manager安装. 打开package manager是在weka主界面的菜单里: &lt;br/&gt;
&lt;img alt="" class="img-responsive" src="../images/java-use-weka/pasted_image002.png"/&gt;&lt;br/&gt;
在package manager里搜索到libsvm安装即可. 然后(linux下)在主目录可以看到有个wekafiles文件夹, &lt;code&gt;wekafiles/packages/LibSVM/&lt;/code&gt;目录下就是libsvm的内容.   &lt;/p&gt;
&lt;p&gt;需要指出的一点是, 要使用libsvm的话, &lt;a href="http://stackoverflow.com/questions/30821926/solved-weka-api-libsvm-classpath-not-found"&gt;需要同时引用两个jar文件&lt;/a&gt;, 而且都叫libsvm.jar!!   &lt;/p&gt;
&lt;p&gt;这两个jar, 一个叫&lt;code&gt;LibSVM.jar&lt;/code&gt;, 在&lt;code&gt;wekafiles/packages/LibSVM/&lt;/code&gt;下, 另一个叫&lt;code&gt;libsvm.jar&lt;/code&gt;, 在&lt;code&gt;wekafiles/packages/LibSVM/lib/&lt;/code&gt;下...orz  &lt;/p&gt;
&lt;p&gt;如果只include第一个jar的话, 就会报错: "java.lang.Exception: libsvm classes not in CLASSPATH! ".   &lt;/p&gt;
&lt;h1 id="2-terminology"&gt;2. terminology&lt;/h1&gt;
&lt;p&gt;首先统一一下各种东西的叫法...  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Instances&lt;/code&gt;: 就是dataset, 比如training set或者test set, Instances实际上就是一个Instance的集合  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Instance&lt;/code&gt;: 就是一个数据点了  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Attribute&lt;/code&gt;: 一个数据点有一些attribute (别处一般叫做feature), 其中有一个attribute其实是label(可以为missing)  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Classifier&lt;/code&gt;: weka里的Classifer其实是也包含了regressor或者cluster... 后面都称之为model  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Evaluation&lt;/code&gt;: 给定一个model和一个dataset, 给出evaluation的数据, 类似GUI界面给出的那些内容  &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="3"&gt;3. 在程序里构建数据&lt;/h1&gt;
&lt;p&gt;这也是为什么要在java里用weka的原因: 如果数据可以直接以csv或者arff文件的方式得到, 那么直接在GUI界面下就可以搞了...  &lt;/p&gt;
&lt;h3 id="attribute"&gt;新建Attribute&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://weka.sourceforge.net/doc.stable-3-8/weka/core/Attribute.html"&gt;http://weka.sourceforge.net/doc.stable-3-8/weka/core/Attribute.html&lt;/a&gt; &lt;br/&gt;
新建numeric的attribue只要简单的在构造函数里传入一个attribute的名字即可:   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;// Create numeric attributes "length" and "weight"   &lt;/span&gt;
&lt;span class="code-line"&gt;Attribute length = new Attribute("length");   &lt;/span&gt;
&lt;span class="code-line"&gt;Attribute weight = new Attribute("weight");&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新建离散(normial)的attribue则需要一个list乘放所有可能的数值:   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;// Create list to hold nominal values "first", "second", "third"   &lt;/span&gt;
&lt;span class="code-line"&gt;List my_nominal_values = new ArrayList(3);   &lt;/span&gt;
&lt;span class="code-line"&gt;my_nominal_values.add("first");   &lt;/span&gt;
&lt;span class="code-line"&gt;my_nominal_values.add("second");   &lt;/span&gt;
&lt;span class="code-line"&gt;my_nominal_values.add("third");   &lt;/span&gt;
&lt;span class="code-line"&gt;// Create nominal attribute "position"   &lt;/span&gt;
&lt;span class="code-line"&gt;Attribute position = new Attribute("position", my_nominal_values);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="instancesdataset"&gt;新建Instances(dataset)&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://weka.sourceforge.net/doc.stable-3-8/weka/core/Instances.html"&gt;http://weka.sourceforge.net/doc.stable-3-8/weka/core/Instances.html&lt;/a&gt;&lt;br/&gt;
&lt;code&gt;Instances&lt;/code&gt;实际上就是一个&lt;code&gt;Instance&lt;/code&gt;的集合, Instances可以类比为pandas里面的DataFrame, 然后每个instance相当于一行. 另外&lt;code&gt;Instances&lt;/code&gt;比&lt;code&gt;Instance&lt;/code&gt;多的就是Attribute信息(类比为pandas里DataFrame的表头head).   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;Instances&lt;/code&gt;的构造函数有两种, 一种是直接在arff文件里读取, 这个后面再说. 另一种构造函数是在java函数里构建Instance时用的, 它构造一个空的Instance集合, 构造函数提供dataset的名字, attribute的集合(arraylist)以及初始的capacity:   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;Instances(String name, ArrayList&amp;lt;Attribute&amp;gt; attInfo, int capacity)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;其中的第二个参数attInfo其实就相当于是表头信息了, 它是一个Attribute的ArrayList.   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;ArrayList&amp;lt;Attribute&amp;gt; atts = new ArrayList&amp;lt;Attribute&amp;gt;();  &lt;/span&gt;
&lt;span class="code-line"&gt;atts.add(length);  &lt;/span&gt;
&lt;span class="code-line"&gt;atts.add(weight);  &lt;/span&gt;
&lt;span class="code-line"&gt;atts.add(position);  &lt;/span&gt;
&lt;span class="code-line"&gt;Instances adataset = new Instances("aDataSet", atts, 10);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(上面代码里的&lt;code&gt;length&lt;/code&gt;, &lt;code&gt;weight&lt;/code&gt; 和&lt;code&gt;position&lt;/code&gt;都是前面声明的Attribute对象)  &lt;/p&gt;
&lt;p&gt;Instances还可以指定哪一列对应的是class label (单个Instance则不能 — 因为单个Instance并没有表头信息attInfo):   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;void setClassIndex(int classIndex)&lt;/code&gt; &lt;/p&gt;
&lt;h3 id="instance"&gt;新建Instance&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://weka.sourceforge.net/doc.stable-3-8/weka/core/Instance.html"&gt;http://weka.sourceforge.net/doc.stable-3-8/weka/core/Instance.html&lt;/a&gt;&lt;br/&gt;
&lt;code&gt;Instance&lt;/code&gt;是一个接口而不是一个类, 一半常用的是&lt;code&gt;DenseInstance&lt;/code&gt;类(它又继承自&lt;code&gt;AbstractInstance&lt;/code&gt;抽象类)   &lt;/p&gt;
&lt;p&gt;这里有一个坑: 一定要指定Instance所属的DataSet(既它属于哪一个Instances对象)再使用setValue函数, 否则在调用setValue的时候可能会有问题!!!   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;void setDataset(Instances instances)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;构造函数里只需要提供这个instance的attribute数量即可. 然后使用&lt;code&gt;setValue&lt;/code&gt;函数可以给每个attribue指定数值. setValue函数的第一个参数接收一个Attribue对象, 第二个参数就是这个attribue的数值(double或者string).   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;// Create empty instance with three attribute values   &lt;/span&gt;
&lt;span class="code-line"&gt;Instance inst = new DenseInstance(3);   &lt;/span&gt;
&lt;span class="code-line"&gt;instance.setDataset(  adataset); // before calling setValue, should first set the Dataset!``  &lt;/span&gt;
&lt;span class="code-line"&gt;// Set instance's values for the attributes "length", "weight", and "position"  &lt;/span&gt;
&lt;span class="code-line"&gt;inst.setValue(length, 5.3);   &lt;/span&gt;
&lt;span class="code-line"&gt;inst.setValue(weight, 300);   &lt;/span&gt;
&lt;span class="code-line"&gt;inst.setValue(position, "first");&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="4-model"&gt;4. 在程序里训练model&lt;/h1&gt;
&lt;p&gt;这里只做classification的例子好了. &lt;br/&gt;
&lt;a href="http://weka.sourceforge.net/doc.stable-3-8/weka/classifiers/Classifier.html"&gt;http://weka.sourceforge.net/doc.stable-3-8/weka/classifiers/Classifier.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;Classifier是一个Interface, 可以在文档里看到有很多类都实现了这个interface, 主要是三个常用的函数:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void buildClassifier(Instances data)&lt;/code&gt; : 用data数据进行训练  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;double   classifyInstance(Instance instance)&lt;/code&gt; : 预测一个Instance的label  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;double[] distributionForInstance(Instance instance)&lt;/code&gt; :对于每一个可能的类, 给一个probability, 返回一个double数组  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以程序里训练model只需要调用&lt;code&gt;buildClassifier()&lt;/code&gt;函数即可.   &lt;/p&gt;
&lt;h1 id="5-model"&gt;5. 从文件读入数据和model&lt;/h1&gt;
&lt;p&gt;之前讲的是在程序里得到数据, 在程序里储存结果的方法, 而如果可以保存数据到文件的话, 在GUI界面下调试模型应该更加放方便.   &lt;/p&gt;
&lt;p&gt;预先已经得到了数据的话, 可以先把数据保存问arff格式, 然后用GUI的weka训练和调试参数. 当得到满意的结果以后可以在GUI界面里选择保存训练好的模型(一个.model文件): &lt;br/&gt;
&lt;img alt="" class="img-responsive" src="../images/java-use-weka/pasted_image001.png"/&gt; &lt;/p&gt;
&lt;p&gt;然后, weka提供了非常方便的方法, 直接从arff文件里得到&lt;code&gt;Instances&lt;/code&gt;对象, 从model文件里得到&lt;code&gt;Classifier&lt;/code&gt;对象: &lt;br/&gt;
(参考链接: &lt;a href="https://weka.wikispaces.com/Serialization"&gt;https://weka.wikispaces.com/Serialization&lt;/a&gt; 以及 &lt;a href="https://weka.wikispaces.com/Use+Weka+in+your+Java+code"&gt;https://weka.wikispaces.com/Use+Weka+in+your+Java+code&lt;/a&gt;)  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;Classifier clf = (Classifier) weka.core.SerializationHelper.read("/some/where/j48.model");  &lt;/span&gt;
&lt;span class="code-line"&gt;Instances testset = new Instances(new BufferedReader(new FileReader("/some/where/test.arff")));``&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="6-evaluation"&gt;6. 输出Evaluation统计&lt;/h1&gt;
&lt;p&gt;当得到了训练好的模型&lt;code&gt;clf&lt;/code&gt;以及要使用的测试数据&lt;code&gt;testset&lt;/code&gt;以后, 可以在testset上测试模型, 并输出结果的统计数据. 这些是靠&lt;code&gt;Evaluation&lt;/code&gt;类完成的.&lt;br/&gt;
&lt;a href="http://weka.sourceforge.net/doc.stable-3-8/weka/classifiers/evaluation/Evaluation.html"&gt;http://weka.sourceforge.net/doc.stable-3-8/weka/classifiers/evaluation/Evaluation.html&lt;/a&gt;&lt;br/&gt;
Evaluation的构造函数里提供的Instances应该为training set, 这个训练集的作用是"to get some header information and prior class distribution information", 如果构造时给的是testing set的话, 应该调用&lt;code&gt;useNoPriors()&lt;/code&gt;函数一下.   &lt;/p&gt;
&lt;p&gt;构造了evalation对象以后, 只要使用 &lt;code&gt;evaluateModel(Classifier classifier, Instances data)&lt;/code&gt; 函数即可, 第一个参数为训练好了的模型(&lt;code&gt;clf&lt;/code&gt;), 第二个参数为要用来测试的数据(&lt;code&gt;testset&lt;/code&gt;).   &lt;/p&gt;
&lt;p&gt;然后可以输出统计信息, 就像在wekaGUI界面一样, 主要靠&lt;code&gt;toSummaryString()&lt;/code&gt;和&lt;code&gt;toMatrixString()&lt;/code&gt;两个函数.   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;Instances trainInstances = ... instances got from somewhere  &lt;/span&gt;
&lt;span class="code-line"&gt;Instances testInstances = ... instances got from somewhere  &lt;/span&gt;
&lt;span class="code-line"&gt;Classifier scheme = ... scheme got from somewhere&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;Evaluation evaluation = new Evaluation(trainInstances);  &lt;/span&gt;
&lt;span class="code-line"&gt;evaluation.evaluateModel(scheme, testInstances);  &lt;/span&gt;
&lt;span class="code-line"&gt;System.out.println(evaluation.toSummaryString());  &lt;/span&gt;
&lt;span class="code-line"&gt;System.out.println(evaluation.toMatrixString());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="7"&gt;7. 输出预测结果&lt;/h1&gt;
&lt;p&gt;对于每一个Instance, 只需要调用Classifier的&lt;code&gt;classifyInstance(Instance instance)&lt;/code&gt;或者&lt;code&gt;distributionForInstance(Instance instance)&lt;/code&gt;函数, 即可得到预测结果...   &lt;/p&gt;
&lt;p&gt;Voila, 大概就是这样, weka这个工具还是蛮好用的(只要能忍受它界面的丑), 而且也算没有太多的坑...   &lt;/p&gt;</summary><category term="ml"></category><category term="weka"></category><category term="java"></category></entry></feed>